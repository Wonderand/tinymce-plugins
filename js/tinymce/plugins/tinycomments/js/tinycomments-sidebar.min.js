/*!
 * Tiny Comments plugin
 *
 * Copyright (c) 2023 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 7.3.0-86
 */

!function() {
    "use strict";
    const e = Object.getPrototypeOf
      , t = (e,t,n)=>{
        var o;
        return !!n(e, t.prototype) || (null === (o = e.constructor) || void 0 === o ? void 0 : o.name) === t.name
    }
      , n = e=>n=>(e=>{
        const n = typeof e;
        return null === e ? "null" : "object" === n && Array.isArray(e) ? "array" : "object" === n && t(e, String, ((e,t)=>t.isPrototypeOf(e))) ? "string" : n
    }
    )(n) === e
      , o = e=>t=>typeof t === e
      , r = n("string")
      , s = n("object")
      , a = n=>((n,o)=>s(n) && t(n, o, ((t,n)=>e(t) === n)))(n, Object)
      , i = n("array")
      , c = o("boolean")
      , l = (void 0,
    e=>undefined === e);
    const u = e=>null == e
      , d = e=>!u(e)
      , m = o("function")
      , g = o("number")
      , p = ()=>{}
      , h = (e,t)=>(...n)=>e(t.apply(null, n))
      , v = e=>()=>e
      , f = e=>e
      , b = (e,t)=>e === t;
    function y(e, ...t) {
        return (...n)=>{
            const o = t.concat(n);
            return e.apply(null, o)
        }
    }
    const _ = e=>()=>{
        throw new Error(e)
    }
      , x = e=>e()
      , w = v(!1)
      , O = v(!0)
      , S = v("dismiss.popups")
      , C = v("reposition.popups");
    class E {
        constructor(e, t) {
            this.tag = e,
            this.value = t
        }
        static some(e) {
            return new E(!0,e)
        }
        static none() {
            return E.singletonNone
        }
        fold(e, t) {
            return this.tag ? t(this.value) : e()
        }
        isSome() {
            return this.tag
        }
        isNone() {
            return !this.tag
        }
        map(e) {
            return this.tag ? E.some(e(this.value)) : E.none()
        }
        bind(e) {
            return this.tag ? e(this.value) : E.none()
        }
        exists(e) {
            return this.tag && e(this.value)
        }
        forall(e) {
            return !this.tag || e(this.value)
        }
        filter(e) {
            return !this.tag || e(this.value) ? this : E.none()
        }
        getOr(e) {
            return this.tag ? this.value : e
        }
        or(e) {
            return this.tag ? this : e
        }
        getOrThunk(e) {
            return this.tag ? this.value : e()
        }
        orThunk(e) {
            return this.tag ? this : e()
        }
        getOrDie(e) {
            if (this.tag)
                return this.value;
            throw new Error(null != e ? e : "Called getOrDie on None")
        }
        static from(e) {
            return d(e) ? E.some(e) : E.none()
        }
        getOrNull() {
            return this.tag ? this.value : null
        }
        getOrUndefined() {
            return this.value
        }
        each(e) {
            this.tag && e(this.value)
        }
        toArray() {
            return this.tag ? [this.value] : []
        }
        toString() {
            return this.tag ? `some(${this.value})` : "none()"
        }
    }
    E.singletonNone = new E(!1);
    const k = e=>{
        if (null == e)
            throw new Error("Node cannot be null or undefined");
        return {
            dom: e
        }
    }
      , T = (e,t)=>{
        const n = (t || document).createElement("div");
        if (n.innerHTML = e,
        !n.hasChildNodes() || n.childNodes.length > 1) {
            const t = "HTML does not have a single root node";
            throw console.error(t, e),
            new Error(t)
        }
        return k(n.childNodes[0])
    }
      , M = (e,t)=>{
        const n = (t || document).createElement(e);
        return k(n)
    }
      , A = (e,t)=>{
        const n = (t || document).createTextNode(e);
        return k(n)
    }
      , R = k;
    var N = function(e) {
        if (null === e)
            return "null";
        if (void 0 === e)
            return "undefined";
        var t = typeof e;
        return "object" === t && (Array.prototype.isPrototypeOf(e) || e.constructor && "Array" === e.constructor.name) ? "array" : "object" === t && (String.prototype.isPrototypeOf(e) || e.constructor && "String" === e.constructor.name) ? "string" : t
    }
      , B = function(e) {
        return {
            eq: e
        }
    }
      , F = B((function(e, t) {
        return e === t
    }
    ))
      , D = F
      , H = function(e) {
        return B((function(t, n) {
            if (t.length !== n.length)
                return !1;
            for (var o = t.length, r = 0; r < o; r++)
                if (!e.eq(t[r], n[r]))
                    return !1;
            return !0
        }
        ))
    }
      , I = B((function(e, t) {
        if (e === t)
            return !0;
        var n, o = N(e);
        return o === N(t) && (function(e) {
            return -1 !== ["undefined", "boolean", "number", "string", "function", "xml", "null"].indexOf(e)
        }(o) ? e === t : "array" === o ? H(I).eq(e, t) : "object" === o && (n = I,
        B((function(e, t) {
            var o = Object.keys(e)
              , r = Object.keys(t);
            if (!function(e, t) {
                return function(e, t) {
                    return B((function(n, o) {
                        return e.eq(t(n), t(o))
                    }
                    ))
                }(H(e), (function(e) {
                    return function(e, t) {
                        return Array.prototype.slice.call(e).sort(t)
                    }(e, t)
                }
                ))
            }(D).eq(o, r))
                return !1;
            for (var s = o.length, a = 0; a < s; a++) {
                var i = o[a];
                if (!n.eq(e[i], t[i]))
                    return !1
            }
            return !0
        }
        ))).eq(e, t))
    }
    ));
    const P = Array.prototype.slice
      , V = Array.prototype.indexOf
      , W = Array.prototype.push
      , L = (e,t)=>((e,t)=>V.call(e, t))(e, t) > -1
      , U = (e,t)=>{
        for (let n = 0, o = e.length; n < o; n++)
            if (t(e[n], n))
                return !0;
        return !1
    }
      , j = (e,t)=>{
        const n = e.length
          , o = new Array(n);
        for (let r = 0; r < n; r++) {
            const n = e[r];
            o[r] = t(n, r)
        }
        return o
    }
      , z = (e,t)=>{
        for (let n = 0, o = e.length; n < o; n++)
            t(e[n], n)
    }
      , $ = (e,t)=>{
        const n = [];
        for (let o = 0, r = e.length; o < r; o++) {
            const r = e[o];
            t(r, o) && n.push(r)
        }
        return n
    }
      , q = (e,t,n)=>(((e,t)=>{
        for (let n = e.length - 1; n >= 0; n--)
            t(e[n], n)
    }
    )(e, ((e,o)=>{
        n = t(n, e, o)
    }
    )),
    n)
      , G = (e,t,n)=>(z(e, ((e,o)=>{
        n = t(n, e, o)
    }
    )),
    n)
      , K = (e,t)=>((e,t,n)=>{
        for (let o = 0, r = e.length; o < r; o++) {
            const r = e[o];
            if (t(r, o))
                return E.some(r);
            if (n(r, o))
                break
        }
        return E.none()
    }
    )(e, t, w)
      , Y = (e,t)=>{
        for (let n = 0, o = e.length; n < o; n++)
            if (t(e[n], n))
                return E.some(n);
        return E.none()
    }
      , Q = e=>{
        const t = [];
        for (let n = 0, o = e.length; n < o; ++n) {
            if (!i(e[n]))
                throw new Error("Arr.flatten item " + n + " was not an array, input: " + e);
            W.apply(t, e[n])
        }
        return t
    }
      , J = (e,t)=>Q(j(e, t))
      , X = (e,t)=>{
        for (let n = 0, o = e.length; n < o; ++n)
            if (!0 !== t(e[n], n))
                return !1;
        return !0
    }
      , Z = e=>{
        const t = P.call(e, 0);
        return t.reverse(),
        t
    }
      , ee = (e,t)=>$(e, (e=>!L(t, e)))
      , te = (e,t)=>{
        const n = {};
        for (let o = 0, r = e.length; o < r; o++) {
            const r = e[o];
            n[String(r)] = t(r, o)
        }
        return n
    }
      , ne = e=>[e]
      , oe = (e,t)=>t >= 0 && t < e.length ? E.some(e[t]) : E.none()
      , re = e=>oe(e, 0)
      , se = (e,t)=>{
        for (let n = 0; n < e.length; n++) {
            const o = t(e[n], n);
            if (o.isSome())
                return o
        }
        return E.none()
    }
      , ae = (e,t)=>{
        const n = e.dom;
        if (1 !== n.nodeType)
            return !1;
        {
            const e = n;
            if (void 0 !== e.matches)
                return e.matches(t);
            if (void 0 !== e.msMatchesSelector)
                return e.msMatchesSelector(t);
            if (void 0 !== e.webkitMatchesSelector)
                return e.webkitMatchesSelector(t);
            if (void 0 !== e.mozMatchesSelector)
                return e.mozMatchesSelector(t);
            throw new Error("Browser lacks native selectors")
        }
    }
      , ie = e=>1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType || 0 === e.childElementCount
      , ce = (e,t)=>e.dom === t.dom;
    "undefined" != typeof window ? window : Function("return this;")();
    const le = e=>e.dom.nodeName.toLowerCase()
      , ue = e=>t=>(e=>e.dom.nodeType)(t) === e
      , de = ue(1)
      , me = ue(3)
      , ge = ue(9)
      , pe = ue(11)
      , he = e=>t=>de(t) && le(t) === e
      , ve = e=>R(e.dom.ownerDocument)
      , fe = e=>{
        return R((t = e,
        ge(t) ? t : ve(t)).dom.defaultView);
        var t
    }
      , be = e=>E.from(e.dom.parentNode).map(R)
      , ye = e=>E.from(e.dom.parentElement).map(R)
      , _e = e=>j(e.dom.childNodes, R)
      , xe = (e,t)=>{
        const n = e.dom.childNodes;
        return E.from(n[t]).map(R)
    }
      , we = e=>xe(e, 0)
      , Oe = e=>pe(e) && d(e.dom.host)
      , Se = e=>R(e.dom.getRootNode())
      , Ce = e=>R(e.dom.host)
      , Ee = e=>{
        const t = R((e=>{
            if (d(e.target)) {
                const t = R(e.target);
                if (de(t) && (e=>d(e.dom.shadowRoot))(t) && e.composed && e.composedPath) {
                    const t = e.composedPath();
                    if (t)
                        return re(t)
                }
            }
            return E.from(e.target)
        }
        )(e).getOr(e.target))
          , n = ()=>e.stopPropagation()
          , o = ()=>e.preventDefault()
          , r = h(o, n);
        return ((e,t,n,o,r,s,a)=>({
            target: e,
            x: t,
            y: n,
            stop: o,
            prevent: r,
            kill: s,
            raw: a
        }))(t, e.clientX, e.clientY, n, o, r, e)
    }
      , ke = (e,t,n,o)=>{
        e.dom.removeEventListener(t, n, o)
    }
      , Te = O
      , Me = (e,t,n)=>((e,t,n,o)=>((e,t,n,o,r)=>{
        const s = ((e,t)=>n=>{
            e(n) && t(Ee(n))
        }
        )(n, o);
        return e.dom.addEventListener(t, s, r),
        {
            unbind: y(ke, e, t, s, r)
        }
    }
    )(e, t, n, o, !1))(e, t, Te, n)
      , Ae = (e,t)=>{
        be(e).each((n=>{
            n.dom.insertBefore(t.dom, e.dom)
        }
        ))
    }
      , Re = (e,t)=>{
        we(e).fold((()=>{
            Ne(e, t)
        }
        ), (n=>{
            e.dom.insertBefore(t.dom, n.dom)
        }
        ))
    }
      , Ne = (e,t)=>{
        e.dom.appendChild(t.dom)
    }
      , Be = Object.keys
      , Fe = Object.hasOwnProperty
      , De = (e,t)=>{
        const n = Be(e);
        for (let o = 0, r = n.length; o < r; o++) {
            const r = n[o];
            t(e[r], r)
        }
    }
      , He = (e,t)=>Ie(e, ((e,n)=>({
        k: n,
        v: t(e, n)
    })))
      , Ie = (e,t)=>{
        const n = {};
        return De(e, ((e,o)=>{
            const r = t(e, o);
            n[r.k] = r.v
        }
        )),
        n
    }
      , Pe = e=>(t,n)=>{
        e[n] = t
    }
      , Ve = (e,t,n,o)=>{
        De(e, ((e,r)=>{
            (t(e, r) ? n : o)(e, r)
        }
        ))
    }
      , We = (e,t)=>{
        const n = {};
        return Ve(e, t, Pe(n), p),
        n
    }
      , Le = (e,t)=>{
        const n = [];
        return De(e, ((e,o)=>{
            n.push(t(e, o))
        }
        )),
        n
    }
      , Ue = (e,t)=>{
        const n = Be(e);
        for (let o = 0, r = n.length; o < r; o++) {
            const r = n[o]
              , s = e[r];
            if (t(s, r, e))
                return E.some(s)
        }
        return E.none()
    }
      , je = (e,t)=>ze(e, t) ? E.from(e[t]) : E.none()
      , ze = (e,t)=>Fe.call(e, t)
      , $e = (e,t)=>ze(e, t) && void 0 !== e[t] && null !== e[t]
      , qe = v("tinycomments")
      , Ge = v("data-mce-annotation")
      , Ke = e=>{
        let t = E.none()
          , n = [];
        const o = e=>{
            r() ? s(e) : n.push(e)
        }
          , r = ()=>t.isSome()
          , s = e=>{
            t.each((t=>{
                setTimeout((()=>{
                    e(t)
                }
                ), 0)
            }
            ))
        }
        ;
        return e((e=>{
            r() || (t = E.some(e),
            z(n, s),
            n = [])
        }
        )),
        {
            get: o,
            map: e=>Ke((t=>{
                o((n=>{
                    t(e(n))
                }
                ))
            }
            )),
            isReady: r
        }
    }
      , Ye = {
        nu: Ke,
        pure: e=>Ke((t=>{
            t(e)
        }
        ))
    }
      , Qe = e=>{
        setTimeout((()=>{
            throw e
        }
        ), 0)
    }
      , Je = e=>{
        const t = t=>{
            e().then(t, Qe)
        }
        ;
        return {
            map: t=>Je((()=>e().then(t))),
            bind: t=>Je((()=>e().then((e=>t(e).toPromise())))),
            anonBind: t=>Je((()=>e().then((()=>t.toPromise())))),
            toLazy: ()=>Ye.nu(t),
            toCached: ()=>{
                let t = null;
                return Je((()=>(null === t && (t = e()),
                t)))
            }
            ,
            toPromise: e,
            get: t
        }
    }
      , Xe = e=>Je((()=>new Promise(e)))
      , Ze = e=>Je((()=>Promise.resolve(e)))
      , et = e=>{
        const t = t=>t(e)
          , n = v(e)
          , o = ()=>r
          , r = {
            tag: !0,
            inner: e,
            fold: (t,n)=>n(e),
            isValue: O,
            isError: w,
            map: t=>nt.value(t(e)),
            mapError: o,
            bind: t,
            exists: t,
            forall: t,
            getOr: n,
            or: o,
            getOrThunk: n,
            orThunk: o,
            getOrDie: n,
            each: t=>{
                t(e)
            }
            ,
            toOptional: ()=>E.some(e)
        };
        return r
    }
      , tt = e=>{
        const t = ()=>n
          , n = {
            tag: !1,
            inner: e,
            fold: (t,n)=>t(e),
            isValue: w,
            isError: O,
            map: t,
            mapError: t=>nt.error(t(e)),
            bind: t,
            exists: w,
            forall: O,
            getOr: f,
            or: f,
            getOrThunk: x,
            orThunk: x,
            getOrDie: _(String(e)),
            each: p,
            toOptional: E.none
        };
        return n
    }
      , nt = {
        value: et,
        error: tt,
        fromOption: (e,t)=>e.fold((()=>tt(t)), et)
    }
      , ot = e=>({
        ...e,
        toCached: ()=>ot(e.toCached()),
        bindFuture: t=>ot(e.bind((e=>e.fold((e=>Ze(nt.error(e))), (e=>t(e)))))),
        bindResult: t=>ot(e.map((e=>e.bind(t)))),
        mapResult: t=>ot(e.map((e=>e.map(t)))),
        mapError: t=>ot(e.map((e=>e.mapError(t)))),
        foldResult: (t,n)=>e.map((e=>e.fold(t, n))),
        withTimeout: (t,n)=>ot(Xe((o=>{
            let r = !1;
            const s = setTimeout((()=>{
                r = !0,
                o(nt.error(n()))
            }
            ), t);
            e.get((e=>{
                r || (clearTimeout(s),
                o(e))
            }
            ))
        }
        )))
    })
      , rt = e=>ot(Xe(e))
      , st = e=>ot(Ze(nt.value(e)))
      , at = {
        nu: rt,
        wrap: ot,
        pure: st,
        value: st,
        error: e=>ot(Ze(nt.error(e))),
        fromResult: e=>ot(Ze(e)),
        fromFuture: e=>ot(e.map(nt.value)),
        fromPromise: e=>rt((t=>{
            e.then((e=>{
                t(nt.value(e))
            }
            ), (e=>{
                t(nt.error(e))
            }
            ))
        }
        ))
    }
      , it = e=>{
        const t = me(e) ? e.dom.parentNode : e.dom;
        if (null == t || null === t.ownerDocument)
            return !1;
        const n = t.ownerDocument;
        return (e=>{
            const t = Se(e);
            return Oe(t) ? E.some(t) : E.none()
        }
        )(R(t)).fold((()=>n.body.contains(t)), (o = it,
        r = Ce,
        e=>o(r(e))));
        var o, r
    }
      , ct = (e,t)=>((e,t)=>{
        const n = void 0 === t ? document : t.dom;
        return ie(n) ? [] : j(n.querySelectorAll(e), R)
    }
    )(t, e);
    var lt;
    !function(e) {
        e[e.Error = 0] = "Error",
        e[e.Value = 1] = "Value"
    }(lt || (lt = {}));
    const ut = (e,t,n)=>e.stype === lt.Error ? t(e.serror) : n(e.svalue)
      , dt = e=>({
        stype: lt.Value,
        svalue: e
    })
      , mt = e=>({
        stype: lt.Error,
        serror: e
    })
      , gt = dt
      , pt = mt
      , ht = ut
      , vt = (e,t,n,o)=>({
        tag: "field",
        key: e,
        newKey: t,
        presence: n,
        prop: o
    })
      , ft = (e,t,n)=>{
        switch (e.tag) {
        case "field":
            return t(e.key, e.newKey, e.presence, e.prop);
        case "custom":
            return n(e.newKey, e.instantiator)
        }
    }
      , bt = e=>(...t)=>{
        if (0 === t.length)
            throw new Error("Can't merge zero objects");
        const n = {};
        for (let o = 0; o < t.length; o++) {
            const r = t[o];
            for (const t in r)
                ze(r, t) && (n[t] = e(n[t], r[t]))
        }
        return n
    }
      , yt = bt(((e,t)=>a(e) && a(t) ? yt(e, t) : t))
      , _t = bt(((e,t)=>t))
      , xt = e=>{
        let t, n = !1;
        return (...o)=>(n || (n = !0,
        t = e.apply(null, o)),
        t)
    }
      , wt = e=>({
        tag: "defaultedThunk",
        process: e
    })
      , Ot = e=>wt(v(e))
      , St = e=>({
        tag: "mergeWithThunk",
        process: e
    })
      , Ct = e=>{
        const t = (e=>{
            const t = []
              , n = [];
            return z(e, (e=>{
                ut(e, (e=>n.push(e)), (e=>t.push(e)))
            }
            )),
            {
                values: t,
                errors: n
            }
        }
        )(e);
        return t.errors.length > 0 ? (n = t.errors,
        h(pt, Q)(n)) : gt(t.values);
        var n
    }
      , Et = e=>s(e) && Be(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2)
      , kt = (e,t)=>pt([{
        path: e,
        getErrorInfo: t
    }])
      , Tt = e=>({
        extract: (t,n)=>((e,t)=>e.stype === lt.Error ? t(e.serror) : e)(e(n), (e=>((e,t)=>kt(e, v(t)))(t, e))),
        toString: v("val")
    })
      , Mt = Tt(gt)
      , At = (e,t,n,o)=>o(je(e, t).getOrThunk((()=>n(e))))
      , Rt = (e,t,n,o,r)=>{
        const s = e=>r.extract(t.concat([o]), e)
          , a = e=>e.fold((()=>gt(E.none())), (e=>((e,t)=>e.stype === lt.Value ? {
            stype: lt.Value,
            svalue: t(e.svalue)
        } : e)(r.extract(t.concat([o]), e), E.some)));
        switch (e.tag) {
        case "required":
            return ((e,t,n,o)=>je(t, n).fold((()=>((e,t,n)=>kt(e, (()=>'Could not find valid *required* value for "' + t + '" in ' + Et(n))))(e, n, t)), o))(t, n, o, s);
        case "defaultedThunk":
            return At(n, o, e.process, s);
        case "option":
            return ((e,t,n)=>n(je(e, t)))(n, o, a);
        case "defaultedOptionThunk":
            return ((e,t,n,o)=>o(je(e, t).map((t=>!0 === t ? n(e) : t))))(n, o, e.process, a);
        case "mergeWithThunk":
            return At(n, o, v({}), (t=>{
                const o = yt(e.process(n), t);
                return s(o)
            }
            ))
        }
    }
      , Nt = e=>Be(We(e, d))
      , Bt = e=>{
        const t = Ft(e)
          , n = q(e, ((e,t)=>ft(t, (t=>yt(e, {
            [t]: !0
        })), v(e))), {});
        return {
            extract: (e,o)=>{
                const r = c(o) ? [] : Nt(o)
                  , s = $(r, (e=>!$e(n, e)));
                return 0 === s.length ? t.extract(e, o) : ((e,t)=>kt(e, (()=>"There are unsupported fields: [" + t.join(", ") + "] specified")))(e, s)
            }
            ,
            toString: t.toString
        }
    }
      , Ft = e=>({
        extract: (t,n)=>((e,t,n)=>{
            const o = {}
              , r = [];
            for (const s of n)
                ft(s, ((n,s,a,i)=>{
                    const c = Rt(a, e, t, n, i);
                    ht(c, (e=>{
                        r.push(...e)
                    }
                    ), (e=>{
                        o[s] = e
                    }
                    ))
                }
                ), ((e,n)=>{
                    o[e] = n(t)
                }
                ));
            return r.length > 0 ? pt(r) : gt(o)
        }
        )(t, n, e),
        toString: ()=>{
            const t = j(e, (e=>ft(e, ((e,t,n,o)=>e + " -> " + o.toString()), ((e,t)=>"state(" + e + ")"))));
            return "obj{\n" + t.join("\n") + "}"
        }
    })
      , Dt = e=>({
        extract: (t,n)=>{
            const o = j(n, ((n,o)=>e.extract(t.concat(["[" + o + "]"]), n)));
            return Ct(o)
        }
        ,
        toString: ()=>"array(" + e.toString() + ")"
    })
      , Ht = (e,t)=>({
        extract: (n,o)=>{
            const r = Be(o)
              , s = ((t,n)=>Dt(Tt(e)).extract(t, n))(n, r);
            return ((e,t)=>e.stype === lt.Value ? t(e.svalue) : e)(s, (e=>{
                const r = j(e, (e=>vt(e, e, {
                    tag: "required",
                    process: {}
                }, t)));
                return Ft(r).extract(n, o)
            }
            ))
        }
        ,
        toString: ()=>"setOf(" + t.toString() + ")"
    })
      , It = v(Mt)
      , Pt = (e,t)=>Tt((n=>{
        const o = typeof n;
        return e(n) ? gt(n) : pt(`Expected type: ${t} but got: ${o}`)
    }
    ))
      , Vt = Pt(r, "string")
      , Wt = Pt(c, "boolean")
      , Lt = Pt(m, "function")
      , Ut = (e,t)=>({
        extract: (n,o)=>je(o, e).fold((()=>((e,t)=>kt(e, (()=>'Choice schema did not contain choice key: "' + t + '"')))(n, e)), (e=>((e,t,n,o)=>je(n, o).fold((()=>((e,t,n)=>kt(e, (()=>'The chosen schema: "' + n + '" did not exist in branches: ' + Et(t))))(e, n, o)), (n=>n.extract(e.concat(["branch: " + o]), t))))(n, o, t, e))),
        toString: ()=>"chooseOn(" + e + "). Possible values: " + Be(t)
    })
      , jt = e=>Tt((t=>e(t).fold(pt, gt)))
      , zt = (e,t)=>Ht((t=>e(t).fold(mt, dt)), t)
      , $t = (e,t,n)=>{
        return o = ((e,t,n)=>((e,t)=>e.stype === lt.Error ? {
            stype: lt.Error,
            serror: t(e.serror)
        } : e)(t.extract([e], n), (e=>({
            input: n,
            errors: e
        }))))(e, t, n),
        ut(o, nt.error, nt.value);
        var o
    }
      , qt = e=>e.fold((e=>{
        throw new Error(Kt(e))
    }
    ), f)
      , Gt = (e,t,n)=>qt($t(e, t, n))
      , Kt = e=>"Errors: \n" + (e=>{
        const t = e.length > 10 ? e.slice(0, 10).concat([{
            path: [],
            getErrorInfo: v("... (only showing first ten failures)")
        }]) : e;
        return j(t, (e=>"Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo()))
    }
    )(e.errors).join("\n") + "\n\nInput object: " + Et(e.input)
      , Yt = (e,t)=>Ut(e, He(t, Ft))
      , Qt = vt
      , Jt = (e,t)=>({
        tag: "custom",
        newKey: e,
        instantiator: t
    })
      , Xt = e=>Qt(e, e, {
        tag: "required",
        process: {}
    }, It())
      , Zt = (e,t)=>Qt(e, e, {
        tag: "required",
        process: {}
    }, t)
      , en = e=>Zt(e, Wt)
      , tn = (e,t)=>Qt(e, e, {
        tag: "required",
        process: {}
    }, Ft(t))
      , nn = e=>Qt(e, e, {
        tag: "option",
        process: {}
    }, It())
      , on = (e,t)=>Qt(e, e, {
        tag: "option",
        process: {}
    }, t)
      , rn = (e,t)=>on(e, Ft(t))
      , sn = (e,t)=>on(e, Bt(t))
      , an = (e,t)=>Qt(e, e, Ot(t), It())
      , cn = (e,t,n)=>Qt(e, e, Ot(t), n)
      , ln = Bt([en("readonly"), en("invalidSelection"), en("saving")])
      , un = e=>e.readonly || e.invalidSelection
      , dn = e=>un(e) || e.saving
      , mn = he("hr");
    var gn;
    !function(e) {
        e[e.Change = 0] = "Change",
        e[e.NoChange = 1] = "NoChange"
    }(gn || (gn = {}));
    const pn = (e,t,n,o)=>{
        let r = {
            readonly: !1,
            saving: !1,
            invalidSelection: !1
        };
        const s = (e,t)=>{
            n.notificationManager.open({
                text: e,
                type: "error"
            }),
            t && console.error(e, t)
        }
          , a = (e,t)=>({
            view: {
                type: "splash"
            },
            grabFocus: ()=>1 === e || t
        })
          , i = (e,t,n)=>({
            view: {
                type: "comments",
                conversation: n
            },
            grabFocus: ()=>t || L([1, 3, 4], e)
        })
          , c = (n,r)=>{
            t.set(n),
            t.get().fold((()=>at.pure({
                response: gn.Change,
                update: a(r, o.hasFocus())
            })), (n=>e.lookup({
                conversationUid: n
            }).foldResult((()=>nt.value({
                response: gn.Change,
                update: a(r, o.hasFocus())
            })), (e=>{
                const n = t.get().forall((t=>t !== e.conversation.uid));
                return nt.value(n ? {
                    response: gn.NoChange
                } : {
                    response: gn.Change,
                    update: i(r, o.hasFocus(), e.conversation)
                })
            }
            )))).get((e=>e.fold((e=>{
                s("An error occurred reading the conversation. See the Console for details.", e)
            }
            ), (e=>{
                e.response === gn.Change && (e.update && o.update(e.update),
                p())
            }
            ))))
        }
          , l = e=>{
            r = {
                ...r,
                readonly: e
            },
            g()
        }
          , m = e=>{
            r = {
                ...r,
                invalidSelection: e
            },
            g()
        }
          , g = ()=>{
            o.sendGlobalUiState(r),
            (e=>{
                e.dispatch("mce-tinycomments-uistate-updated")
            }
            )(n)
        }
          , p = ()=>(t.get().isSome() || u(n.selection) ? (l(!1),
        m(!1)) : m((e=>{
            const t = R(e.selection.getNode())
              , n = R(e.selection.getStart());
            return (e=>{
                let t = e.selection.getRng().commonAncestorContainer;
                return 3 === t.nodeType && (t = t.parentNode),
                !!d(t) && e.dom.isEmpty(t)
            }
            )(e) || mn(t) || mn(n)
        }
        )(n) || (()=>{
            const e = (e,t,n)=>{
                const o = t.createRange();
                return o.selectNode(n.dom),
                o.compareBoundaryPoints(window.Range.END_TO_START, e) < 0 && o.compareBoundaryPoints(window.Range.START_TO_END, e) > 0
            }
            ;
            if (n.selection) {
                const t = n.selection.getRng()
                  , o = ct(R(t.commonAncestorContainer), `[${Ge()}="${qe()}"]`);
                return U(o, y(e, t, n.getDoc()))
            }
            return !1
        }
        )()),
        un(r));
        return {
            refreshSidebar: c,
            refreshView: e=>{
                e.fold((()=>{
                    c(E.none(), 0)
                }
                ), (({uid: e})=>{
                    c(E.some(e), 0)
                }
                ))
            }
            ,
            setReadonly: l,
            isReadonly: ()=>un(r),
            setSaving: e=>{
                r = {
                    ...r,
                    saving: e
                },
                g()
            }
            ,
            showError: s,
            refreshReadonly: p
        }
    }
      , hn = e=>{
        let t = e;
        return {
            get: ()=>t,
            set: e=>{
                t = e
            }
        }
    }
      , vn = ()=>(new Date).toISOString()
      , fn = 36e5
      , bn = 864e5
      , yn = 6048e5
      , _n = 24192e5
      , xn = 290304e5;
    var wn;
    !function(e) {
        e[e.LessThanMinute = 0] = "LessThanMinute",
        e[e.Minute = 1] = "Minute",
        e[e.Hour = 2] = "Hour",
        e[e.Day = 3] = "Day",
        e[e.Week = 4] = "Week",
        e[e.Month = 5] = "Month",
        e[e.Year = 6] = "Year"
    }(wn || (wn = {}));
    const On = y(((e,t)=>{
        const n = e() - Date.parse(t);
        return n < 6e4 ? {
            interval: wn.LessThanMinute,
            intervalUnits: n,
            intervalMs: n
        } : n < fn ? {
            interval: wn.Minute,
            intervalUnits: Math.floor(n / 6e4),
            intervalMs: n
        } : n < bn ? {
            interval: wn.Hour,
            intervalUnits: Math.floor(n / fn),
            intervalMs: n
        } : n < yn ? {
            interval: wn.Day,
            intervalUnits: Math.floor(n / bn),
            intervalMs: n
        } : n < _n ? {
            interval: wn.Week,
            intervalUnits: Math.floor(n / yn),
            intervalMs: n
        } : n < xn ? {
            interval: wn.Month,
            intervalUnits: Math.floor(n / _n),
            intervalMs: n
        } : {
            interval: wn.Year,
            intervalUnits: Math.floor(n / xn),
            intervalMs: n
        }
    }
    ), (()=>Date.now()))
      , Sn = (e,t="")=>{
        const n = e.get()
          , o = "" === t ? 0 : Date.parse(t);
        return {
            timestamp: vn(),
            events: o > 0 ? $(n, (e=>Date.parse(e.timestamp) > o)) : n
        }
    }
      , Cn = "comments.globalUiState"
      , En = "comments.resize"
      , kn = {
        init: ()=>Tn({
            readState: v("No State required")
        })
    }
      , Tn = e=>e
      , Mn = e=>{
        if (!i(e))
            throw new Error("cases must be an array");
        if (0 === e.length)
            throw new Error("there must be at least one case");
        const t = []
          , n = {};
        return z(e, ((o,r)=>{
            const s = Be(o);
            if (1 !== s.length)
                throw new Error("one and only one name per case");
            const a = s[0]
              , c = o[a];
            if (void 0 !== n[a])
                throw new Error("duplicate key detected:" + a);
            if ("cata" === a)
                throw new Error("cannot have a case named cata (sorry)");
            if (!i(c))
                throw new Error("case arguments must be an array");
            t.push(a),
            n[a] = (...n)=>{
                const o = n.length;
                if (o !== c.length)
                    throw new Error("Wrong number of arguments to case " + a + ". Expected " + c.length + " (" + c + "), got " + o);
                return {
                    fold: (...t)=>{
                        if (t.length !== e.length)
                            throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + t.length);
                        return t[r].apply(null, n)
                    }
                    ,
                    match: e=>{
                        const o = Be(e);
                        if (t.length !== o.length)
                            throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + "\nActual: " + o.join(","));
                        if (!X(t, (e=>L(o, e))))
                            throw new Error("Not all branches were specified when using match. Specified: " + o.join(", ") + "\nRequired: " + t.join(", "));
                        return e[a].apply(null, n)
                    }
                    ,
                    log: e=>{
                        console.log(e, {
                            constructors: t,
                            constructor: a,
                            params: n
                        })
                    }
                }
            }
        }
        )),
        n
    }
    ;
    Mn([{
        bothErrors: ["error1", "error2"]
    }, {
        firstError: ["error1", "value2"]
    }, {
        secondError: ["value1", "error2"]
    }, {
        bothValues: ["value1", "value2"]
    }]);
    const An = (e,t)=>((e,t)=>({
        [e]: t
    }))(e, t)
      , Rn = e=>(e=>{
        const t = {};
        return z(e, (e=>{
            t[e.key] = e.value
        }
        )),
        t
    }
    )(e)
      , Nn = e=>m(e) ? e : w
      , Bn = (e,t)=>ce(e.element, t.event.target)
      , Fn = {
        can: O,
        abort: w,
        run: p
    }
      , Dn = e=>{
        if (!$e(e, "can") && !$e(e, "abort") && !$e(e, "run"))
            throw new Error("EventHandler defined by: " + JSON.stringify(e, null, 2) + " does not have can, abort, or run!");
        return {
            ...Fn,
            ...e
        }
    }
      , Hn = ()=>In(0, 0)
      , In = (e,t)=>({
        major: e,
        minor: t
    })
      , Pn = {
        nu: In,
        detect: (e,t)=>{
            const n = String(t).toLowerCase();
            return 0 === e.length ? Hn() : ((e,t)=>{
                const n = ((e,t)=>{
                    for (let n = 0; n < e.length; n++) {
                        const o = e[n];
                        if (o.test(t))
                            return o
                    }
                }
                )(e, t);
                if (!n)
                    return {
                        major: 0,
                        minor: 0
                    };
                const o = e=>Number(t.replace(n, "$" + e));
                return In(o(1), o(2))
            }
            )(e, n)
        }
        ,
        unknown: Hn
    }
      , Vn = (e,t)=>{
        const n = String(t).toLowerCase();
        return K(e, (e=>e.search(n)))
    }
      , Wn = (e,t,n=0,o)=>{
        const r = e.indexOf(t, n);
        return -1 !== r && (!!l(o) || r + t.length <= o)
    }
      , Ln = (e,t)=>((e,t,n)=>"" === t || e.length >= t.length && e.substr(n, n + t.length) === t)(e, t, e.length - t.length)
      , Un = (e=>t=>t.replace(e, ""))(/^\s+|\s+$/g)
      , jn = e=>e.length > 0
      , zn = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/
      , $n = e=>t=>Wn(t, e)
      , qn = [{
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: e=>Wn(e, "edge/") && Wn(e, "chrome") && Wn(e, "safari") && Wn(e, "applewebkit")
    }, {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, zn],
        search: e=>Wn(e, "chrome") && !Wn(e, "chromeframe")
    }, {
        name: "IE",
        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
        search: e=>Wn(e, "msie") || Wn(e, "trident")
    }, {
        name: "Opera",
        versionRegexes: [zn, /.*?opera\/([0-9]+)\.([0-9]+).*/],
        search: $n("opera")
    }, {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: $n("firefox")
    }, {
        name: "Safari",
        versionRegexes: [zn, /.*?cpu os ([0-9]+)_([0-9]+).*/],
        search: e=>(Wn(e, "safari") || Wn(e, "mobile/")) && Wn(e, "applewebkit")
    }]
      , Gn = [{
        name: "Windows",
        search: $n("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "iOS",
        search: e=>Wn(e, "iphone") || Wn(e, "ipad"),
        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
    }, {
        name: "Android",
        search: $n("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    }, {
        name: "macOS",
        search: $n("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    }, {
        name: "Linux",
        search: $n("linux"),
        versionRegexes: []
    }, {
        name: "Solaris",
        search: $n("sunos"),
        versionRegexes: []
    }, {
        name: "FreeBSD",
        search: $n("freebsd"),
        versionRegexes: []
    }, {
        name: "ChromeOS",
        search: $n("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }]
      , Kn = {
        browsers: v(qn),
        oses: v(Gn)
    }
      , Yn = "Edge"
      , Qn = "Chromium"
      , Jn = "Opera"
      , Xn = "Firefox"
      , Zn = "Safari"
      , eo = e=>{
        const t = e.current
          , n = e.version
          , o = e=>()=>t === e;
        return {
            current: t,
            version: n,
            isEdge: o(Yn),
            isChromium: o(Qn),
            isIE: o("IE"),
            isOpera: o(Jn),
            isFirefox: o(Xn),
            isSafari: o(Zn)
        }
    }
      , to = ()=>eo({
        current: void 0,
        version: Pn.unknown()
    })
      , no = eo
      , oo = (v(Yn),
    v(Qn),
    v("IE"),
    v(Jn),
    v(Xn),
    v(Zn),
    "Windows")
      , ro = "Android"
      , so = "Linux"
      , ao = "macOS"
      , io = "Solaris"
      , co = "FreeBSD"
      , lo = "ChromeOS"
      , uo = e=>{
        const t = e.current
          , n = e.version
          , o = e=>()=>t === e;
        return {
            current: t,
            version: n,
            isWindows: o(oo),
            isiOS: o("iOS"),
            isAndroid: o(ro),
            isMacOS: o(ao),
            isLinux: o(so),
            isSolaris: o(io),
            isFreeBSD: o(co),
            isChromeOS: o(lo)
        }
    }
      , mo = ()=>uo({
        current: void 0,
        version: Pn.unknown()
    })
      , go = uo
      , po = (v(oo),
    v("iOS"),
    v(ro),
    v(so),
    v(ao),
    v(io),
    v(co),
    v(lo),
    e=>window.matchMedia(e).matches);
    let ho = xt((()=>((e,t,n)=>{
        const o = Kn.browsers()
          , r = Kn.oses()
          , s = t.bind((e=>((e,t)=>se(t.brands, (t=>{
            const n = t.brand.toLowerCase();
            return K(e, (e=>{
                var t;
                return n === (null === (t = e.brand) || void 0 === t ? void 0 : t.toLowerCase())
            }
            )).map((e=>({
                current: e.name,
                version: Pn.nu(parseInt(t.version, 10), 0)
            })))
        }
        )))(o, e))).orThunk((()=>((e,t)=>Vn(e, t).map((e=>{
            const n = Pn.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: n
            }
        }
        )))(o, e))).fold(to, no)
          , a = ((e,t)=>Vn(e, t).map((e=>{
            const n = Pn.detect(e.versionRegexes, t);
            return {
                current: e.name,
                version: n
            }
        }
        )))(r, e).fold(mo, go)
          , i = ((e,t,n,o)=>{
            const r = e.isiOS() && !0 === /ipad/i.test(n)
              , s = e.isiOS() && !r
              , a = e.isiOS() || e.isAndroid()
              , i = a || o("(pointer:coarse)")
              , c = r || !s && a && o("(min-device-width:768px)")
              , l = s || a && !c
              , u = t.isSafari() && e.isiOS() && !1 === /safari/i.test(n)
              , d = !l && !c && !u;
            return {
                isiPad: v(r),
                isiPhone: v(s),
                isTablet: v(c),
                isPhone: v(l),
                isTouch: v(i),
                isAndroid: e.isAndroid,
                isiOS: e.isiOS,
                isWebView: v(u),
                isDesktop: v(d)
            }
        }
        )(a, s, e, n);
        return {
            browser: s,
            os: a,
            deviceType: i
        }
    }
    )(window.navigator.userAgent, E.from(window.navigator.userAgentData), po)));
    const vo = ()=>ho()
      , fo = v
      , bo = fo("touchstart")
      , yo = fo("touchmove")
      , _o = fo("touchend")
      , xo = fo("mousedown")
      , wo = fo("mouseover")
      , Oo = fo("keydown")
      , So = fo("keyup")
      , Co = fo("input")
      , Eo = fo("click")
      , ko = fo("transitioncancel")
      , To = fo("transitionend")
      , Mo = fo("transitionstart")
      , Ao = e=>v("alloy." + e)
      , Ro = {
        tap: Ao("tap")
    }
      , No = Ao("focus")
      , Bo = Ao("blur.post")
      , Fo = Ao("paste.post")
      , Do = Ao("receive")
      , Ho = Ao("execute")
      , Io = Ao("focus.item")
      , Po = Ro.tap
      , Vo = Ao("longpress")
      , Wo = Ao("sandbox.close")
      , Lo = Ao("system.init")
      , Uo = Ao("system.attached")
      , jo = Ao("system.detached")
      , zo = Ao("system.dismissRequested")
      , $o = Ao("system.repositionRequested")
      , qo = Ao("focusmanager.shifted")
      , Go = Ao("highlight")
      , Ko = Ao("dehighlight")
      , Yo = (e,t)=>{
        Zo(e, e.element, t, {})
    }
      , Qo = (e,t,n)=>{
        Zo(e, e.element, t, n)
    }
      , Jo = e=>{
        Yo(e, Ho())
    }
      , Xo = (e,t,n)=>{
        Zo(e, t, n, {})
    }
      , Zo = (e,t,n,o)=>{
        const r = {
            target: t,
            ...o
        };
        e.getSystem().triggerEvent(n, t, r)
    }
      , er = e=>Rn(e)
      , tr = (e,t)=>({
        key: e,
        value: Dn({
            abort: t
        })
    })
      , nr = (e,t)=>({
        key: e,
        value: Dn({
            run: t
        })
    })
      , or = e=>t=>({
        key: e,
        value: Dn({
            run: (e,n)=>{
                Bn(e, n) && t(e, n)
            }
        })
    })
      , rr = e=>nr(e, ((e,t)=>{
        t.cut()
    }
    ))
      , sr = e=>nr(e, ((e,t)=>{
        t.stop()
    }
    ))
      , ar = (e,t)=>or(e)(t)
      , ir = or(Uo())
      , cr = or(jo())
      , lr = or(Lo())
      , ur = (e=>t=>nr(e, t))(Ho())
      , dr = (e,t,n=b)=>e.exists((e=>n(e, t)))
      , mr = e=>{
        const t = []
          , n = e=>{
            t.push(e)
        }
        ;
        for (let t = 0; t < e.length; t++)
            e[t].each(n);
        return t
    }
      , gr = (e,t,n)=>e.isSome() && t.isSome() ? E.some(n(e.getOrDie(), t.getOrDie())) : E.none()
      , pr = e=>j(e, (e=>Ln(e, "/*") ? e.substring(0, e.length - 2) : e))
      , hr = (e,t)=>{
        const n = e.toString()
          , o = n.indexOf(")") + 1
          , r = n.indexOf("(")
          , s = n.substring(r + 1, o - 1).split(/,\s*/);
        return e.toFunctionAnnotation = ()=>({
            name: t,
            parameters: pr(s)
        }),
        e
    }
      , vr = e=>({
        classes: l(e.classes) ? [] : e.classes,
        attributes: l(e.attributes) ? {} : e.attributes,
        styles: l(e.styles) ? {} : e.styles
    })
      , fr = (e,t,n)=>lr(((o,r)=>{
        n(o, e, t)
    }
    ))
      , br = e=>({
        key: e,
        value: void 0
    })
      , yr = (e,t,n,o,r,s,a)=>{
        const i = e=>$e(e, n) ? e[n]() : E.none()
          , c = He(r, ((e,t)=>((e,t,n)=>((e,t,n)=>{
            const o = n.toString()
              , r = o.indexOf(")") + 1
              , s = o.indexOf("(")
              , a = o.substring(s + 1, r - 1).split(/,\s*/);
            return e.toFunctionAnnotation = ()=>({
                name: t,
                parameters: pr(a.slice(0, 1).concat(a.slice(3)))
            }),
            e
        }
        )(((o,...r)=>{
            const s = [o].concat(r);
            return o.config({
                name: v(e)
            }).fold((()=>{
                throw new Error("We could not find any behaviour configuration for: " + e + ". Using API: " + n)
            }
            ), (e=>{
                const n = Array.prototype.slice.call(s, 1);
                return t.apply(void 0, [o, e.config, e.state].concat(n))
            }
            ))
        }
        ), n, t))(n, e, t)))
          , l = {
            ...He(s, ((e,t)=>hr(e, t))),
            ...c,
            revoke: y(br, n),
            config: t=>{
                const o = Gt(n + "-config", e, t);
                return {
                    key: n,
                    value: {
                        config: o,
                        me: l,
                        configAsRaw: xt((()=>Gt(n + "-config", e, t))),
                        initialConfig: t,
                        state: a
                    }
                }
            }
            ,
            schema: v(t),
            exhibit: (e,t)=>gr(i(e), je(o, "exhibit"), ((e,n)=>n(t, e.config, e.state))).getOrThunk((()=>vr({}))),
            name: v(n),
            handlers: e=>i(e).map((e=>je(o, "events").getOr((()=>({})))(e.config, e.state))).getOr({})
        };
        return l
    }
      , _r = e=>Rn(e)
      , xr = Bt([Xt("fields"), Xt("name"), an("active", {}), an("apis", {}), an("state", kn), an("extra", {})])
      , wr = e=>{
        const t = Gt("Creating behaviour: " + e.name, xr, e);
        return ((e,t,n,o,r,s)=>{
            const a = Bt(e)
              , i = rn(t, [sn("config", e)]);
            return yr(a, i, t, n, o, r, s)
        }
        )(t.fields, t.name, t.active, t.apis, t.extra, t.state)
    }
      , Or = Bt([Xt("branchKey"), Xt("branches"), Xt("name"), an("active", {}), an("apis", {}), an("state", kn), an("extra", {})])
      , Sr = v(void 0)
      , Cr = (e,t)=>{
        const n = ((e,t)=>{
            const n = er(t);
            return wr({
                fields: [Xt("enabled")],
                name: e,
                active: {
                    events: v(n)
                }
            })
        }
        )(e, t);
        return {
            key: e,
            value: {
                config: {},
                me: n,
                configAsRaw: v({}),
                initialConfig: {},
                state: kn
            }
        }
    }
      , Er = ()=>R(document)
      , kr = (e,t=!1)=>e.dom.focus({
        preventScroll: t
    })
      , Tr = (e=Er())=>E.from(e.dom.activeElement).map(R)
      , Mr = e=>Tr(Se(e)).filter((t=>e.dom.contains(t.dom)))
      , Ar = (e,t)=>{
        z(t, (t=>{
            Ne(e, t)
        }
        ))
    }
      , Rr = e=>{
        e.dom.textContent = "",
        z(_e(e), (e=>{
            Nr(e)
        }
        ))
    }
      , Nr = e=>{
        const t = e.dom;
        null !== t.parentNode && t.parentNode.removeChild(t)
    }
      , Br = e=>e.dom.innerHTML
      , Fr = (e,t)=>{
        const n = ve(e).dom
          , o = R(n.createDocumentFragment())
          , r = ((e,t)=>{
            const n = (t || document).createElement("div");
            return n.innerHTML = e,
            _e(R(n))
        }
        )(t, n);
        Ar(o, r),
        Rr(e),
        Ne(e, o)
    }
      , Dr = (e,t,n)=>{
        if (!(r(n) || c(n) || g(n)))
            throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", n, ":: Element ", e),
            new Error("Attribute value was not simple");
        e.setAttribute(t, n + "")
    }
      , Hr = (e,t,n)=>{
        Dr(e.dom, t, n)
    }
      , Ir = (e,t)=>{
        const n = e.dom;
        De(t, ((e,t)=>{
            Dr(n, t, e)
        }
        ))
    }
      , Pr = (e,t)=>{
        const n = e.dom.getAttribute(t);
        return null === n ? void 0 : n
    }
      , Vr = (e,t)=>E.from(Pr(e, t))
      , Wr = (e,t)=>{
        const n = e.dom;
        return !(!n || !n.hasAttribute) && n.hasAttribute(t)
    }
      , Lr = (e,t)=>{
        e.dom.removeAttribute(t)
    }
      , Ur = e=>Oe(e) ? "#shadow-root" : (e=>{
        const t = M("div")
          , n = R(e.dom.cloneNode(!0));
        return Ne(t, n),
        Br(t)
    }
    )((e=>((e,t)=>R(e.dom.cloneNode(!1)))(e))(e))
      , jr = e=>Ur(e);
    var zr;
    !function(e) {
        e[e.STOP = 0] = "STOP",
        e[e.NORMAL = 1] = "NORMAL",
        e[e.LOGGING = 2] = "LOGGING"
    }(zr || (zr = {}));
    const $r = hn({})
      , qr = ["alloy/data/Fields", "alloy/debugging/Debugging"]
      , Gr = (e,t,n)=>((e,t,n)=>{
        switch (je($r.get(), e).orThunk((()=>{
            const t = Be($r.get());
            return se(t, (t=>e.indexOf(t) > -1 ? E.some($r.get()[t]) : E.none()))
        }
        )).getOr(zr.NORMAL)) {
        case zr.NORMAL:
            return n(Kr());
        case zr.LOGGING:
            {
                const o = ((e,t)=>{
                    const n = []
                      , o = (new Date).getTime();
                    return {
                        logEventCut: (e,t,o)=>{
                            n.push({
                                outcome: "cut",
                                target: t,
                                purpose: o
                            })
                        }
                        ,
                        logEventStopped: (e,t,o)=>{
                            n.push({
                                outcome: "stopped",
                                target: t,
                                purpose: o
                            })
                        }
                        ,
                        logNoParent: (e,t,o)=>{
                            n.push({
                                outcome: "no-parent",
                                target: t,
                                purpose: o
                            })
                        }
                        ,
                        logEventNoHandlers: (e,t)=>{
                            n.push({
                                outcome: "no-handlers-left",
                                target: t
                            })
                        }
                        ,
                        logEventResponse: (e,t,o)=>{
                            n.push({
                                outcome: "response",
                                purpose: o,
                                target: t
                            })
                        }
                        ,
                        write: ()=>{
                            const r = (new Date).getTime();
                            L(["mousemove", "mouseover", "mouseout", Lo()], e) || console.log(e, {
                                event: e,
                                time: r - o,
                                target: t.dom,
                                sequence: j(n, (e=>L(["cut", "stopped", "response"], e.outcome) ? "{" + e.purpose + "} " + e.outcome + " at (" + jr(e.target) + ")" : e.outcome))
                            })
                        }
                    }
                }
                )(e, t)
                  , r = n(o);
                return o.write(),
                r
            }
        case zr.STOP:
            return !0
        }
    }
    )(e, t, n)
      , Kr = v({
        logEventCut: p,
        logEventStopped: p,
        logNoParent: p,
        logEventNoHandlers: p,
        logEventResponse: p,
        write: p
    })
      , Yr = e=>e.cHandler
      , Qr = e=>{
        const t = hn(E.none())
          , n = ()=>t.get().each(e);
        return {
            clear: ()=>{
                n(),
                t.set(E.none())
            }
            ,
            isSet: ()=>t.get().isSome(),
            get: ()=>t.get(),
            set: e=>{
                n(),
                t.set(E.some(e))
            }
        }
    }
      , Jr = ()=>Qr((e=>e.unbind()))
      , Xr = ()=>{
        const e = Qr(p);
        return {
            ...e,
            on: t=>e.get().each(t)
        }
    }
    ;
    var Zr = (e,t,n,o,r)=>e(n, o) ? E.some(n) : m(r) && r(n) ? E.none() : t(n, o, r);
    const es = (e,t,n)=>{
        let o = e.dom;
        const r = m(n) ? n : w;
        for (; o.parentNode; ) {
            o = o.parentNode;
            const e = R(o);
            if (t(e))
                return E.some(e);
            if (r(e))
                break
        }
        return E.none()
    }
      , ts = (e,t,n)=>Zr(((e,t)=>t(e)), es, e, t, n)
      , ns = (e,t,n)=>es(e, (e=>ae(e, t)), n)
      , os = (e,t)=>((e,t)=>{
        const n = void 0 === t ? document : t.dom;
        return ie(n) ? E.none() : E.from(n.querySelector(e)).map(R)
    }
    )(t, e)
      , rs = (e,t,n)=>Zr(((e,t)=>ae(e, t)), ns, e, t, n)
      , ss = [8]
      , as = [9]
      , is = [13]
      , cs = [27]
      , ls = [32]
      , us = [37]
      , ds = [38]
      , ms = [39]
      , gs = [40]
      , ps = e=>{
        const t = e.raw;
        return void 0 === t.touches || 1 !== t.touches.length ? E.none() : E.some(t.touches[0])
    }
      , hs = e=>{
        const t = Xr()
          , n = hn(!1)
          , o = ((e,t)=>{
            let n = null;
            return {
                cancel: ()=>{
                    null !== n && (clearTimeout(n),
                    n = null)
                }
                ,
                schedule: (...t)=>{
                    n = setTimeout((()=>{
                        e.apply(null, t),
                        n = null
                    }
                    ), 400)
                }
            }
        }
        )((t=>{
            e.triggerEvent(Vo(), t),
            n.set(!0)
        }
        ))
          , r = Rn([{
            key: bo(),
            value: e=>(ps(e).each((r=>{
                o.cancel();
                const s = {
                    x: r.clientX,
                    y: r.clientY,
                    target: e.target
                };
                o.schedule(e),
                n.set(!1),
                t.set(s)
            }
            )),
            E.none())
        }, {
            key: yo(),
            value: e=>(o.cancel(),
            ps(e).each((e=>{
                t.on((n=>{
                    ((e,t)=>{
                        const n = Math.abs(e.clientX - t.x)
                          , o = Math.abs(e.clientY - t.y);
                        return n > 5 || o > 5
                    }
                    )(e, n) && t.clear()
                }
                ))
            }
            )),
            E.none())
        }, {
            key: _o(),
            value: r=>(o.cancel(),
            t.get().filter((e=>ce(e.target, r.target))).map((t=>n.get() ? (r.prevent(),
            !1) : e.triggerEvent(Po(), r))))
        }]);
        return {
            fireIfReady: (e,t)=>je(r, t).bind((t=>t(e)))
        }
    }
      , vs = (e,t)=>{
        const n = je(e, "target").getOr(t);
        return hn(n)
    }
      , fs = Mn([{
        stopped: []
    }, {
        resume: ["element"]
    }, {
        complete: []
    }])
      , bs = (e,t,n,o,r,s)=>{
        const a = e(t, o)
          , i = ((e,t)=>{
            const n = hn(!1)
              , o = hn(!1);
            return {
                stop: ()=>{
                    n.set(!0)
                }
                ,
                cut: ()=>{
                    o.set(!0)
                }
                ,
                isStopped: n.get,
                isCut: o.get,
                event: e,
                setSource: t.set,
                getSource: t.get
            }
        }
        )(n, r);
        return a.fold((()=>(s.logEventNoHandlers(t, o),
        fs.complete())), (e=>{
            const n = e.descHandler;
            return Yr(n)(i),
            i.isStopped() ? (s.logEventStopped(t, e.element, n.purpose),
            fs.stopped()) : i.isCut() ? (s.logEventCut(t, e.element, n.purpose),
            fs.complete()) : be(e.element).fold((()=>(s.logNoParent(t, e.element, n.purpose),
            fs.complete())), (o=>(s.logEventResponse(t, e.element, n.purpose),
            fs.resume(o))))
        }
        ))
    }
      , ys = (e,t,n,o,r,s)=>bs(e, t, n, o, r, s).fold(O, (o=>ys(e, t, n, o, r, s)), w)
      , _s = (e,t,n,o,r)=>{
        const s = vs(n, o);
        return ys(e, t, n, o, s, r)
    }
      , xs = (e,t,n,o)=>{
        const r = e + t;
        return r > o ? n : r < n ? o : r
    }
      , ws = (e,t,n)=>Math.min(Math.max(e, t), n)
      , Os = ()=>window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;
    let Ss = 0;
    const Cs = e=>{
        const t = (new Date).getTime()
          , n = Math.floor(1e9 * Os());
        return Ss++,
        e + "_" + n + Ss + String(t)
    }
      , Es = v("alloy-id-")
      , ks = v("data-alloy-id")
      , Ts = Es()
      , Ms = ks()
      , As = (e,t)=>{
        Object.defineProperty(e.dom, Ms, {
            value: t,
            writable: !0
        })
    }
      , Rs = e=>{
        const t = de(e) ? e.dom[Ms] : null;
        return E.from(t)
    }
      , Ns = e=>Cs(e)
      , Bs = ()=>{
        const e = {};
        return {
            registerId: (t,n,o)=>{
                De(o, ((o,r)=>{
                    const s = void 0 !== e[r] ? e[r] : {};
                    s[n] = ((e,t)=>({
                        cHandler: y.apply(void 0, [e.handler].concat(t)),
                        purpose: e.purpose
                    }))(o, t),
                    e[r] = s
                }
                ))
            }
            ,
            unregisterId: t=>{
                De(e, ((e,n)=>{
                    ze(e, t) && delete e[t]
                }
                ))
            }
            ,
            filterByType: t=>je(e, t).map((e=>Le(e, ((e,t)=>((e,t)=>({
                id: e,
                descHandler: t
            }))(t, e))))).getOr([]),
            find: (t,n,o)=>je(e, n).bind((e=>((e,t,n)=>{
                const o = t(e)
                  , r = Nn(n);
                return o.orThunk((()=>r(e) ? E.none() : ((e,t,n)=>{
                    let o = e.dom;
                    const r = Nn(n);
                    for (; o.parentNode; ) {
                        o = o.parentNode;
                        const e = R(o)
                          , n = t(e);
                        if (n.isSome())
                            return n;
                        if (r(e))
                            break
                    }
                    return E.none()
                }
                )(e, t, r)))
            }
            )(o, (t=>((e,t)=>Rs(t).bind((t=>je(e, t))).map((e=>((e,t)=>({
                element: e,
                descHandler: t
            }))(t, e))))(e, t)), t)))
        }
    }
      , Fs = ()=>{
        const e = Bs()
          , t = {}
          , n = n=>{
            Rs(n.element).each((n=>{
                delete t[n],
                e.unregisterId(n)
            }
            ))
        }
        ;
        return {
            find: (t,n,o)=>e.find(t, n, o),
            filter: t=>e.filterByType(t),
            register: o=>{
                const r = (e=>{
                    const t = e.element;
                    return Rs(t).getOrThunk((()=>((e,t)=>{
                        const n = Cs(Ts + "uid-");
                        return As(t, n),
                        n
                    }
                    )(0, e.element)))
                }
                )(o);
                $e(t, r) && ((e,o)=>{
                    const r = t[o];
                    if (r !== e)
                        throw new Error('The tagId "' + o + '" is already used by: ' + jr(r.element) + "\nCannot use it for: " + jr(e.element) + "\nThe conflicting element is" + (it(r.element) ? " " : " not ") + "already in the DOM");
                    n(e)
                }
                )(o, r);
                const s = [o];
                e.registerId(s, r, o.events),
                t[r] = o
            }
            ,
            unregister: n,
            getById: e=>je(t, e)
        }
    }
      , Ds = er([((e,t)=>({
        key: e,
        value: Dn({
            can: (e,t)=>{
                const n = t.event
                  , o = n.originator
                  , r = n.target;
                return !((e,t,n)=>ce(t, e.element) && !ce(t, n))(e, o, r) || (console.warn(No() + " did not get interpreted by the desired target. \nOriginator: " + jr(o) + "\nTarget: " + jr(r) + "\nCheck the " + No() + " event handlers"),
                !1)
            }
        })
    }))(No())]);
    var Hs = Object.freeze({
        __proto__: null,
        events: Ds
    });
    const Is = f
      , Ps = e=>{
        const t = t=>`The component must be in a context to execute: ${t}` + (e ? "\n" + jr(e().element) + " is not in context." : "")
          , n = e=>()=>{
            throw new Error(t(e))
        }
          , o = e=>()=>{
            console.warn(t(e))
        }
        ;
        return {
            debugInfo: v("fake"),
            triggerEvent: o("triggerEvent"),
            triggerFocus: o("triggerFocus"),
            triggerEscape: o("triggerEscape"),
            broadcast: o("broadcast"),
            broadcastOn: o("broadcastOn"),
            broadcastEvent: o("broadcastEvent"),
            build: n("build"),
            buildOrPatch: n("buildOrPatch"),
            addToWorld: n("addToWorld"),
            removeFromWorld: n("removeFromWorld"),
            addToGui: n("addToGui"),
            removeFromGui: n("removeFromGui"),
            getByUid: n("getByUid"),
            getByDom: n("getByDom"),
            isConnected: w
        }
    }
      , Vs = Ps()
      , Ws = Cs("alloy-premade")
      , Ls = e=>(Object.defineProperty(e.element.dom, Ws, {
        value: e.uid,
        writable: !0
    }),
    An(Ws, e))
      , Us = e=>je(e, Ws)
      , js = e=>((e,t)=>{
        const n = t.toString()
          , o = n.indexOf(")") + 1
          , r = n.indexOf("(")
          , s = n.substring(r + 1, o - 1).split(/,\s*/);
        return e.toFunctionAnnotation = ()=>({
            name: "OVERRIDE",
            parameters: pr(s.slice(1))
        }),
        e
    }
    )(((t,...n)=>e(t.getApis(), t, ...n)), e)
      , zs = (e,t)=>{
        const n = {};
        return De(e, ((e,o)=>{
            De(e, ((e,r)=>{
                const s = je(n, r).getOr([]);
                n[r] = s.concat([t(o, e)])
            }
            ))
        }
        )),
        n
    }
      , $s = (e,t,n,o)=>{
        try {
            const r = ((n,r)=>{
                const s = P.call(n, 0);
                return s.sort(((n,r)=>{
                    const s = n[t]
                      , a = r[t]
                      , i = o.indexOf(s)
                      , c = o.indexOf(a);
                    if (-1 === i)
                        throw new Error("The ordering for " + e + " does not have an entry for " + s + ".\nOrder specified: " + JSON.stringify(o, null, 2));
                    if (-1 === c)
                        throw new Error("The ordering for " + e + " does not have an entry for " + a + ".\nOrder specified: " + JSON.stringify(o, null, 2));
                    return i < c ? -1 : c < i ? 1 : 0
                }
                )),
                s
            }
            )(n);
            return nt.value(r)
        } catch (e) {
            return nt.error([e])
        }
    }
      , qs = (e,t)=>({
        name: e,
        handler: t
    })
      , Gs = (e,t)=>{
        const n = {};
        return z(e, (e=>{
            n[e.name()] = e.handlers(t)
        }
        )),
        n
    }
      , Ks = (e,t,n)=>{
        const o = t[n];
        return o ? $s("Event: " + n, "name", e, o).map((e=>(e=>{
            const t = ((e,t)=>(...t)=>G(e, ((e,n)=>e && (e=>e.can)(n).apply(void 0, t)), !0))(e)
              , n = ((e,t)=>(...t)=>G(e, ((e,n)=>e || (e=>e.abort)(n).apply(void 0, t)), !1))(e);
            return {
                can: t,
                abort: n,
                run: (...t)=>{
                    z(e, (e=>{
                        e.run.apply(void 0, t)
                    }
                    ))
                }
            }
        }
        )(j(e, (e=>e.handler))))) : ((e,t)=>nt.error(["The event (" + e + ') has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that can trigger it are: ' + JSON.stringify(j(t, (e=>e.name)), null, 2)]))(n, e)
    }
      , Ys = (e,t)=>{
        const n = Le(e, ((e,n)=>(1 === e.length ? nt.value(e[0].handler) : Ks(e, t, n)).map((o=>{
            const r = (e=>{
                const t = (e=>m(e) ? {
                    can: O,
                    abort: w,
                    run: e
                } : e)(e);
                return (e,n,...o)=>{
                    const r = [e, n].concat(o);
                    t.abort.apply(void 0, r) ? n.stop() : t.can.apply(void 0, r) && t.run.apply(void 0, r)
                }
            }
            )(o)
              , s = e.length > 1 ? $(t[n], (t=>U(e, (e=>e.name === t)))).join(" > ") : e[0].name;
            return An(n, ((e,t)=>({
                handler: e,
                purpose: t
            }))(r, s))
        }
        ))));
        return ((e,t)=>{
            const n = (e=>{
                const t = []
                  , n = [];
                return z(e, (e=>{
                    e.fold((e=>{
                        t.push(e)
                    }
                    ), (e=>{
                        n.push(e)
                    }
                    ))
                }
                )),
                {
                    errors: t,
                    values: n
                }
            }
            )(e);
            return n.errors.length > 0 ? (o = n.errors,
            nt.error(Q(o))) : ((e,t)=>0 === e.length ? nt.value(t) : nt.value(yt(t, _t.apply(void 0, e))))(n.values, t);
            var o
        }
        )(n, {})
    }
      , Qs = "alloy.base.behaviour"
      , Js = Ft([Qt("dom", "dom", {
        tag: "required",
        process: {}
    }, Ft([Xt("tag"), an("styles", {}), an("classes", []), an("attributes", {}), nn("value"), nn("innerHtml")])), Xt("components"), Xt("uid"), an("events", {}), an("apis", {}), Qt("eventOrder", "eventOrder", (Va = {
        [Ho()]: ["disabling", Qs, "toggling", "typeaheadevents"],
        [No()]: [Qs, "focusing", "keying"],
        [Lo()]: [Qs, "disabling", "toggling", "representing", "tooltipping"],
        [Co()]: [Qs, "representing", "streaming", "invalidating"],
        [jo()]: [Qs, "representing", "item-events", "toolbar-button-events", "tooltipping"],
        [xo()]: ["focusing", Qs, "item-type-events"],
        [bo()]: ["focusing", Qs, "item-type-events"],
        [wo()]: ["item-type-events", "tooltipping"],
        [Do()]: ["receiving", "reflecting", "tooltipping"]
    },
    St(v(Va))), It()), nn("domModification")])
      , Xs = e=>e.events
      , Zs = (e,t)=>{
        const n = Pr(e, t);
        return void 0 === n || "" === n ? [] : n.split(" ")
    }
      , ea = e=>void 0 !== e.dom.classList
      , ta = e=>Zs(e, "class")
      , na = (e,t)=>{
        ea(e) ? e.dom.classList.add(t) : ((e,t)=>{
            ((e,t,n)=>{
                const o = Zs(e, t).concat([n]);
                Hr(e, t, o.join(" "))
            }
            )(e, "class", t)
        }
        )(e, t)
    }
      , oa = (e,t)=>{
        ea(e) ? e.dom.classList.remove(t) : ((e,t)=>{
            ((e,t,n)=>{
                const o = $(Zs(e, t), (e=>e !== n));
                o.length > 0 ? Hr(e, t, o.join(" ")) : Lr(e, t)
            }
            )(e, "class", t)
        }
        )(e, t),
        (e=>{
            0 === (ea(e) ? e.dom.classList : ta(e)).length && Lr(e, "class")
        }
        )(e)
    }
      , ra = (e,t)=>ea(e) && e.dom.classList.contains(t)
      , sa = (e,t)=>{
        z(t, (t=>{
            na(e, t)
        }
        ))
    }
      , aa = (e,t)=>{
        z(t, (t=>{
            oa(e, t)
        }
        ))
    }
      , ia = e=>void 0 !== e.style && m(e.style.getPropertyValue)
      , ca = (e,t,n)=>{
        if (!r(n))
            throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", n, ":: Element ", e),
            new Error("CSS value must be a string: " + n);
        ia(e) && e.style.setProperty(t, n)
    }
      , la = (e,t)=>{
        ia(e) && e.style.removeProperty(t)
    }
      , ua = (e,t,n)=>{
        const o = e.dom;
        ca(o, t, n)
    }
      , da = (e,t)=>{
        const n = e.dom;
        De(t, ((e,t)=>{
            ca(n, t, e)
        }
        ))
    }
      , ma = (e,t)=>{
        const n = e.dom;
        De(t, ((e,t)=>{
            e.fold((()=>{
                la(n, t)
            }
            ), (e=>{
                ca(n, t, e)
            }
            ))
        }
        ))
    }
      , ga = (e,t)=>{
        const n = e.dom
          , o = window.getComputedStyle(n).getPropertyValue(t);
        return "" !== o || it(e) ? o : pa(n, t)
    }
      , pa = (e,t)=>ia(e) ? e.style.getPropertyValue(t) : ""
      , ha = (e,t)=>{
        const n = e.dom
          , o = pa(n, t);
        return E.from(o).filter((e=>e.length > 0))
    }
      , va = (e,t)=>{
        const n = e.dom;
        la(n, t),
        dr(Vr(e, "style").map(Un), "") && Lr(e, "style")
    }
      , fa = e=>e.dom.offsetWidth
      , ba = e=>e.dom.value
      , ya = (e,t)=>{
        if (void 0 === t)
            throw new Error("Value.set was undefined");
        e.dom.value = t
    }
      , _a = (e,t,n)=>{
        n.fold((()=>Ne(e, t)), (e=>{
            ce(e, t) || (Ae(e, t),
            Nr(e))
        }
        ))
    }
      , xa = (e,t,n)=>{
        const o = j(t, n)
          , r = _e(e);
        return z(r.slice(o.length), Nr),
        o
    }
      , wa = (e,t,n,o)=>{
        const r = xe(e, t)
          , s = o(n, r)
          , a = ((e,t,n)=>xe(e, t).map((e=>{
            if (n.exists((t=>!ce(t, e)))) {
                const t = n.map(le).getOr("span")
                  , o = M(t);
                return Ae(e, o),
                o
            }
            return e
        }
        )))(e, t, r);
        return _a(e, s.element, a),
        s
    }
      , Oa = (e,t)=>{
        const n = Be(e)
          , o = Be(t)
          , r = ee(o, n)
          , s = ((e,n)=>{
            const o = {}
              , r = {};
            return Ve(e, ((e,n)=>!ze(t, n) || e !== t[n]), Pe(o), Pe(r)),
            {
                t: o,
                f: r
            }
        }
        )(e).t;
        return {
            toRemove: r,
            toSet: s
        }
    }
      , Sa = (e,t)=>{
        const {class: n, style: o, ...r} = (e=>G(e.dom.attributes, ((e,t)=>(e[t.name] = t.value,
        e)), {}))(t)
          , {toSet: s, toRemove: a} = Oa(e.attributes, r)
          , i = (e=>{
            const t = {}
              , n = e.dom;
            if (ia(n))
                for (let e = 0; e < n.style.length; e++) {
                    const o = n.style.item(e);
                    t[o] = n.style[o]
                }
            return t
        }
        )(t)
          , {toSet: c, toRemove: l} = Oa(e.styles, i)
          , u = (e=>ea(e) ? (e=>{
            const t = e.dom.classList
              , n = new Array(t.length);
            for (let e = 0; e < t.length; e++) {
                const o = t.item(e);
                null !== o && (n[e] = o)
            }
            return n
        }
        )(e) : ta(e))(t)
          , d = ee(u, e.classes)
          , m = ee(e.classes, u);
        return z(a, (e=>Lr(t, e))),
        Ir(t, s),
        sa(t, m),
        aa(t, d),
        z(l, (e=>va(t, e))),
        da(t, c),
        e.innerHtml.fold((()=>{
            const n = e.domChildren;
            ((e,t)=>{
                xa(e, t, ((t,n)=>{
                    const o = xe(e, n);
                    return _a(e, t, o),
                    t
                }
                ))
            }
            )(t, n)
        }
        ), (e=>{
            Fr(t, e)
        }
        )),
        (()=>{
            const n = t
              , o = e.value.getOrUndefined();
            o !== ba(n) && ya(n, null != o ? o : "")
        }
        )(),
        t
    }
      , Ca = e=>{
        const t = (e=>{
            const t = je(e, "behaviours").getOr({});
            return J(Be(t), (e=>{
                const n = t[e];
                return d(n) ? [n.me] : []
            }
            ))
        }
        )(e);
        return ((e,t)=>((e,t)=>{
            const n = j(t, (e=>rn(e.name(), [Xt("config"), an("state", kn)])))
              , o = $t("component.behaviours", Ft(n), e.behaviours).fold((t=>{
                throw new Error(Kt(t) + "\nComplete spec:\n" + JSON.stringify(e, null, 2))
            }
            ), f);
            return {
                list: t,
                data: He(o, (e=>{
                    const t = e.map((e=>({
                        config: e.config,
                        state: e.state.init(e.config)
                    })));
                    return v(t)
                }
                ))
            }
        }
        )(e, t))(e, t)
    }
      , Ea = (e,t)=>{
        const n = ()=>g
          , o = hn(Vs)
          , r = qt((e=>$t("custom.definition", Js, e))(e))
          , s = Ca(e)
          , a = (e=>e.list)(s)
          , i = (e=>e.data)(s)
          , c = ((e,t,n)=>{
            const o = {
                ...(r = e).dom,
                uid: r.uid,
                domChildren: j(r.components, (e=>e.element))
            };
            var r;
            const s = (e=>e.domModification.fold((()=>vr({})), vr))(e)
              , a = {
                "alloy.base.modification": s
            }
              , i = t.length > 0 ? ((e,t,n,o)=>{
                const r = {
                    ...t
                };
                z(n, (t=>{
                    r[t.name()] = t.exhibit(e, o)
                }
                ));
                const s = zs(r, ((e,t)=>({
                    name: e,
                    modification: t
                })))
                  , a = e=>q(e, ((e,t)=>({
                    ...t.modification,
                    ...e
                })), {})
                  , i = q(s.classes, ((e,t)=>t.modification.concat(e)), [])
                  , c = a(s.attributes)
                  , l = a(s.styles);
                return vr({
                    classes: i,
                    attributes: c,
                    styles: l
                })
            }
            )(n, a, t, o) : s;
            return c = o,
            l = i,
            {
                ...c,
                attributes: {
                    ...c.attributes,
                    ...l.attributes
                },
                styles: {
                    ...c.styles,
                    ...l.styles
                },
                classes: c.classes.concat(l.classes)
            };
            var c, l
        }
        )(r, a, i)
          , l = ((e,t)=>{
            const n = t.filter((t=>le(t) === e.tag && !(e=>e.innerHtml.isSome() && e.domChildren.length > 0)(e) && !(e=>ze(e.dom, Ws))(t))).bind((t=>((e,t)=>{
                try {
                    const n = Sa(e, t);
                    return E.some(n)
                } catch (e) {
                    return E.none()
                }
            }
            )(e, t))).getOrThunk((()=>(e=>{
                const t = M(e.tag);
                Ir(t, e.attributes),
                sa(t, e.classes),
                da(t, e.styles),
                e.innerHtml.each((e=>Fr(t, e)));
                const n = e.domChildren;
                return Ar(t, n),
                e.value.each((e=>{
                    ya(t, e)
                }
                )),
                t
            }
            )(e)));
            return As(n, e.uid),
            n
        }
        )(c, t)
          , u = ((e,t,n)=>{
            const o = {
                "alloy.base.behaviour": Xs(e)
            };
            return ((e,t,n,o)=>{
                const r = ((e,t,n)=>{
                    const o = {
                        ...n,
                        ...Gs(t, e)
                    };
                    return zs(o, qs)
                }
                )(e, n, o);
                return Ys(r, t)
            }
            )(n, e.eventOrder, t, o).getOrDie()
        }
        )(r, a, i)
          , d = hn(r.components)
          , g = {
            uid: e.uid,
            getSystem: o.get,
            config: t=>{
                const n = i;
                return (m(n[t.name()]) ? n[t.name()] : ()=>{
                    throw new Error("Could not find " + t.name() + " in " + JSON.stringify(e, null, 2))
                }
                )()
            }
            ,
            hasConfigured: e=>m(i[e.name()]),
            spec: e,
            readState: e=>i[e]().map((e=>e.state.readState())).getOr("not enabled"),
            getApis: ()=>r.apis,
            connect: e=>{
                o.set(e)
            }
            ,
            disconnect: ()=>{
                o.set(Ps(n))
            }
            ,
            element: l,
            syncComponents: ()=>{
                const e = _e(l)
                  , t = J(e, (e=>o.get().getByDom(e).fold((()=>[]), ne)));
                d.set(t)
            }
            ,
            components: d.get,
            events: u
        };
        return g
    }
      , ka = e=>{
        const t = A(e);
        return Ta({
            element: t
        })
    }
      , Ta = e=>{
        const t = Gt("external.component", Bt([Xt("element"), nn("uid")]), e)
          , n = hn(Ps())
          , o = t.uid.getOrThunk((()=>Ns("external")));
        As(t.element, o);
        const r = {
            uid: o,
            getSystem: n.get,
            config: E.none,
            hasConfigured: w,
            connect: e=>{
                n.set(e)
            }
            ,
            disconnect: ()=>{
                n.set(Ps((()=>r)))
            }
            ,
            getApis: ()=>({}),
            element: t.element,
            spec: e,
            readState: v("No state"),
            syncComponents: p,
            components: v([]),
            events: {}
        };
        return Ls(r)
    }
      , Ma = Ns
      , Aa = (e,t)=>Us(e).getOrThunk((()=>((e,t)=>{
        const {events: n, ...o} = Is(e)
          , r = ((e,t)=>{
            const n = je(e, "components").getOr([]);
            return t.fold((()=>j(n, Ra)), (e=>j(n, ((t,n)=>Aa(t, xe(e, n))))))
        }
        )(o, t)
          , s = {
            ...o,
            events: {
                ...Hs,
                ...n
            },
            components: r
        };
        return nt.value(Ea(s, t))
    }
    )((e=>ze(e, "uid"))(e) ? e : {
        uid: Ma(""),
        ...e
    }, t).getOrDie()))
      , Ra = e=>Aa(e, E.none())
      , Na = Ls
      , Ba = (e,t)=>((e,t,n)=>cn(e, {}, Ft(n)))(e, 0, j(t, (t=>{
        return n = t.name(),
        o = "Cannot configure " + t.name() + " for " + e,
        Qt(n, n, {
            tag: "option",
            process: {}
        }, Tt((e=>pt("The field: " + n + " is forbidden. " + o))));
        var n, o
    }
    )).concat([Jt("dump", f)]))
      , Fa = (e,t)=>({
        ..._r(t),
        ...e.dump
    })
      , Da = Ba
      , Ha = Fa
      , Ia = v([Xt("menu"), Xt("selectedMenu")])
      , Pa = v([Xt("item"), Xt("selectedItem")]);
    var Va;
    v(Ft(Pa().concat(Ia())));
    const Wa = v(Ft(Pa()))
      , La = tn("initSize", [Xt("numColumns"), Xt("numRows")])
      , Ua = ()=>tn("markers", [Xt("backgroundMenu")].concat(Ia()).concat(Pa()))
      , ja = (e,t,n)=>((()=>{
        const e = new Error;
        if (void 0 !== e.stack) {
            const t = e.stack.split("\n");
            K(t, (e=>e.indexOf("alloy") > 0 && !U(qr, (t=>e.indexOf(t) > -1)))).getOr("unknown")
        }
    }
    )(),
    Qt(t, t, n, jt((e=>nt.value(((...t)=>e.apply(void 0, t)))))))
      , za = e=>ja(0, e, Ot(p))
      , $a = e=>ja(0, e, Ot(E.none))
      , qa = e=>ja(0, e, {
        tag: "required",
        process: {}
    })
      , Ga = e=>ja(0, e, {
        tag: "required",
        process: {}
    })
      , Ka = (e,t)=>Jt(e, v(t))
      , Ya = e=>Jt(e, f)
      , Qa = v(La)
      , Ja = "placeholder"
      , Xa = Mn([{
        single: ["required", "valueThunk"]
    }, {
        multiple: ["required", "valueThunks"]
    }])
      , Za = e=>ze(e, "uiType")
      , ei = (e,t,n,o)=>((e,t,n,o)=>Za(n) && n.uiType === Ja ? ((e,t,n,o)=>e.exists((e=>e !== n.owner)) ? Xa.single(!0, v(n)) : je(o, n.name).fold((()=>{
        throw new Error("Unknown placeholder component: " + n.name + "\nKnown: [" + Be(o) + "]\nNamespace: " + e.getOr("none") + "\nSpec: " + JSON.stringify(n, null, 2))
    }
    ), (e=>e.replace())))(e, 0, n, o) : Xa.single(!1, v(n)))(e, 0, n, o).fold(((r,s)=>{
        const a = Za(n) ? s(t, n.config, n.validated) : s(t)
          , i = je(a, "components").getOr([])
          , c = J(i, (n=>ei(e, t, n, o)));
        return [{
            ...a,
            components: c
        }]
    }
    ), ((e,o)=>{
        if (Za(n)) {
            const e = o(t, n.config, n.validated);
            return n.validated.preprocess.getOr(f)(e)
        }
        return o(t)
    }
    ))
      , ti = Xa.single
      , ni = Xa.multiple
      , oi = v(Ja)
      , ri = Mn([{
        required: ["data"]
    }, {
        external: ["data"]
    }, {
        optional: ["data"]
    }, {
        group: ["data"]
    }])
      , si = an("factory", {
        sketch: f
    })
      , ai = an("schema", [])
      , ii = Xt("name")
      , ci = Qt("pname", "pname", wt((e=>"<alloy." + Cs(e.name) + ">")), It())
      , li = Jt("schema", (()=>[nn("preprocess")]))
      , ui = an("defaults", v({}))
      , di = an("overrides", v({}))
      , mi = Ft([si, ai, ii, ci, ui, di])
      , gi = Ft([si, ai, ii, ui, di])
      , pi = Ft([si, ai, ii, ci, ui, di])
      , hi = Ft([si, li, ii, Xt("unit"), ci, ui, di])
      , vi = e=>{
        const t = e=>e.name;
        return e.fold(t, t, t, t)
    }
      , fi = (e,t)=>n=>{
        const o = Gt("Converting part type", t, n);
        return e(o)
    }
      , bi = fi(ri.required, mi)
      , yi = fi(ri.external, gi)
      , _i = fi(ri.optional, pi)
      , xi = fi(ri.group, hi)
      , wi = v("entirety")
      , Oi = (e,t,n,o)=>yt(t.defaults(e, n, o), n, {
        uid: e.partUids[t.name]
    }, t.overrides(e, n, o))
      , Si = (e,t)=>({
        uiType: oi(),
        owner: e,
        name: t
    })
      , Ci = (e,t,n)=>((e,t,n)=>{
        const o = {}
          , r = {};
        return z(n, (e=>{
            e.fold((e=>{
                o[e.pname] = ti(!0, ((t,n,o)=>e.factory.sketch(Oi(t, e, n, o))))
            }
            ), (e=>{
                const n = t.parts[e.name];
                r[e.name] = v(e.factory.sketch(Oi(t, e, n[wi()]), n))
            }
            ), (e=>{
                o[e.pname] = ti(!1, ((t,n,o)=>e.factory.sketch(Oi(t, e, n, o))))
            }
            ), (e=>{
                o[e.pname] = ni(!0, ((t,n,o)=>{
                    const r = t[e.name];
                    return j(r, (n=>e.factory.sketch(yt(e.defaults(t, n, o), n, e.overrides(t, n)))))
                }
                ))
            }
            ))
        }
        )),
        {
            internals: v(o),
            externals: v(r)
        }
    }
    )(0, t, n)
      , Ei = (e,t,n)=>((e,t,n,o)=>{
        const r = He(o, ((e,t)=>((e,t)=>{
            let n = !1;
            return {
                name: v(e),
                required: ()=>t.fold(((e,t)=>e), ((e,t)=>e)),
                used: ()=>n,
                replace: ()=>{
                    if (n)
                        throw new Error("Trying to use the same placeholder more than once: " + e);
                    return n = !0,
                    t
                }
            }
        }
        )(t, e)))
          , s = ((e,t,n,o)=>J(n, (n=>ei(e, t, n, o))))(e, t, n, r);
        return De(r, (n=>{
            if (!1 === n.used() && n.required())
                throw new Error("Placeholder: " + n.name() + " was not found in components list\nNamespace: " + e.getOr("none") + "\nComponents: " + JSON.stringify(t.components, null, 2))
        }
        )),
        s
    }
    )(E.some(e), t, t.components, n)
      , ki = e=>Qt("partUids", "partUids", St((t=>((e,t)=>{
        const n = (e=>j(e, vi))(t);
        return Rn(j(n, (t=>({
            key: t,
            value: e + "-" + t
        }))))
    }
    )(t.uid, e))), It())
      , Ti = (e,t,n,o,r)=>{
        const s = ((e,t)=>(e.length > 0 ? [tn("parts", e)] : []).concat([Xt("uid"), an("dom", {}), an("components", []), Ya("originalSpec"), an("debug.sketcher", {})]).concat(t))(o, r);
        return Gt(e + " [SpecSchema]", Bt(s.concat(t)), n)
    }
      , Mi = e=>(e=>ze(e, "uid"))(e) ? e : {
        ...e,
        uid: Ns("uid")
    }
      , Ai = Bt([Xt("name"), Xt("factory"), Xt("configFields"), an("apis", {}), an("extraApis", {})])
      , Ri = Bt([Xt("name"), Xt("factory"), Xt("configFields"), Xt("partFields"), an("apis", {}), an("extraApis", {})])
      , Ni = e=>{
        const t = Gt("Sketcher for " + e.name, Ai, e)
          , n = He(t.apis, js)
          , o = He(t.extraApis, ((e,t)=>hr(e, t)));
        return {
            name: t.name,
            configFields: t.configFields,
            sketch: e=>((e,t,n,o)=>{
                const r = Mi(o);
                return n(Ti(e, t, r, [], []), r)
            }
            )(t.name, t.configFields, t.factory, e),
            ...n,
            ...o
        }
    }
      , Bi = e=>{
        const t = Gt("Sketcher for " + e.name, Ri, e)
          , n = ((e,t)=>{
            const n = {};
            return z(t, (t=>{
                (e=>e.fold(E.some, E.none, E.some, E.some))(t).each((t=>{
                    const o = Si(e, t.pname);
                    n[t.name] = n=>{
                        const r = Gt("Part: " + t.name + " in " + e, Ft(t.schema), n);
                        return {
                            ...o,
                            config: n,
                            validated: r
                        }
                    }
                }
                ))
            }
            )),
            n
        }
        )(t.name, t.partFields)
          , o = He(t.apis, js)
          , r = He(t.extraApis, ((e,t)=>hr(e, t)));
        return {
            name: t.name,
            partFields: t.partFields,
            configFields: t.configFields,
            sketch: e=>((e,t,n,o,r)=>{
                const s = Mi(r)
                  , a = (e=>J(e, (e=>e.fold(E.none, E.some, E.none, E.none).map((e=>tn(e.name, e.schema.concat([Ya(wi())])))).toArray())))(n)
                  , i = ki(n)
                  , c = Ti(e, t, s, a, [i])
                  , l = Ci(0, c, n);
                return o(c, Ei(e, c, l.internals()), s, l.externals())
            }
            )(t.name, t.configFields, t.partFields, t.factory, e),
            parts: n,
            ...o,
            ...r
        }
    }
    ;
    Ni({
        name: "Container",
        factory: e=>{
            const {attributes: t, ...n} = e.dom;
            return {
                uid: e.uid,
                dom: {
                    tag: "div",
                    attributes: {
                        role: "presentation",
                        ...t
                    },
                    ...n
                },
                components: e.components,
                behaviours: (o = e.containerBehaviours,
                o.dump),
                events: e.events,
                domModification: e.domModification,
                eventOrder: e.eventOrder
            };
            var o
        }
        ,
        configFields: [an("components", []), Ba("containerBehaviours", []), an("events", {}), an("domModification", {}), an("eventOrder", {})]
    });
    const Fi = e=>e.getSystem().isConnected()
      , Di = e=>{
        Yo(e, jo());
        const t = e.components();
        z(t, Di)
    }
      , Hi = e=>{
        const t = e.components();
        z(t, Hi),
        Yo(e, Uo())
    }
      , Ii = (e,t)=>{
        e.getSystem().addToWorld(t),
        it(e.element) && Hi(t)
    }
      , Pi = e=>{
        Di(e),
        e.getSystem().removeFromWorld(e)
    }
      , Vi = (e,t)=>{
        Ne(e.element, t.element)
    }
      , Wi = (e,t)=>{
        Li(e, t, Ne)
    }
      , Li = (e,t,n)=>{
        e.getSystem().addToWorld(t),
        n(e.element, t.element),
        it(e.element) && Hi(t),
        e.syncComponents()
    }
      , Ui = e=>{
        Di(e),
        Nr(e.element),
        e.getSystem().removeFromWorld(e)
    }
      , ji = e=>{
        const t = be(e.element).bind((t=>e.getSystem().getByDom(t).toOptional()));
        Ui(e),
        t.each((e=>{
            e.syncComponents()
        }
        ))
    }
      , zi = e=>{
        const t = e.components();
        z(t, Ui),
        Rr(e.element),
        e.syncComponents()
    }
      , $i = e=>{
        const t = t=>be(e.element).fold(O, (e=>ce(t, e)))
          , n = Fs()
          , o = (e,o)=>n.find(t, e, o)
          , r = ((e,t)=>{
            const n = {
                stopBackspace: !0,
                ...t
            }
              , o = hs(n)
              , r = j(["touchstart", "touchmove", "touchend", "touchcancel", "gesturestart", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "click"].concat(["selectstart", "input", "contextmenu", "change", "transitionend", "transitioncancel", "drag", "dragstart", "dragend", "dragenter", "dragleave", "dragover", "drop", "keyup"]), (t=>Me(e, t, (e=>{
                o.fireIfReady(e, t).each((t=>{
                    t && e.kill()
                }
                )),
                n.triggerEvent(t, e) && e.kill()
            }
            ))))
              , s = Xr()
              , a = Me(e, "paste", (e=>{
                o.fireIfReady(e, "paste").each((t=>{
                    t && e.kill()
                }
                )),
                n.triggerEvent("paste", e) && e.kill(),
                s.set(setTimeout((()=>{
                    n.triggerEvent(Fo(), e)
                }
                ), 0))
            }
            ))
              , i = Me(e, "keydown", (e=>{
                n.triggerEvent("keydown", e) ? e.kill() : n.stopBackspace && (e=>{
                    return e.raw.which === ss[0] && !L(["input", "textarea"], le(e.target)) && (t = e.target,
                    !rs(t, '[contenteditable="true"]', void 0).isSome());
                    var t
                }
                )(e) && e.prevent()
            }
            ))
              , c = Me(e, "focusin", (e=>{
                n.triggerEvent("focusin", e) && e.kill()
            }
            ))
              , l = Xr()
              , u = Me(e, "focusout", (e=>{
                n.triggerEvent("focusout", e) && e.kill(),
                l.set(setTimeout((()=>{
                    n.triggerEvent(Bo(), e)
                }
                ), 0))
            }
            ));
            return {
                unbind: ()=>{
                    z(r, (e=>{
                        e.unbind()
                    }
                    )),
                    i.unbind(),
                    c.unbind(),
                    u.unbind(),
                    a.unbind(),
                    s.on(clearTimeout),
                    l.on(clearTimeout)
                }
            }
        }
        )(e.element, {
            triggerEvent: (e,t)=>Gr(e, t.target, (n=>((e,t,n,o)=>_s(e, t, n, n.target, o))(o, e, t, n)))
        })
          , s = {
            debugInfo: v("real"),
            triggerEvent: (e,t,n)=>{
                Gr(e, t, (r=>_s(o, e, n, t, r)))
            }
            ,
            triggerFocus: (e,t)=>{
                Rs(e).fold((()=>{
                    kr(e)
                }
                ), (n=>{
                    Gr(No(), e, (n=>(((e,t,n,o,r)=>{
                        const s = vs(n, o);
                        bs(e, t, n, o, s, r)
                    }
                    )(o, No(), {
                        originator: t,
                        kill: p,
                        prevent: p,
                        target: e
                    }, e, n),
                    !1)))
                }
                ))
            }
            ,
            triggerEscape: (e,t)=>{
                s.triggerEvent("keydown", e.element, t.event)
            }
            ,
            getByUid: e=>h(e),
            getByDom: e=>f(e),
            build: Ra,
            buildOrPatch: Aa,
            addToGui: e=>{
                c(e)
            }
            ,
            removeFromGui: e=>{
                l(e)
            }
            ,
            addToWorld: e=>{
                a(e)
            }
            ,
            removeFromWorld: e=>{
                i(e)
            }
            ,
            broadcast: e=>{
                d(e)
            }
            ,
            broadcastOn: (e,t)=>{
                m(e, t)
            }
            ,
            broadcastEvent: (e,t)=>{
                g(e, t)
            }
            ,
            isConnected: O
        }
          , a = e=>{
            e.connect(s),
            me(e.element) || (n.register(e),
            z(e.components(), a),
            s.triggerEvent(Lo(), e.element, {
                target: e.element
            }))
        }
          , i = e=>{
            me(e.element) || (z(e.components(), i),
            n.unregister(e)),
            e.disconnect()
        }
          , c = t=>{
            Wi(e, t)
        }
          , l = e=>{
            ji(e)
        }
          , u = e=>{
            const t = n.filter(Do());
            z(t, (t=>{
                const n = t.descHandler;
                Yr(n)(e)
            }
            ))
        }
          , d = e=>{
            u({
                universal: !0,
                data: e
            })
        }
          , m = (e,t)=>{
            u({
                universal: !1,
                channels: e,
                data: t
            })
        }
          , g = (e,t)=>((e,t,n)=>{
            const o = (e=>{
                const t = hn(!1);
                return {
                    stop: ()=>{
                        t.set(!0)
                    }
                    ,
                    cut: p,
                    isStopped: t.get,
                    isCut: w,
                    event: e,
                    setSource: _("Cannot set source of a broadcasted event"),
                    getSource: _("Cannot get source of a broadcasted event")
                }
            }
            )(t);
            return z(e, (e=>{
                const t = e.descHandler;
                Yr(t)(o)
            }
            )),
            o.isStopped()
        }
        )(n.filter(e), t)
          , h = e=>n.getById(e).fold((()=>nt.error(new Error('Could not find component with uid: "' + e + '" in system.'))), nt.value)
          , f = e=>{
            const t = Rs(e).getOr("not found");
            return h(t)
        }
        ;
        return a(e),
        {
            root: e,
            element: e.element,
            destroy: ()=>{
                r.unbind(),
                Nr(e.element)
            }
            ,
            add: c,
            remove: l,
            getByUid: h,
            getByDom: f,
            addToWorld: a,
            removeFromWorld: i,
            broadcast: d,
            broadcastOn: m,
            broadcastEvent: g
        }
    }
      , qi = e=>{
        const t = (e=>void 0 !== e.uid)(e) && $e(e, "uid") ? e.uid : Ns("memento");
        return {
            get: e=>e.getSystem().getByUid(t).getOrDie(),
            getOpt: e=>e.getSystem().getByUid(t).toOptional(),
            asSpec: ()=>({
                ...e,
                uid: t
            })
        }
    }
    ;
    var Gi = Object.freeze({
        __proto__: null,
        exhibit: (e,t)=>vr({
            classes: [],
            styles: t.useFixed() ? {} : {
                position: "relative"
            }
        })
    });
    const Ki = (e,t)=>({
        left: e,
        top: t,
        translate: (n,o)=>Ki(e + n, t + o)
    })
      , Yi = Ki
      , Qi = (e,t)=>void 0 !== e ? e : void 0 !== t ? t : 0
      , Ji = e=>{
        const t = e.dom.ownerDocument
          , n = t.body
          , o = t.defaultView
          , r = t.documentElement;
        if (n === e.dom)
            return Yi(n.offsetLeft, n.offsetTop);
        const s = Qi(null == o ? void 0 : o.pageYOffset, r.scrollTop)
          , a = Qi(null == o ? void 0 : o.pageXOffset, r.scrollLeft)
          , i = Qi(r.clientTop, n.clientTop)
          , c = Qi(r.clientLeft, n.clientLeft);
        return Xi(e).translate(a - c, s - i)
    }
      , Xi = e=>{
        const t = e.dom
          , n = t.ownerDocument.body;
        return n === t ? Yi(n.offsetLeft, n.offsetTop) : it(e) ? (e=>{
            const t = e.getBoundingClientRect();
            return Yi(t.left, t.top)
        }
        )(t) : Yi(0, 0)
    }
      , Zi = (e,t)=>{
        const n = Se(t)
          , o = Tr(n).bind((e=>{
            const n = t=>ce(e, t);
            return n(t) ? E.some(t) : ((e,t)=>{
                const n = e=>{
                    for (let o = 0; o < e.childNodes.length; o++) {
                        const r = R(e.childNodes[o]);
                        if (t(r))
                            return E.some(r);
                        const s = n(e.childNodes[o]);
                        if (s.isSome())
                            return s
                    }
                    return E.none()
                }
                ;
                return n(e.dom)
            }
            )(t, n)
        }
        ))
          , r = e(t);
        return o.each((e=>{
            Tr(n).filter((t=>ce(t, e))).fold((()=>{
                kr(e)
            }
            ), p)
        }
        )),
        r
    }
      , ec = (e,t)=>{
        const n = n=>{
            const o = t(n);
            if (o <= 0 || null === o) {
                const t = ga(n, e);
                return parseFloat(t) || 0
            }
            return o
        }
          , o = (e,t)=>G(t, ((t,n)=>{
            const o = ga(e, n)
              , r = void 0 === o ? 0 : parseInt(o, 10);
            return isNaN(r) ? t : t + r
        }
        ), 0);
        return {
            set: (t,n)=>{
                if (!g(n) && !n.match(/^[0-9]+$/))
                    throw new Error(e + ".set accepts only positive integer values. Value was " + n);
                const o = t.dom;
                ia(o) && (o.style[e] = n + "px")
            }
            ,
            get: n,
            getOuter: n,
            aggregate: o,
            max: (e,t,n)=>{
                const r = o(e, n);
                return t > r ? t - r : 0
            }
        }
    }
      , tc = ec("height", (e=>{
        const t = e.dom;
        return it(e) ? t.getBoundingClientRect().height : t.offsetHeight
    }
    ))
      , nc = e=>tc.get(e)
      , oc = e=>tc.getOuter(e)
      , rc = e=>{
        const t = void 0 !== e ? e.dom : document
          , n = t.body.scrollLeft || t.documentElement.scrollLeft
          , o = t.body.scrollTop || t.documentElement.scrollTop;
        return Yi(n, o)
    }
      , sc = ec("width", (e=>e.dom.offsetWidth))
      , ac = e=>sc.get(e)
      , ic = e=>sc.getOuter(e)
      , cc = (e,t,n,o)=>({
        x: e,
        y: t,
        width: n,
        height: o,
        right: e + n,
        bottom: t + o
    })
      , lc = (e,t)=>e.view(t).fold(v([]), (t=>{
        const n = e.owner(t)
          , o = lc(e, n);
        return [t].concat(o)
    }
    ));
    var uc = Object.freeze({
        __proto__: null,
        owner: e=>ve(e),
        view: e=>{
            var t;
            return (e.dom === document ? E.none() : E.from(null === (t = e.dom.defaultView) || void 0 === t ? void 0 : t.frameElement)).map(R)
        }
    });
    const dc = e=>{
        const t = Er()
          , n = rc(t)
          , o = ((e,t)=>{
            const n = t.owner(e)
              , o = lc(t, n);
            return E.some(o)
        }
        )(e, uc);
        return o.fold(y(Ji, e), (t=>{
            const o = Xi(e)
              , r = q(t, ((e,t)=>{
                const n = Xi(t);
                return {
                    left: e.left + n.left,
                    top: e.top + n.top
                }
            }
            ), {
                left: 0,
                top: 0
            });
            return Yi(r.left + o.left + n.left, r.top + o.top + n.top)
        }
        ))
    }
      , mc = (e,t,n,o)=>({
        x: e,
        y: t,
        width: n,
        height: o,
        right: e + n,
        bottom: t + o
    })
      , gc = ()=>(e=>{
        const t = void 0 === e ? window : e
          , n = t.document
          , o = rc(R(n));
        return (e=>{
            const t = void 0 === e ? window : e;
            return vo().browser.isFirefox() ? E.none() : E.from(t.visualViewport)
        }
        )(t).fold((()=>{
            const e = t.document.documentElement
              , n = e.clientWidth
              , r = e.clientHeight;
            return cc(o.left, o.top, n, r)
        }
        ), (e=>cc(Math.max(e.pageLeft, o.left), Math.max(e.pageTop, o.top), e.width, e.height)))
    }
    )(window)
      , pc = (e,t,n,o,r)=>{
        const s = e=>e + "px";
        return {
            position: e,
            left: t.map(s),
            top: n.map(s),
            right: o.map(s),
            bottom: r.map(s)
        }
    }
      , hc = Mn([{
        southeast: []
    }, {
        southwest: []
    }, {
        northeast: []
    }, {
        northwest: []
    }, {
        south: []
    }, {
        north: []
    }, {
        east: []
    }, {
        west: []
    }])
      , vc = hc.southeast
      , fc = hc.southwest
      , bc = hc.northeast
      , yc = hc.northwest
      , _c = hc.south
      , xc = hc.north
      , wc = hc.east
      , Oc = hc.west
      , Sc = Mn([{
        none: []
    }, {
        relative: ["x", "y", "width", "height"]
    }, {
        fixed: ["x", "y", "width", "height"]
    }])
      , Cc = (e,t,n,o,r,s)=>{
        const a = t.rect
          , i = a.x - n
          , c = a.y - o
          , l = r - (i + a.width)
          , u = s - (c + a.height)
          , d = E.some(i)
          , m = E.some(c)
          , g = E.some(l)
          , p = E.some(u)
          , h = E.none();
        return t.direction.fold((()=>pc(e, d, m, h, h)), (()=>pc(e, h, m, g, h)), (()=>pc(e, d, h, h, p)), (()=>pc(e, h, h, g, p)), (()=>pc(e, d, m, h, h)), (()=>pc(e, d, h, h, p)), (()=>pc(e, d, m, h, h)), (()=>pc(e, h, m, g, h)))
    }
      , Ec = (e,t)=>e.fold((()=>{
        const e = t.rect;
        return pc("absolute", E.some(e.x), E.some(e.y), E.none(), E.none())
    }
    ), ((e,n,o,r)=>Cc("absolute", t, e, n, o, r)), ((e,n,o,r)=>Cc("fixed", t, e, n, o, r)))
      , kc = (e,t)=>{
        const n = y(dc, t)
          , o = e.fold(n, n, (()=>{
            const e = rc();
            return dc(t).translate(-e.left, -e.top)
        }
        ))
          , r = ic(t)
          , s = oc(t);
        return mc(o.left, o.top, r, s)
    }
      , Tc = (e,t)=>t.fold((()=>e.fold(gc, gc, mc)), (t=>e.fold(v(t), v(t), (()=>{
        const n = Mc(e, t.x, t.y);
        return mc(n.left, n.top, t.width, t.height)
    }
    ))))
      , Mc = (e,t,n)=>{
        const o = Yi(t, n);
        return e.fold(v(o), v(o), (()=>{
            const e = rc();
            return o.translate(-e.left, -e.top)
        }
        ))
    }
    ;
    Sc.none;
    const Ac = Sc.relative
      , Rc = Sc.fixed
      , Nc = "data-alloy-placement"
      , Bc = (e,t)=>te(["left", "right", "top", "bottom"], (n=>je(t, n).map((t=>((e,t)=>{
        switch (t) {
        case 1:
            return e.x;
        case 0:
            return e.x + e.width;
        case 2:
            return e.y;
        case 3:
            return e.y + e.height
        }
    }
    )(e, t)))))
      , Fc = Mn([{
        fit: ["reposition"]
    }, {
        nofit: ["reposition", "visibleW", "visibleH", "isVisible"]
    }])
      , Dc = (e,t,n,o)=>{
        const r = e.bubble
          , s = r.offset
          , a = ((e,t,n)=>{
            const o = (o,r)=>t[o].map((t=>{
                const s = "top" === o || "bottom" === o
                  , a = s ? n.top : n.left
                  , i = ("left" === o || "top" === o ? Math.max : Math.min)(t, r) + a;
                return s ? ws(i, e.y, e.bottom) : ws(i, e.x, e.right)
            }
            )).getOr(r)
              , r = o("left", e.x)
              , s = o("top", e.y)
              , a = o("right", e.right)
              , i = o("bottom", e.bottom);
            return mc(r, s, a - r, i - s)
        }
        )(o, e.restriction, s)
          , i = e.x + s.left
          , c = e.y + s.top
          , l = mc(i, c, t, n)
          , {originInBounds: u, sizeInBounds: d, visibleW: m, visibleH: g} = ((e,t)=>{
            const {x: n, y: o, right: r, bottom: s} = t
              , {x: a, y: i, right: c, bottom: l, width: u, height: d} = e;
            return {
                originInBounds: a >= n && a <= r && i >= o && i <= s,
                sizeInBounds: c <= r && c >= n && l <= s && l >= o,
                visibleW: Math.min(u, a >= n ? r - a : c - n),
                visibleH: Math.min(d, i >= o ? s - i : l - o)
            }
        }
        )(l, a)
          , p = u && d
          , h = p ? l : ((e,t)=>{
            const {x: n, y: o, right: r, bottom: s} = t
              , {x: a, y: i, width: c, height: l} = e
              , u = Math.max(n, r - c)
              , d = Math.max(o, s - l)
              , m = ws(a, n, u)
              , g = ws(i, o, d)
              , p = Math.min(m + c, r) - m
              , h = Math.min(g + l, s) - g;
            return mc(m, g, p, h)
        }
        )(l, a)
          , f = h.width > 0 && h.height > 0
          , {maxWidth: b, maxHeight: y} = ((e,t,n)=>{
            const o = v(t.bottom - n.y)
              , r = v(n.bottom - t.y)
              , s = ((e,t,n,o)=>e.fold(t, t, o, o, t, o, n, n))(e, r, r, o)
              , a = v(t.right - n.x)
              , i = v(n.right - t.x)
              , c = ((e,t,n,o)=>e.fold(t, o, t, o, n, n, t, o))(e, i, i, a);
            return {
                maxWidth: c,
                maxHeight: s
            }
        }
        )(e.direction, h, o)
          , _ = {
            rect: h,
            maxHeight: y,
            maxWidth: b,
            direction: e.direction,
            placement: e.placement,
            classes: {
                on: r.classesOn,
                off: r.classesOff
            },
            layout: e.label,
            testY: c
        };
        return p || e.alwaysFit ? Fc.fit(_) : Fc.nofit(_, m, g, f)
    }
      , Hc = ["top", "bottom", "right", "left"]
      , Ic = "data-alloy-transition-timer"
      , Pc = (e,t,n,o,s,a)=>{
        const i = ((e,t,n)=>n.exists((n=>{
            const o = e.mode;
            return "all" === o || n[o] !== t[o]
        }
        )))(o, s, a);
        if (i || ((e,t)=>((e,t)=>X(t, (t=>ra(e, t))))(e, t.classes))(e, o)) {
            ua(e, "position", n.position);
            const a = kc(t, e)
              , c = Ec(t, {
                ...s,
                rect: a
            })
              , l = te(Hc, (e=>c[e]));
            ((e,t)=>{
                const n = e=>parseFloat(e).toFixed(3);
                return Ue(t, ((t,o)=>!((e,t,n=b)=>gr(e, t, n).getOr(e.isNone() && t.isNone()))(e[o].map(n), t.map(n)))).isSome()
            }
            )(n, l) && (ma(e, l),
            i && ((e,t)=>{
                sa(e, t.classes),
                Vr(e, Ic).each((t=>{
                    clearTimeout(parseInt(t, 10)),
                    Lr(e, Ic)
                }
                )),
                ((e,t)=>{
                    const n = Jr()
                      , o = Jr();
                    let s;
                    const a = t=>{
                        var n;
                        const o = null !== (n = t.raw.pseudoElement) && void 0 !== n ? n : "";
                        return ce(t.target, e) && !jn(o) && L(Hc, t.raw.propertyName)
                    }
                      , i = r=>{
                        if (u(r) || a(r)) {
                            n.clear(),
                            o.clear();
                            const a = null == r ? void 0 : r.raw.type;
                            (u(a) || a === To()) && (clearTimeout(s),
                            Lr(e, Ic),
                            aa(e, t.classes))
                        }
                    }
                      , c = Me(e, Mo(), (t=>{
                        a(t) && (c.unbind(),
                        n.set(Me(e, To(), i)),
                        o.set(Me(e, ko(), i)))
                    }
                    ))
                      , l = (e=>{
                        const t = t=>{
                            const n = ga(e, t).split(/\s*,\s*/);
                            return $(n, jn)
                        }
                          , n = e=>{
                            if (r(e) && /^[\d.]+/.test(e)) {
                                const t = parseFloat(e);
                                return Ln(e, "ms") ? t : 1e3 * t
                            }
                            return 0
                        }
                          , o = t("transition-delay")
                          , s = t("transition-duration");
                        return G(s, ((e,t,r)=>{
                            const s = n(o[r]) + n(t);
                            return Math.max(e, s)
                        }
                        ), 0)
                    }
                    )(e);
                    requestAnimationFrame((()=>{
                        s = setTimeout(i, l + 17),
                        Hr(e, Ic, s)
                    }
                    ))
                }
                )(e, t)
            }
            )(e, o),
            fa(e))
        } else
            aa(e, o.classes)
    }
      , Vc = v(((e,t)=>{
        ((e,t)=>{
            ((e,t)=>{
                const n = tc.max(e, t, ["margin-top", "border-top-width", "padding-top", "padding-bottom", "border-bottom-width", "margin-bottom"]);
                ua(e, "max-height", n + "px")
            }
            )(e, Math.floor(t))
        }
        )(e, t),
        da(e, {
            "overflow-x": "hidden",
            "overflow-y": "auto"
        })
    }
    ))
      , Wc = (e,t,n)=>void 0 === e[t] ? n : e[t]
      , Lc = (e,t,n,o)=>{
        const r = ((e,t,n,o)=>{
            va(t, "max-height"),
            va(t, "max-width");
            const r = {
                width: ic(s = t),
                height: oc(s)
            };
            var s;
            return ((e,t,n,o,r,s)=>{
                const a = o.width
                  , i = o.height
                  , c = (t,c,l,u,d)=>{
                    const m = t(n, o, r, e, s)
                      , g = Dc(m, a, i, s);
                    return g.fold(v(g), ((e,t,n,o)=>(d === o ? n > u || t > l : !d && o) ? g : Fc.nofit(c, l, u, d)))
                }
                ;
                return G(t, ((e,t)=>{
                    const n = y(c, t);
                    return e.fold(v(e), n)
                }
                ), Fc.nofit({
                    rect: n,
                    maxHeight: o.height,
                    maxWidth: o.width,
                    direction: vc(),
                    placement: "southeast",
                    classes: {
                        on: [],
                        off: []
                    },
                    layout: "none",
                    testY: n.y
                }, -1, -1, !1)).fold(f, f)
            }
            )(t, o.preference, e, r, n, o.bounds)
        }
        )(e, t, n, o);
        return ((e,t,n)=>{
            const o = Ec(n.origin, t);
            n.transition.each((r=>{
                Pc(e, n.origin, o, r, t, n.lastPlacement)
            }
            )),
            ((e,t)=>{
                ma(e, (e=>({
                    ...e,
                    position: E.some(e.position)
                }))(t))
            }
            )(e, o)
        }
        )(t, r, o),
        ((e,t)=>{
            ((e,t)=>{
                Hr(e, Nc, t)
            }
            )(e, t.placement)
        }
        )(t, r),
        ((e,t)=>{
            const n = t.classes;
            aa(e, n.off),
            sa(e, n.on)
        }
        )(t, r),
        ((e,t,n)=>{
            (0,
            n.maxHeightFunction)(e, t.maxHeight)
        }
        )(t, r, o),
        ((e,t,n)=>{
            (0,
            n.maxWidthFunction)(e, t.maxWidth)
        }
        )(t, r, o),
        {
            layout: r.layout,
            placement: r.placement
        }
    }
      , Uc = ["valignCentre", "alignLeft", "alignRight", "alignCentre", "top", "bottom", "left", "right", "inset"]
      , jc = ()=>((e,t,n,o=1)=>{
        const r = e * o
          , s = t * o
          , a = e=>je(n, e).getOr([])
          , i = (e,t,n)=>{
            const o = ee(Uc, n);
            return {
                offset: Yi(e, t),
                classesOn: J(n, a),
                classesOff: J(o, a)
            }
        }
        ;
        return {
            southeast: ()=>i(-e, t, ["top", "alignLeft"]),
            southwest: ()=>i(e, t, ["top", "alignRight"]),
            south: ()=>i(-e / 2, t, ["top", "alignCentre"]),
            northeast: ()=>i(-e, -t, ["bottom", "alignLeft"]),
            northwest: ()=>i(e, -t, ["bottom", "alignRight"]),
            north: ()=>i(-e / 2, -t, ["bottom", "alignCentre"]),
            east: ()=>i(e, -t / 2, ["valignCentre", "left"]),
            west: ()=>i(-e, -t / 2, ["valignCentre", "right"]),
            insetNortheast: ()=>i(r, s, ["top", "alignLeft", "inset"]),
            insetNorthwest: ()=>i(-r, s, ["top", "alignRight", "inset"]),
            insetNorth: ()=>i(-r / 2, s, ["top", "alignCentre", "inset"]),
            insetSoutheast: ()=>i(r, -s, ["bottom", "alignLeft", "inset"]),
            insetSouthwest: ()=>i(-r, -s, ["bottom", "alignRight", "inset"]),
            insetSouth: ()=>i(-r / 2, -s, ["bottom", "alignCentre", "inset"]),
            insetEast: ()=>i(-r, -s / 2, ["valignCentre", "right", "inset"]),
            insetWest: ()=>i(r, -s / 2, ["valignCentre", "left", "inset"])
        }
    }
    )(0, 0, {})
      , zc = (e,t,n,o,r,s,a,i=!1)=>({
        x: e,
        y: t,
        bubble: n,
        direction: o,
        placement: r,
        restriction: s,
        label: `${a}-${r}`,
        alwaysFit: i
    })
      , $c = "layout"
      , qc = e=>e.x
      , Gc = (e,t)=>e.x + e.width / 2 - t.width / 2
      , Kc = (e,t)=>e.x + e.width - t.width
      , Yc = (e,t)=>e.y - t.height
      , Qc = e=>e.y + e.height
      , Jc = (e,t)=>e.y + e.height / 2 - t.height / 2
      , Xc = (e,t,n)=>zc(qc(e), Qc(e), n.southeast(), vc(), "southeast", Bc(e, {
        left: 1,
        top: 3
    }), $c)
      , Zc = (e,t,n)=>zc(Kc(e, t), Qc(e), n.southwest(), fc(), "southwest", Bc(e, {
        right: 0,
        top: 3
    }), $c)
      , el = (e,t,n)=>zc(qc(e), Yc(e, t), n.northeast(), bc(), "northeast", Bc(e, {
        left: 1,
        bottom: 2
    }), $c)
      , tl = (e,t,n)=>zc(Kc(e, t), Yc(e, t), n.northwest(), yc(), "northwest", Bc(e, {
        right: 0,
        bottom: 2
    }), $c)
      , nl = (e,t,n)=>zc(Gc(e, t), Yc(e, t), n.north(), xc(), "north", Bc(e, {
        bottom: 2
    }), $c)
      , ol = (e,t,n)=>zc(Gc(e, t), Qc(e), n.south(), _c(), "south", Bc(e, {
        top: 3
    }), $c)
      , rl = (e,t,n)=>zc((e=>e.x + e.width)(e), Jc(e, t), n.east(), wc(), "east", Bc(e, {
        left: 0
    }), $c)
      , sl = (e,t,n)=>zc(((e,t)=>e.x - t.width)(e, t), Jc(e, t), n.west(), Oc(), "west", Bc(e, {
        right: 1
    }), $c)
      , al = ()=>[Xc, Zc, el, tl, ol, nl, rl, sl]
      , il = ()=>[Zc, Xc, tl, el, ol, nl, rl, sl]
      , cl = ()=>[el, tl, Xc, Zc, nl, ol]
      , ll = ()=>[tl, el, Zc, Xc, nl, ol]
      , ul = ()=>[Xc, Zc, el, tl, ol, nl]
      , dl = ()=>[Zc, Xc, tl, el, ol, nl]
      , ml = f
      , gl = (e,t)=>n=>"rtl" === pl(n) ? t : e
      , pl = e=>"rtl" === ga(e, "direction") ? "rtl" : "ltr"
      , hl = (e,t,n)=>ts(e, t, n).isSome();
    var vl;
    !function(e) {
        e.TopToBottom = "toptobottom",
        e.BottomToTop = "bottomtotop"
    }(vl || (vl = {}));
    const fl = e=>hl(e, (e=>de(e) && Pr(e, "data-alloy-vertical-dir") === vl.BottomToTop))
      , bl = ()=>rn("layouts", [Xt("onLtr"), Xt("onRtl"), nn("onBottomLtr"), nn("onBottomRtl")])
      , yl = (e,t,n,o,r,s,a)=>{
        const i = a.map(fl).getOr(!1)
          , c = t.layouts.map((t=>t.onLtr(e)))
          , l = t.layouts.map((t=>t.onRtl(e)))
          , u = i ? t.layouts.bind((t=>t.onBottomLtr.map((t=>t(e))))).or(c).getOr(r) : c.getOr(n)
          , d = i ? t.layouts.bind((t=>t.onBottomRtl.map((t=>t(e))))).or(l).getOr(s) : l.getOr(o);
        return gl(u, d)(e)
    }
    ;
    var _l = [Xt("hotspot"), nn("bubble"), an("overrides", {}), bl(), Ka("placement", ((e,t,n)=>{
        const o = t.hotspot
          , r = kc(n, o.element)
          , s = yl(e.element, t, ul(), dl(), cl(), ll(), E.some(t.hotspot.element));
        return E.some(ml({
            anchorBox: r,
            bubble: t.bubble.getOr(jc()),
            overrides: t.overrides,
            layouts: s
        }))
    }
    ))]
      , xl = [Xt("x"), Xt("y"), an("height", 0), an("width", 0), an("bubble", jc()), an("overrides", {}), bl(), Ka("placement", ((e,t,n)=>{
        const o = Mc(n, t.x, t.y)
          , r = mc(o.left, o.top, t.width, t.height)
          , s = yl(e.element, t, al(), il(), al(), il(), E.none());
        return E.some(ml({
            anchorBox: r,
            bubble: t.bubble,
            overrides: t.overrides,
            layouts: s
        }))
    }
    ))];
    const wl = Mn([{
        screen: ["point"]
    }, {
        absolute: ["point", "scrollLeft", "scrollTop"]
    }])
      , Ol = e=>e.fold(f, ((e,t,n)=>e.translate(-t, -n)))
      , Sl = e=>e.fold(f, f)
      , Cl = e=>G(e, ((e,t)=>e.translate(t.left, t.top)), Yi(0, 0))
      , El = e=>{
        const t = j(e, Sl);
        return Cl(t)
    }
      , kl = wl.screen
      , Tl = wl.absolute
      , Ml = (e,t,n)=>{
        const o = ve(e.element)
          , r = rc(o)
          , s = ((e,t,n)=>{
            const o = fe(n.root).dom;
            return E.from(o.frameElement).map(R).filter((t=>{
                const n = ve(t)
                  , o = ve(e.element);
                return ce(n, o)
            }
            )).map(Ji)
        }
        )(e, 0, n).getOr(r);
        return Tl(s, r.left, r.top)
    }
      , Al = (e,t,n,o)=>{
        const r = kl(Yi(e, t));
        return E.some(((e,t,n)=>({
            point: e,
            width: t,
            height: n
        }))(r, n, o))
    }
      , Rl = (e,t,n,o,r)=>e.map((e=>{
        const s = [t, e.point]
          , a = (i = ()=>El(s),
        c = ()=>El(s),
        l = ()=>(e=>{
            const t = j(e, Ol);
            return Cl(t)
        }
        )(s),
        o.fold(i, c, l));
        var i, c, l;
        const u = {
            x: a.left,
            y: a.top,
            width: e.width,
            height: e.height
        };
        const d = n.showAbove ? cl() : ul()
          , m = n.showAbove ? ll() : dl()
          , g = yl(r, n, d, m, d, m, E.none());
        return ml({
            anchorBox: u,
            bubble: n.bubble.getOr(jc()),
            overrides: n.overrides,
            layouts: g
        })
    }
    ));
    var Nl = [Xt("node"), Xt("root"), nn("bubble"), bl(), an("overrides", {}), an("showAbove", !1), Ka("placement", ((e,t,n)=>{
        const o = Ml(e, 0, t);
        return t.node.filter(it).bind((r=>{
            const s = r.dom.getBoundingClientRect()
              , a = Al(s.left, s.top, s.width, s.height)
              , i = t.node.getOr(e.element);
            return Rl(a, o, t, n, i)
        }
        ))
    }
    ))];
    const Bl = (e,t,n,o)=>({
        start: e,
        soffset: t,
        finish: n,
        foffset: o
    })
      , Fl = Mn([{
        before: ["element"]
    }, {
        on: ["element", "offset"]
    }, {
        after: ["element"]
    }])
      , Dl = (Fl.before,
    Fl.on,
    Fl.after,
    e=>e.fold(f, f, f))
      , Hl = Mn([{
        domRange: ["rng"]
    }, {
        relative: ["startSitu", "finishSitu"]
    }, {
        exact: ["start", "soffset", "finish", "foffset"]
    }])
      , Il = {
        domRange: Hl.domRange,
        relative: Hl.relative,
        exact: Hl.exact,
        exactFromRange: e=>Hl.exact(e.start, e.soffset, e.finish, e.foffset),
        getWin: e=>{
            const t = (e=>e.match({
                domRange: e=>R(e.startContainer),
                relative: (e,t)=>Dl(e),
                exact: (e,t,n,o)=>e
            }))(e);
            return fe(t)
        }
        ,
        range: Bl
    }
      , Pl = (e,t,n)=>{
        const o = e.document.createRange();
        var r;
        return r = o,
        t.fold((e=>{
            r.setStartBefore(e.dom)
        }
        ), ((e,t)=>{
            r.setStart(e.dom, t)
        }
        ), (e=>{
            r.setStartAfter(e.dom)
        }
        )),
        ((e,t)=>{
            t.fold((t=>{
                e.setEndBefore(t.dom)
            }
            ), ((t,n)=>{
                e.setEnd(t.dom, n)
            }
            ), (t=>{
                e.setEndAfter(t.dom)
            }
            ))
        }
        )(o, n),
        o
    }
      , Vl = (e,t,n,o,r)=>{
        const s = e.document.createRange();
        return s.setStart(t.dom, n),
        s.setEnd(o.dom, r),
        s
    }
      , Wl = e=>({
        left: e.left,
        top: e.top,
        right: e.right,
        bottom: e.bottom,
        width: e.width,
        height: e.height
    })
      , Ll = Mn([{
        ltr: ["start", "soffset", "finish", "foffset"]
    }, {
        rtl: ["start", "soffset", "finish", "foffset"]
    }])
      , Ul = (e,t,n)=>t(R(n.startContainer), n.startOffset, R(n.endContainer), n.endOffset)
      , jl = (e,t)=>((e,t)=>{
        const n = ((e,t)=>t.match({
            domRange: e=>({
                ltr: v(e),
                rtl: E.none
            }),
            relative: (t,n)=>({
                ltr: xt((()=>Pl(e, t, n))),
                rtl: xt((()=>E.some(Pl(e, n, t))))
            }),
            exact: (t,n,o,r)=>({
                ltr: xt((()=>Vl(e, t, n, o, r))),
                rtl: xt((()=>E.some(Vl(e, o, r, t, n))))
            })
        }))(e, t);
        return ((e,t)=>{
            const n = t.ltr();
            return n.collapsed ? t.rtl().filter((e=>!1 === e.collapsed)).map((e=>Ll.rtl(R(e.endContainer), e.endOffset, R(e.startContainer), e.startOffset))).getOrThunk((()=>Ul(0, Ll.ltr, n))) : Ul(0, Ll.ltr, n)
        }
        )(0, n)
    }
    )(e, t).match({
        ltr: (t,n,o,r)=>{
            const s = e.document.createRange();
            return s.setStart(t.dom, n),
            s.setEnd(o.dom, r),
            s
        }
        ,
        rtl: (t,n,o,r)=>{
            const s = e.document.createRange();
            return s.setStart(o.dom, r),
            s.setEnd(t.dom, n),
            s
        }
    });
    Ll.ltr,
    Ll.rtl;
    const zl = e=>{
        if (e.rangeCount > 0) {
            const t = e.getRangeAt(0)
              , n = e.getRangeAt(e.rangeCount - 1);
            return E.some(Bl(R(t.startContainer), t.startOffset, R(n.endContainer), n.endOffset))
        }
        return E.none()
    }
      , $l = e=>{
        if (null === e.anchorNode || null === e.focusNode)
            return zl(e);
        {
            const t = R(e.anchorNode)
              , n = R(e.focusNode);
            return ((e,t,n,o)=>{
                const r = ((e,t,n,o)=>{
                    const r = ve(e).dom.createRange();
                    return r.setStart(e.dom, t),
                    r.setEnd(n.dom, o),
                    r
                }
                )(e, t, n, o)
                  , s = ce(e, n) && t === o;
                return r.collapsed && !s
            }
            )(t, e.anchorOffset, n, e.focusOffset) ? E.some(Bl(t, e.anchorOffset, n, e.focusOffset)) : zl(e)
        }
    }
      , ql = ((e,t)=>{
        const n = t=>e(t) ? E.from(t.dom.nodeValue) : E.none();
        return {
            get: t=>{
                if (!e(t))
                    throw new Error("Can only get text value of a text node");
                return n(t).getOr("")
            }
            ,
            getOption: n,
            set: (t,n)=>{
                if (!e(t))
                    throw new Error("Can only set raw text value of a text node");
                t.dom.nodeValue = n
            }
        }
    }
    )(me)
      , Gl = (e,t)=>({
        element: e,
        offset: t
    })
      , Kl = (e,t)=>me(e) ? Gl(e, t) : ((e,t)=>{
        const n = _e(e);
        if (0 === n.length)
            return Gl(e, t);
        if (t < n.length)
            return Gl(n[t], 0);
        {
            const e = n[n.length - 1]
              , t = me(e) ? (e=>ql.get(e))(e).length : _e(e).length;
            return Gl(e, t)
        }
    }
    )(e, t)
      , Yl = e=>void 0 !== e.foffset
      , Ql = (e,t)=>t.getSelection.getOrThunk((()=>()=>(e=>(e=>E.from(e.getSelection()))(e).filter((e=>e.rangeCount > 0)).bind($l))(e)))().map((e=>{
        if (Yl(e)) {
            const t = Kl(e.start, e.soffset)
              , n = Kl(e.finish, e.foffset);
            return Il.range(t.element, t.offset, n.element, n.offset)
        }
        return e
    }
    ));
    var Jl = [nn("getSelection"), Xt("root"), nn("bubble"), bl(), an("overrides", {}), an("showAbove", !1), Ka("placement", ((e,t,n)=>{
        const o = fe(t.root).dom
          , r = Ml(e, 0, t)
          , s = Ql(o, t).bind((e=>{
            if (Yl(e)) {
                const t = ((e,t)=>(e=>{
                    const t = e.getBoundingClientRect();
                    return t.width > 0 || t.height > 0 ? E.some(t).map(Wl) : E.none()
                }
                )(jl(e, t)))(o, Il.exactFromRange(e)).orThunk((()=>{
                    const t = A("\ufeff");
                    Ae(e.start, t);
                    const n = ((e,t)=>(e=>{
                        const t = e.getClientRects()
                          , n = t.length > 0 ? t[0] : e.getBoundingClientRect();
                        return n.width > 0 || n.height > 0 ? E.some(n).map(Wl) : E.none()
                    }
                    )(jl(e, t)))(o, Il.exact(t, 0, t, 1));
                    return Nr(t),
                    n
                }
                ));
                return t.bind((e=>Al(e.left, e.top, e.width, e.height)))
            }
            {
                const t = He(e, (e=>e.dom.getBoundingClientRect()))
                  , n = {
                    left: Math.min(t.firstCell.left, t.lastCell.left),
                    right: Math.max(t.firstCell.right, t.lastCell.right),
                    top: Math.min(t.firstCell.top, t.lastCell.top),
                    bottom: Math.max(t.firstCell.bottom, t.lastCell.bottom)
                };
                return Al(n.left, n.top, n.right - n.left, n.bottom - n.top)
            }
        }
        ))
          , a = Ql(o, t).bind((e=>Yl(e) ? de(e.start) ? E.some(e.start) : ye(e.start) : E.some(e.firstCell))).getOr(e.element);
        return Rl(s, r, t, n, a)
    }
    ))];
    const Xl = "link-layout"
      , Zl = e=>e.x + e.width
      , eu = (e,t)=>e.x - t.width
      , tu = (e,t)=>e.y - t.height + e.height
      , nu = e=>e.y
      , ou = (e,t,n)=>zc(Zl(e), nu(e), n.southeast(), vc(), "southeast", Bc(e, {
        left: 0,
        top: 2
    }), Xl)
      , ru = (e,t,n)=>zc(eu(e, t), nu(e), n.southwest(), fc(), "southwest", Bc(e, {
        right: 1,
        top: 2
    }), Xl)
      , su = (e,t,n)=>zc(Zl(e), tu(e, t), n.northeast(), bc(), "northeast", Bc(e, {
        left: 0,
        bottom: 3
    }), Xl)
      , au = (e,t,n)=>zc(eu(e, t), tu(e, t), n.northwest(), yc(), "northwest", Bc(e, {
        right: 1,
        bottom: 3
    }), Xl)
      , iu = ()=>[ou, ru, su, au]
      , cu = ()=>[ru, ou, au, su];
    var lu = [Xt("item"), bl(), an("overrides", {}), Ka("placement", ((e,t,n)=>{
        const o = kc(n, t.item.element)
          , r = yl(e.element, t, iu(), cu(), iu(), cu(), E.none());
        return E.some(ml({
            anchorBox: o,
            bubble: jc(),
            overrides: t.overrides,
            layouts: r
        }))
    }
    ))]
      , uu = Yt("type", {
        selection: Jl,
        node: Nl,
        hotspot: _l,
        submenu: lu,
        makeshift: xl
    });
    const du = [((e,t)=>Qt(e, e, {
        tag: "required",
        process: {}
    }, Dt(t)))("classes", Vt), cn("mode", "all", (hu = ["all", "layout", "placement"],
    jt((e=>L(hu, e) ? nt.value(e) : nt.error(`Unsupported value: "${e}", choose one of "${hu.join(", ")}".`)))))]
      , mu = [an("useFixed", w), nn("getBounds")]
      , gu = [Zt("anchor", uu), rn("transition", du)]
      , pu = (e,t,n,o,r,s)=>{
        const a = Gt("placement.info", Ft(gu), r)
          , i = a.anchor
          , c = o.element
          , l = n.get(o.uid);
        Zi((()=>{
            ua(c, "position", "fixed");
            const r = ha(c, "visibility");
            ua(c, "visibility", "hidden");
            const u = t.useFixed() ? (()=>{
                const e = document.documentElement;
                return Rc(0, 0, e.clientWidth, e.clientHeight)
            }
            )() : (e=>{
                const t = Ji(e.element)
                  , n = e.element.dom.getBoundingClientRect();
                return Ac(t.left, t.top, n.width, n.height)
            }
            )(e);
            i.placement(e, i, u).each((e=>{
                const r = s.orThunk((()=>t.getBounds.map(x)))
                  , i = ((e,t,n,o,r,s)=>((e,t,n,o,r,s,a,i)=>{
                    const c = Wc(a, "maxHeightFunction", Vc())
                      , l = Wc(a, "maxWidthFunction", p)
                      , u = e.anchorBox
                      , d = e.origin
                      , m = {
                        bounds: Tc(d, s),
                        origin: d,
                        preference: o,
                        maxHeightFunction: c,
                        maxWidthFunction: l,
                        lastPlacement: r,
                        transition: i
                    };
                    return Lc(u, t, n, m)
                }
                )(((e,t)=>((e,t)=>({
                    anchorBox: e,
                    origin: t
                }))(e, t))(t.anchorBox, e), o.element, t.bubble, t.layouts, r, n, t.overrides, s))(u, e, r, o, l, a.transition);
                n.set(o.uid, i)
            }
            )),
            r.fold((()=>{
                va(c, "visibility")
            }
            ), (e=>{
                ua(c, "visibility", e)
            }
            )),
            ha(c, "left").isNone() && ha(c, "top").isNone() && ha(c, "right").isNone() && ha(c, "bottom").isNone() && dr(ha(c, "position"), "fixed") && va(c, "position")
        }
        ), c)
    }
    ;
    var hu, vu = Object.freeze({
        __proto__: null,
        getMode: (e,t,n)=>t.useFixed() ? "fixed" : "absolute",
        position: (e,t,n,o,r)=>{
            const s = E.none();
            pu(e, t, n, o, r, s)
        }
        ,
        positionWithinBounds: pu,
        reset: (e,t,n,o)=>{
            const r = o.element;
            z(["position", "left", "right", "top", "bottom"], (e=>va(r, e))),
            (e=>{
                Lr(e, Nc)
            }
            )(r),
            n.clear(o.uid)
        }
    });
    const fu = wr({
        fields: mu,
        name: "positioning",
        active: Gi,
        apis: vu,
        state: Object.freeze({
            __proto__: null,
            init: ()=>{
                let e = {};
                return Tn({
                    readState: ()=>e,
                    clear: t=>{
                        d(t) ? delete e[t] : e = {}
                    }
                    ,
                    set: (t,n)=>{
                        e[t] = n
                    }
                    ,
                    get: t=>je(e, t)
                })
            }
        })
    })
      , bu = (e,t)=>{
        Zi((()=>{
            ((e,t,n)=>{
                const o = e.components();
                (e=>{
                    z(e.components(), (e=>Nr(e.element))),
                    Rr(e.element),
                    e.syncComponents()
                }
                )(e);
                const r = n(t)
                  , s = ee(o, r);
                z(s, (t=>{
                    Di(t),
                    e.getSystem().removeFromWorld(t)
                }
                )),
                z(r, (t=>{
                    Fi(t) ? Vi(e, t) : (e.getSystem().addToWorld(t),
                    Vi(e, t),
                    it(e.element) && Hi(t))
                }
                )),
                e.syncComponents()
            }
            )(e, t, (()=>j(t, e.getSystem().build)))
        }
        ), e.element)
    }
      , yu = (e,t)=>{
        Zi((()=>{
            ((n,o,r)=>{
                const s = n.components()
                  , a = J(o, (e=>Us(e).toArray()));
                z(s, (e=>{
                    L(a, e) || Pi(e)
                }
                ));
                const i = ((e,t,n)=>xa(e, t, ((t,o)=>wa(e, o, t, n))))(e.element, t, e.getSystem().buildOrPatch)
                  , c = ee(s, i);
                z(c, (e=>{
                    Fi(e) && Pi(e)
                }
                )),
                z(i, (e=>{
                    Fi(e) || Ii(n, e)
                }
                )),
                n.syncComponents()
            }
            )(e, t)
        }
        ), e.element)
    }
      , _u = (e,t,n,o)=>{
        Pi(t);
        const r = wa(e.element, n, o, e.getSystem().buildOrPatch);
        Ii(e, r),
        e.syncComponents()
    }
      , xu = (e,t,n)=>{
        const o = e.getSystem().build(n);
        Li(e, o, t)
    }
      , wu = (e,t,n,o)=>{
        ji(t),
        xu(e, ((e,t)=>((e,t,n)=>{
            xe(e, n).fold((()=>{
                Ne(e, t)
            }
            ), (e=>{
                Ae(e, t)
            }
            ))
        }
        )(e, t, n)), o)
    }
      , Ou = (e,t)=>e.components()
      , Su = (e,t,n,o,r)=>{
        const s = Ou(e);
        return E.from(s[o]).map((n=>(r.fold((()=>ji(n)), (r=>{
            (t.reuseDom ? _u : wu)(e, n, o, r)
        }
        )),
        n)))
    }
    ;
    var Cu = Object.freeze({
        __proto__: null,
        append: (e,t,n,o)=>{
            xu(e, Ne, o)
        }
        ,
        contents: Ou,
        prepend: (e,t,n,o)=>{
            xu(e, Re, o)
        }
        ,
        remove: (e,t,n,o)=>{
            const r = Ou(e)
              , s = K(r, (e=>ce(o.element, e.element)));
            s.each(ji)
        }
        ,
        replaceAt: Su,
        replaceBy: (e,t,n,o,r)=>{
            const s = Ou(e);
            return Y(s, o).bind((n=>Su(e, t, 0, n, r)))
        }
        ,
        set: (e,t,n,o)=>(t.reuseDom ? yu : bu)(e, o)
    });
    const Eu = wr({
        fields: [cn("reuseDom", !0, Wt)],
        name: "replacing",
        apis: Cu
    })
      , ku = e=>!(e=>e.offsetWidth <= 0 && e.offsetHeight <= 0)(e.dom);
    var Tu, Mu = {
        exports: {}
    };
    (Tu = Mu).exports && (Tu.exports = function() {
        var e = 3
          , t = 4
          , n = 12
          , o = 13
          , r = 16
          , s = 17;
        function a(e, t) {
            void 0 === t && (t = 0);
            var n = e.charCodeAt(t);
            if (55296 <= n && n <= 56319 && t < e.length - 1) {
                var o = n;
                return 56320 <= (r = e.charCodeAt(t + 1)) && r <= 57343 ? 1024 * (o - 55296) + (r - 56320) + 65536 : o
            }
            if (56320 <= n && n <= 57343 && t >= 1) {
                var r = n;
                return 55296 <= (o = e.charCodeAt(t - 1)) && o <= 56319 ? 1024 * (o - 55296) + (r - 56320) + 65536 : r
            }
            return n
        }
        function i(a, i, c) {
            var l = [a].concat(i).concat([c])
              , u = l[l.length - 2]
              , d = c
              , m = l.lastIndexOf(14);
            if (m > 1 && l.slice(1, m).every((function(t) {
                return t == e
            }
            )) && -1 == [e, o, s].indexOf(a))
                return 2;
            var g = l.lastIndexOf(t);
            if (g > 0 && l.slice(1, g).every((function(e) {
                return e == t
            }
            )) && -1 == [n, t].indexOf(u))
                return l.filter((function(e) {
                    return e == t
                }
                )).length % 2 == 1 ? 3 : 4;
            if (0 == u && 1 == d)
                return 0;
            if (2 == u || 0 == u || 1 == u)
                return 14 == d && i.every((function(t) {
                    return t == e
                }
                )) ? 2 : 1;
            if (2 == d || 0 == d || 1 == d)
                return 1;
            if (6 == u && (6 == d || 7 == d || 9 == d || 10 == d))
                return 0;
            if (!(9 != u && 7 != u || 7 != d && 8 != d))
                return 0;
            if ((10 == u || 8 == u) && 8 == d)
                return 0;
            if (d == e || 15 == d)
                return 0;
            if (5 == d)
                return 0;
            if (u == n)
                return 0;
            var p = -1 != l.indexOf(e) ? l.lastIndexOf(e) - 1 : l.length - 2;
            return -1 != [o, s].indexOf(l[p]) && l.slice(p + 1, -1).every((function(t) {
                return t == e
            }
            )) && 14 == d || 15 == u && -1 != [r, s].indexOf(d) ? 0 : -1 != i.indexOf(t) ? 2 : u == t && d == t ? 0 : 1
        }
        function c(a) {
            return 1536 <= a && a <= 1541 || 1757 == a || 1807 == a || 2274 == a || 3406 == a || 69821 == a || 70082 <= a && a <= 70083 || 72250 == a || 72326 <= a && a <= 72329 || 73030 == a ? n : 13 == a ? 0 : 10 == a ? 1 : 0 <= a && a <= 9 || 11 <= a && a <= 12 || 14 <= a && a <= 31 || 127 <= a && a <= 159 || 173 == a || 1564 == a || 6158 == a || 8203 == a || 8206 <= a && a <= 8207 || 8232 == a || 8233 == a || 8234 <= a && a <= 8238 || 8288 <= a && a <= 8292 || 8293 == a || 8294 <= a && a <= 8303 || 55296 <= a && a <= 57343 || 65279 == a || 65520 <= a && a <= 65528 || 65529 <= a && a <= 65531 || 113824 <= a && a <= 113827 || 119155 <= a && a <= 119162 || 917504 == a || 917505 == a || 917506 <= a && a <= 917535 || 917632 <= a && a <= 917759 || 918e3 <= a && a <= 921599 ? 2 : 768 <= a && a <= 879 || 1155 <= a && a <= 1159 || 1160 <= a && a <= 1161 || 1425 <= a && a <= 1469 || 1471 == a || 1473 <= a && a <= 1474 || 1476 <= a && a <= 1477 || 1479 == a || 1552 <= a && a <= 1562 || 1611 <= a && a <= 1631 || 1648 == a || 1750 <= a && a <= 1756 || 1759 <= a && a <= 1764 || 1767 <= a && a <= 1768 || 1770 <= a && a <= 1773 || 1809 == a || 1840 <= a && a <= 1866 || 1958 <= a && a <= 1968 || 2027 <= a && a <= 2035 || 2070 <= a && a <= 2073 || 2075 <= a && a <= 2083 || 2085 <= a && a <= 2087 || 2089 <= a && a <= 2093 || 2137 <= a && a <= 2139 || 2260 <= a && a <= 2273 || 2275 <= a && a <= 2306 || 2362 == a || 2364 == a || 2369 <= a && a <= 2376 || 2381 == a || 2385 <= a && a <= 2391 || 2402 <= a && a <= 2403 || 2433 == a || 2492 == a || 2494 == a || 2497 <= a && a <= 2500 || 2509 == a || 2519 == a || 2530 <= a && a <= 2531 || 2561 <= a && a <= 2562 || 2620 == a || 2625 <= a && a <= 2626 || 2631 <= a && a <= 2632 || 2635 <= a && a <= 2637 || 2641 == a || 2672 <= a && a <= 2673 || 2677 == a || 2689 <= a && a <= 2690 || 2748 == a || 2753 <= a && a <= 2757 || 2759 <= a && a <= 2760 || 2765 == a || 2786 <= a && a <= 2787 || 2810 <= a && a <= 2815 || 2817 == a || 2876 == a || 2878 == a || 2879 == a || 2881 <= a && a <= 2884 || 2893 == a || 2902 == a || 2903 == a || 2914 <= a && a <= 2915 || 2946 == a || 3006 == a || 3008 == a || 3021 == a || 3031 == a || 3072 == a || 3134 <= a && a <= 3136 || 3142 <= a && a <= 3144 || 3146 <= a && a <= 3149 || 3157 <= a && a <= 3158 || 3170 <= a && a <= 3171 || 3201 == a || 3260 == a || 3263 == a || 3266 == a || 3270 == a || 3276 <= a && a <= 3277 || 3285 <= a && a <= 3286 || 3298 <= a && a <= 3299 || 3328 <= a && a <= 3329 || 3387 <= a && a <= 3388 || 3390 == a || 3393 <= a && a <= 3396 || 3405 == a || 3415 == a || 3426 <= a && a <= 3427 || 3530 == a || 3535 == a || 3538 <= a && a <= 3540 || 3542 == a || 3551 == a || 3633 == a || 3636 <= a && a <= 3642 || 3655 <= a && a <= 3662 || 3761 == a || 3764 <= a && a <= 3769 || 3771 <= a && a <= 3772 || 3784 <= a && a <= 3789 || 3864 <= a && a <= 3865 || 3893 == a || 3895 == a || 3897 == a || 3953 <= a && a <= 3966 || 3968 <= a && a <= 3972 || 3974 <= a && a <= 3975 || 3981 <= a && a <= 3991 || 3993 <= a && a <= 4028 || 4038 == a || 4141 <= a && a <= 4144 || 4146 <= a && a <= 4151 || 4153 <= a && a <= 4154 || 4157 <= a && a <= 4158 || 4184 <= a && a <= 4185 || 4190 <= a && a <= 4192 || 4209 <= a && a <= 4212 || 4226 == a || 4229 <= a && a <= 4230 || 4237 == a || 4253 == a || 4957 <= a && a <= 4959 || 5906 <= a && a <= 5908 || 5938 <= a && a <= 5940 || 5970 <= a && a <= 5971 || 6002 <= a && a <= 6003 || 6068 <= a && a <= 6069 || 6071 <= a && a <= 6077 || 6086 == a || 6089 <= a && a <= 6099 || 6109 == a || 6155 <= a && a <= 6157 || 6277 <= a && a <= 6278 || 6313 == a || 6432 <= a && a <= 6434 || 6439 <= a && a <= 6440 || 6450 == a || 6457 <= a && a <= 6459 || 6679 <= a && a <= 6680 || 6683 == a || 6742 == a || 6744 <= a && a <= 6750 || 6752 == a || 6754 == a || 6757 <= a && a <= 6764 || 6771 <= a && a <= 6780 || 6783 == a || 6832 <= a && a <= 6845 || 6846 == a || 6912 <= a && a <= 6915 || 6964 == a || 6966 <= a && a <= 6970 || 6972 == a || 6978 == a || 7019 <= a && a <= 7027 || 7040 <= a && a <= 7041 || 7074 <= a && a <= 7077 || 7080 <= a && a <= 7081 || 7083 <= a && a <= 7085 || 7142 == a || 7144 <= a && a <= 7145 || 7149 == a || 7151 <= a && a <= 7153 || 7212 <= a && a <= 7219 || 7222 <= a && a <= 7223 || 7376 <= a && a <= 7378 || 7380 <= a && a <= 7392 || 7394 <= a && a <= 7400 || 7405 == a || 7412 == a || 7416 <= a && a <= 7417 || 7616 <= a && a <= 7673 || 7675 <= a && a <= 7679 || 8204 == a || 8400 <= a && a <= 8412 || 8413 <= a && a <= 8416 || 8417 == a || 8418 <= a && a <= 8420 || 8421 <= a && a <= 8432 || 11503 <= a && a <= 11505 || 11647 == a || 11744 <= a && a <= 11775 || 12330 <= a && a <= 12333 || 12334 <= a && a <= 12335 || 12441 <= a && a <= 12442 || 42607 == a || 42608 <= a && a <= 42610 || 42612 <= a && a <= 42621 || 42654 <= a && a <= 42655 || 42736 <= a && a <= 42737 || 43010 == a || 43014 == a || 43019 == a || 43045 <= a && a <= 43046 || 43204 <= a && a <= 43205 || 43232 <= a && a <= 43249 || 43302 <= a && a <= 43309 || 43335 <= a && a <= 43345 || 43392 <= a && a <= 43394 || 43443 == a || 43446 <= a && a <= 43449 || 43452 == a || 43493 == a || 43561 <= a && a <= 43566 || 43569 <= a && a <= 43570 || 43573 <= a && a <= 43574 || 43587 == a || 43596 == a || 43644 == a || 43696 == a || 43698 <= a && a <= 43700 || 43703 <= a && a <= 43704 || 43710 <= a && a <= 43711 || 43713 == a || 43756 <= a && a <= 43757 || 43766 == a || 44005 == a || 44008 == a || 44013 == a || 64286 == a || 65024 <= a && a <= 65039 || 65056 <= a && a <= 65071 || 65438 <= a && a <= 65439 || 66045 == a || 66272 == a || 66422 <= a && a <= 66426 || 68097 <= a && a <= 68099 || 68101 <= a && a <= 68102 || 68108 <= a && a <= 68111 || 68152 <= a && a <= 68154 || 68159 == a || 68325 <= a && a <= 68326 || 69633 == a || 69688 <= a && a <= 69702 || 69759 <= a && a <= 69761 || 69811 <= a && a <= 69814 || 69817 <= a && a <= 69818 || 69888 <= a && a <= 69890 || 69927 <= a && a <= 69931 || 69933 <= a && a <= 69940 || 70003 == a || 70016 <= a && a <= 70017 || 70070 <= a && a <= 70078 || 70090 <= a && a <= 70092 || 70191 <= a && a <= 70193 || 70196 == a || 70198 <= a && a <= 70199 || 70206 == a || 70367 == a || 70371 <= a && a <= 70378 || 70400 <= a && a <= 70401 || 70460 == a || 70462 == a || 70464 == a || 70487 == a || 70502 <= a && a <= 70508 || 70512 <= a && a <= 70516 || 70712 <= a && a <= 70719 || 70722 <= a && a <= 70724 || 70726 == a || 70832 == a || 70835 <= a && a <= 70840 || 70842 == a || 70845 == a || 70847 <= a && a <= 70848 || 70850 <= a && a <= 70851 || 71087 == a || 71090 <= a && a <= 71093 || 71100 <= a && a <= 71101 || 71103 <= a && a <= 71104 || 71132 <= a && a <= 71133 || 71219 <= a && a <= 71226 || 71229 == a || 71231 <= a && a <= 71232 || 71339 == a || 71341 == a || 71344 <= a && a <= 71349 || 71351 == a || 71453 <= a && a <= 71455 || 71458 <= a && a <= 71461 || 71463 <= a && a <= 71467 || 72193 <= a && a <= 72198 || 72201 <= a && a <= 72202 || 72243 <= a && a <= 72248 || 72251 <= a && a <= 72254 || 72263 == a || 72273 <= a && a <= 72278 || 72281 <= a && a <= 72283 || 72330 <= a && a <= 72342 || 72344 <= a && a <= 72345 || 72752 <= a && a <= 72758 || 72760 <= a && a <= 72765 || 72767 == a || 72850 <= a && a <= 72871 || 72874 <= a && a <= 72880 || 72882 <= a && a <= 72883 || 72885 <= a && a <= 72886 || 73009 <= a && a <= 73014 || 73018 == a || 73020 <= a && a <= 73021 || 73023 <= a && a <= 73029 || 73031 == a || 92912 <= a && a <= 92916 || 92976 <= a && a <= 92982 || 94095 <= a && a <= 94098 || 113821 <= a && a <= 113822 || 119141 == a || 119143 <= a && a <= 119145 || 119150 <= a && a <= 119154 || 119163 <= a && a <= 119170 || 119173 <= a && a <= 119179 || 119210 <= a && a <= 119213 || 119362 <= a && a <= 119364 || 121344 <= a && a <= 121398 || 121403 <= a && a <= 121452 || 121461 == a || 121476 == a || 121499 <= a && a <= 121503 || 121505 <= a && a <= 121519 || 122880 <= a && a <= 122886 || 122888 <= a && a <= 122904 || 122907 <= a && a <= 122913 || 122915 <= a && a <= 122916 || 122918 <= a && a <= 122922 || 125136 <= a && a <= 125142 || 125252 <= a && a <= 125258 || 917536 <= a && a <= 917631 || 917760 <= a && a <= 917999 ? e : 127462 <= a && a <= 127487 ? t : 2307 == a || 2363 == a || 2366 <= a && a <= 2368 || 2377 <= a && a <= 2380 || 2382 <= a && a <= 2383 || 2434 <= a && a <= 2435 || 2495 <= a && a <= 2496 || 2503 <= a && a <= 2504 || 2507 <= a && a <= 2508 || 2563 == a || 2622 <= a && a <= 2624 || 2691 == a || 2750 <= a && a <= 2752 || 2761 == a || 2763 <= a && a <= 2764 || 2818 <= a && a <= 2819 || 2880 == a || 2887 <= a && a <= 2888 || 2891 <= a && a <= 2892 || 3007 == a || 3009 <= a && a <= 3010 || 3014 <= a && a <= 3016 || 3018 <= a && a <= 3020 || 3073 <= a && a <= 3075 || 3137 <= a && a <= 3140 || 3202 <= a && a <= 3203 || 3262 == a || 3264 <= a && a <= 3265 || 3267 <= a && a <= 3268 || 3271 <= a && a <= 3272 || 3274 <= a && a <= 3275 || 3330 <= a && a <= 3331 || 3391 <= a && a <= 3392 || 3398 <= a && a <= 3400 || 3402 <= a && a <= 3404 || 3458 <= a && a <= 3459 || 3536 <= a && a <= 3537 || 3544 <= a && a <= 3550 || 3570 <= a && a <= 3571 || 3635 == a || 3763 == a || 3902 <= a && a <= 3903 || 3967 == a || 4145 == a || 4155 <= a && a <= 4156 || 4182 <= a && a <= 4183 || 4228 == a || 6070 == a || 6078 <= a && a <= 6085 || 6087 <= a && a <= 6088 || 6435 <= a && a <= 6438 || 6441 <= a && a <= 6443 || 6448 <= a && a <= 6449 || 6451 <= a && a <= 6456 || 6681 <= a && a <= 6682 || 6741 == a || 6743 == a || 6765 <= a && a <= 6770 || 6916 == a || 6965 == a || 6971 == a || 6973 <= a && a <= 6977 || 6979 <= a && a <= 6980 || 7042 == a || 7073 == a || 7078 <= a && a <= 7079 || 7082 == a || 7143 == a || 7146 <= a && a <= 7148 || 7150 == a || 7154 <= a && a <= 7155 || 7204 <= a && a <= 7211 || 7220 <= a && a <= 7221 || 7393 == a || 7410 <= a && a <= 7411 || 7415 == a || 43043 <= a && a <= 43044 || 43047 == a || 43136 <= a && a <= 43137 || 43188 <= a && a <= 43203 || 43346 <= a && a <= 43347 || 43395 == a || 43444 <= a && a <= 43445 || 43450 <= a && a <= 43451 || 43453 <= a && a <= 43456 || 43567 <= a && a <= 43568 || 43571 <= a && a <= 43572 || 43597 == a || 43755 == a || 43758 <= a && a <= 43759 || 43765 == a || 44003 <= a && a <= 44004 || 44006 <= a && a <= 44007 || 44009 <= a && a <= 44010 || 44012 == a || 69632 == a || 69634 == a || 69762 == a || 69808 <= a && a <= 69810 || 69815 <= a && a <= 69816 || 69932 == a || 70018 == a || 70067 <= a && a <= 70069 || 70079 <= a && a <= 70080 || 70188 <= a && a <= 70190 || 70194 <= a && a <= 70195 || 70197 == a || 70368 <= a && a <= 70370 || 70402 <= a && a <= 70403 || 70463 == a || 70465 <= a && a <= 70468 || 70471 <= a && a <= 70472 || 70475 <= a && a <= 70477 || 70498 <= a && a <= 70499 || 70709 <= a && a <= 70711 || 70720 <= a && a <= 70721 || 70725 == a || 70833 <= a && a <= 70834 || 70841 == a || 70843 <= a && a <= 70844 || 70846 == a || 70849 == a || 71088 <= a && a <= 71089 || 71096 <= a && a <= 71099 || 71102 == a || 71216 <= a && a <= 71218 || 71227 <= a && a <= 71228 || 71230 == a || 71340 == a || 71342 <= a && a <= 71343 || 71350 == a || 71456 <= a && a <= 71457 || 71462 == a || 72199 <= a && a <= 72200 || 72249 == a || 72279 <= a && a <= 72280 || 72343 == a || 72751 == a || 72766 == a || 72873 == a || 72881 == a || 72884 == a || 94033 <= a && a <= 94078 || 119142 == a || 119149 == a ? 5 : 4352 <= a && a <= 4447 || 43360 <= a && a <= 43388 ? 6 : 4448 <= a && a <= 4519 || 55216 <= a && a <= 55238 ? 7 : 4520 <= a && a <= 4607 || 55243 <= a && a <= 55291 ? 8 : 44032 == a || 44060 == a || 44088 == a || 44116 == a || 44144 == a || 44172 == a || 44200 == a || 44228 == a || 44256 == a || 44284 == a || 44312 == a || 44340 == a || 44368 == a || 44396 == a || 44424 == a || 44452 == a || 44480 == a || 44508 == a || 44536 == a || 44564 == a || 44592 == a || 44620 == a || 44648 == a || 44676 == a || 44704 == a || 44732 == a || 44760 == a || 44788 == a || 44816 == a || 44844 == a || 44872 == a || 44900 == a || 44928 == a || 44956 == a || 44984 == a || 45012 == a || 45040 == a || 45068 == a || 45096 == a || 45124 == a || 45152 == a || 45180 == a || 45208 == a || 45236 == a || 45264 == a || 45292 == a || 45320 == a || 45348 == a || 45376 == a || 45404 == a || 45432 == a || 45460 == a || 45488 == a || 45516 == a || 45544 == a || 45572 == a || 45600 == a || 45628 == a || 45656 == a || 45684 == a || 45712 == a || 45740 == a || 45768 == a || 45796 == a || 45824 == a || 45852 == a || 45880 == a || 45908 == a || 45936 == a || 45964 == a || 45992 == a || 46020 == a || 46048 == a || 46076 == a || 46104 == a || 46132 == a || 46160 == a || 46188 == a || 46216 == a || 46244 == a || 46272 == a || 46300 == a || 46328 == a || 46356 == a || 46384 == a || 46412 == a || 46440 == a || 46468 == a || 46496 == a || 46524 == a || 46552 == a || 46580 == a || 46608 == a || 46636 == a || 46664 == a || 46692 == a || 46720 == a || 46748 == a || 46776 == a || 46804 == a || 46832 == a || 46860 == a || 46888 == a || 46916 == a || 46944 == a || 46972 == a || 47e3 == a || 47028 == a || 47056 == a || 47084 == a || 47112 == a || 47140 == a || 47168 == a || 47196 == a || 47224 == a || 47252 == a || 47280 == a || 47308 == a || 47336 == a || 47364 == a || 47392 == a || 47420 == a || 47448 == a || 47476 == a || 47504 == a || 47532 == a || 47560 == a || 47588 == a || 47616 == a || 47644 == a || 47672 == a || 47700 == a || 47728 == a || 47756 == a || 47784 == a || 47812 == a || 47840 == a || 47868 == a || 47896 == a || 47924 == a || 47952 == a || 47980 == a || 48008 == a || 48036 == a || 48064 == a || 48092 == a || 48120 == a || 48148 == a || 48176 == a || 48204 == a || 48232 == a || 48260 == a || 48288 == a || 48316 == a || 48344 == a || 48372 == a || 48400 == a || 48428 == a || 48456 == a || 48484 == a || 48512 == a || 48540 == a || 48568 == a || 48596 == a || 48624 == a || 48652 == a || 48680 == a || 48708 == a || 48736 == a || 48764 == a || 48792 == a || 48820 == a || 48848 == a || 48876 == a || 48904 == a || 48932 == a || 48960 == a || 48988 == a || 49016 == a || 49044 == a || 49072 == a || 49100 == a || 49128 == a || 49156 == a || 49184 == a || 49212 == a || 49240 == a || 49268 == a || 49296 == a || 49324 == a || 49352 == a || 49380 == a || 49408 == a || 49436 == a || 49464 == a || 49492 == a || 49520 == a || 49548 == a || 49576 == a || 49604 == a || 49632 == a || 49660 == a || 49688 == a || 49716 == a || 49744 == a || 49772 == a || 49800 == a || 49828 == a || 49856 == a || 49884 == a || 49912 == a || 49940 == a || 49968 == a || 49996 == a || 50024 == a || 50052 == a || 50080 == a || 50108 == a || 50136 == a || 50164 == a || 50192 == a || 50220 == a || 50248 == a || 50276 == a || 50304 == a || 50332 == a || 50360 == a || 50388 == a || 50416 == a || 50444 == a || 50472 == a || 50500 == a || 50528 == a || 50556 == a || 50584 == a || 50612 == a || 50640 == a || 50668 == a || 50696 == a || 50724 == a || 50752 == a || 50780 == a || 50808 == a || 50836 == a || 50864 == a || 50892 == a || 50920 == a || 50948 == a || 50976 == a || 51004 == a || 51032 == a || 51060 == a || 51088 == a || 51116 == a || 51144 == a || 51172 == a || 51200 == a || 51228 == a || 51256 == a || 51284 == a || 51312 == a || 51340 == a || 51368 == a || 51396 == a || 51424 == a || 51452 == a || 51480 == a || 51508 == a || 51536 == a || 51564 == a || 51592 == a || 51620 == a || 51648 == a || 51676 == a || 51704 == a || 51732 == a || 51760 == a || 51788 == a || 51816 == a || 51844 == a || 51872 == a || 51900 == a || 51928 == a || 51956 == a || 51984 == a || 52012 == a || 52040 == a || 52068 == a || 52096 == a || 52124 == a || 52152 == a || 52180 == a || 52208 == a || 52236 == a || 52264 == a || 52292 == a || 52320 == a || 52348 == a || 52376 == a || 52404 == a || 52432 == a || 52460 == a || 52488 == a || 52516 == a || 52544 == a || 52572 == a || 52600 == a || 52628 == a || 52656 == a || 52684 == a || 52712 == a || 52740 == a || 52768 == a || 52796 == a || 52824 == a || 52852 == a || 52880 == a || 52908 == a || 52936 == a || 52964 == a || 52992 == a || 53020 == a || 53048 == a || 53076 == a || 53104 == a || 53132 == a || 53160 == a || 53188 == a || 53216 == a || 53244 == a || 53272 == a || 53300 == a || 53328 == a || 53356 == a || 53384 == a || 53412 == a || 53440 == a || 53468 == a || 53496 == a || 53524 == a || 53552 == a || 53580 == a || 53608 == a || 53636 == a || 53664 == a || 53692 == a || 53720 == a || 53748 == a || 53776 == a || 53804 == a || 53832 == a || 53860 == a || 53888 == a || 53916 == a || 53944 == a || 53972 == a || 54e3 == a || 54028 == a || 54056 == a || 54084 == a || 54112 == a || 54140 == a || 54168 == a || 54196 == a || 54224 == a || 54252 == a || 54280 == a || 54308 == a || 54336 == a || 54364 == a || 54392 == a || 54420 == a || 54448 == a || 54476 == a || 54504 == a || 54532 == a || 54560 == a || 54588 == a || 54616 == a || 54644 == a || 54672 == a || 54700 == a || 54728 == a || 54756 == a || 54784 == a || 54812 == a || 54840 == a || 54868 == a || 54896 == a || 54924 == a || 54952 == a || 54980 == a || 55008 == a || 55036 == a || 55064 == a || 55092 == a || 55120 == a || 55148 == a || 55176 == a ? 9 : 44033 <= a && a <= 44059 || 44061 <= a && a <= 44087 || 44089 <= a && a <= 44115 || 44117 <= a && a <= 44143 || 44145 <= a && a <= 44171 || 44173 <= a && a <= 44199 || 44201 <= a && a <= 44227 || 44229 <= a && a <= 44255 || 44257 <= a && a <= 44283 || 44285 <= a && a <= 44311 || 44313 <= a && a <= 44339 || 44341 <= a && a <= 44367 || 44369 <= a && a <= 44395 || 44397 <= a && a <= 44423 || 44425 <= a && a <= 44451 || 44453 <= a && a <= 44479 || 44481 <= a && a <= 44507 || 44509 <= a && a <= 44535 || 44537 <= a && a <= 44563 || 44565 <= a && a <= 44591 || 44593 <= a && a <= 44619 || 44621 <= a && a <= 44647 || 44649 <= a && a <= 44675 || 44677 <= a && a <= 44703 || 44705 <= a && a <= 44731 || 44733 <= a && a <= 44759 || 44761 <= a && a <= 44787 || 44789 <= a && a <= 44815 || 44817 <= a && a <= 44843 || 44845 <= a && a <= 44871 || 44873 <= a && a <= 44899 || 44901 <= a && a <= 44927 || 44929 <= a && a <= 44955 || 44957 <= a && a <= 44983 || 44985 <= a && a <= 45011 || 45013 <= a && a <= 45039 || 45041 <= a && a <= 45067 || 45069 <= a && a <= 45095 || 45097 <= a && a <= 45123 || 45125 <= a && a <= 45151 || 45153 <= a && a <= 45179 || 45181 <= a && a <= 45207 || 45209 <= a && a <= 45235 || 45237 <= a && a <= 45263 || 45265 <= a && a <= 45291 || 45293 <= a && a <= 45319 || 45321 <= a && a <= 45347 || 45349 <= a && a <= 45375 || 45377 <= a && a <= 45403 || 45405 <= a && a <= 45431 || 45433 <= a && a <= 45459 || 45461 <= a && a <= 45487 || 45489 <= a && a <= 45515 || 45517 <= a && a <= 45543 || 45545 <= a && a <= 45571 || 45573 <= a && a <= 45599 || 45601 <= a && a <= 45627 || 45629 <= a && a <= 45655 || 45657 <= a && a <= 45683 || 45685 <= a && a <= 45711 || 45713 <= a && a <= 45739 || 45741 <= a && a <= 45767 || 45769 <= a && a <= 45795 || 45797 <= a && a <= 45823 || 45825 <= a && a <= 45851 || 45853 <= a && a <= 45879 || 45881 <= a && a <= 45907 || 45909 <= a && a <= 45935 || 45937 <= a && a <= 45963 || 45965 <= a && a <= 45991 || 45993 <= a && a <= 46019 || 46021 <= a && a <= 46047 || 46049 <= a && a <= 46075 || 46077 <= a && a <= 46103 || 46105 <= a && a <= 46131 || 46133 <= a && a <= 46159 || 46161 <= a && a <= 46187 || 46189 <= a && a <= 46215 || 46217 <= a && a <= 46243 || 46245 <= a && a <= 46271 || 46273 <= a && a <= 46299 || 46301 <= a && a <= 46327 || 46329 <= a && a <= 46355 || 46357 <= a && a <= 46383 || 46385 <= a && a <= 46411 || 46413 <= a && a <= 46439 || 46441 <= a && a <= 46467 || 46469 <= a && a <= 46495 || 46497 <= a && a <= 46523 || 46525 <= a && a <= 46551 || 46553 <= a && a <= 46579 || 46581 <= a && a <= 46607 || 46609 <= a && a <= 46635 || 46637 <= a && a <= 46663 || 46665 <= a && a <= 46691 || 46693 <= a && a <= 46719 || 46721 <= a && a <= 46747 || 46749 <= a && a <= 46775 || 46777 <= a && a <= 46803 || 46805 <= a && a <= 46831 || 46833 <= a && a <= 46859 || 46861 <= a && a <= 46887 || 46889 <= a && a <= 46915 || 46917 <= a && a <= 46943 || 46945 <= a && a <= 46971 || 46973 <= a && a <= 46999 || 47001 <= a && a <= 47027 || 47029 <= a && a <= 47055 || 47057 <= a && a <= 47083 || 47085 <= a && a <= 47111 || 47113 <= a && a <= 47139 || 47141 <= a && a <= 47167 || 47169 <= a && a <= 47195 || 47197 <= a && a <= 47223 || 47225 <= a && a <= 47251 || 47253 <= a && a <= 47279 || 47281 <= a && a <= 47307 || 47309 <= a && a <= 47335 || 47337 <= a && a <= 47363 || 47365 <= a && a <= 47391 || 47393 <= a && a <= 47419 || 47421 <= a && a <= 47447 || 47449 <= a && a <= 47475 || 47477 <= a && a <= 47503 || 47505 <= a && a <= 47531 || 47533 <= a && a <= 47559 || 47561 <= a && a <= 47587 || 47589 <= a && a <= 47615 || 47617 <= a && a <= 47643 || 47645 <= a && a <= 47671 || 47673 <= a && a <= 47699 || 47701 <= a && a <= 47727 || 47729 <= a && a <= 47755 || 47757 <= a && a <= 47783 || 47785 <= a && a <= 47811 || 47813 <= a && a <= 47839 || 47841 <= a && a <= 47867 || 47869 <= a && a <= 47895 || 47897 <= a && a <= 47923 || 47925 <= a && a <= 47951 || 47953 <= a && a <= 47979 || 47981 <= a && a <= 48007 || 48009 <= a && a <= 48035 || 48037 <= a && a <= 48063 || 48065 <= a && a <= 48091 || 48093 <= a && a <= 48119 || 48121 <= a && a <= 48147 || 48149 <= a && a <= 48175 || 48177 <= a && a <= 48203 || 48205 <= a && a <= 48231 || 48233 <= a && a <= 48259 || 48261 <= a && a <= 48287 || 48289 <= a && a <= 48315 || 48317 <= a && a <= 48343 || 48345 <= a && a <= 48371 || 48373 <= a && a <= 48399 || 48401 <= a && a <= 48427 || 48429 <= a && a <= 48455 || 48457 <= a && a <= 48483 || 48485 <= a && a <= 48511 || 48513 <= a && a <= 48539 || 48541 <= a && a <= 48567 || 48569 <= a && a <= 48595 || 48597 <= a && a <= 48623 || 48625 <= a && a <= 48651 || 48653 <= a && a <= 48679 || 48681 <= a && a <= 48707 || 48709 <= a && a <= 48735 || 48737 <= a && a <= 48763 || 48765 <= a && a <= 48791 || 48793 <= a && a <= 48819 || 48821 <= a && a <= 48847 || 48849 <= a && a <= 48875 || 48877 <= a && a <= 48903 || 48905 <= a && a <= 48931 || 48933 <= a && a <= 48959 || 48961 <= a && a <= 48987 || 48989 <= a && a <= 49015 || 49017 <= a && a <= 49043 || 49045 <= a && a <= 49071 || 49073 <= a && a <= 49099 || 49101 <= a && a <= 49127 || 49129 <= a && a <= 49155 || 49157 <= a && a <= 49183 || 49185 <= a && a <= 49211 || 49213 <= a && a <= 49239 || 49241 <= a && a <= 49267 || 49269 <= a && a <= 49295 || 49297 <= a && a <= 49323 || 49325 <= a && a <= 49351 || 49353 <= a && a <= 49379 || 49381 <= a && a <= 49407 || 49409 <= a && a <= 49435 || 49437 <= a && a <= 49463 || 49465 <= a && a <= 49491 || 49493 <= a && a <= 49519 || 49521 <= a && a <= 49547 || 49549 <= a && a <= 49575 || 49577 <= a && a <= 49603 || 49605 <= a && a <= 49631 || 49633 <= a && a <= 49659 || 49661 <= a && a <= 49687 || 49689 <= a && a <= 49715 || 49717 <= a && a <= 49743 || 49745 <= a && a <= 49771 || 49773 <= a && a <= 49799 || 49801 <= a && a <= 49827 || 49829 <= a && a <= 49855 || 49857 <= a && a <= 49883 || 49885 <= a && a <= 49911 || 49913 <= a && a <= 49939 || 49941 <= a && a <= 49967 || 49969 <= a && a <= 49995 || 49997 <= a && a <= 50023 || 50025 <= a && a <= 50051 || 50053 <= a && a <= 50079 || 50081 <= a && a <= 50107 || 50109 <= a && a <= 50135 || 50137 <= a && a <= 50163 || 50165 <= a && a <= 50191 || 50193 <= a && a <= 50219 || 50221 <= a && a <= 50247 || 50249 <= a && a <= 50275 || 50277 <= a && a <= 50303 || 50305 <= a && a <= 50331 || 50333 <= a && a <= 50359 || 50361 <= a && a <= 50387 || 50389 <= a && a <= 50415 || 50417 <= a && a <= 50443 || 50445 <= a && a <= 50471 || 50473 <= a && a <= 50499 || 50501 <= a && a <= 50527 || 50529 <= a && a <= 50555 || 50557 <= a && a <= 50583 || 50585 <= a && a <= 50611 || 50613 <= a && a <= 50639 || 50641 <= a && a <= 50667 || 50669 <= a && a <= 50695 || 50697 <= a && a <= 50723 || 50725 <= a && a <= 50751 || 50753 <= a && a <= 50779 || 50781 <= a && a <= 50807 || 50809 <= a && a <= 50835 || 50837 <= a && a <= 50863 || 50865 <= a && a <= 50891 || 50893 <= a && a <= 50919 || 50921 <= a && a <= 50947 || 50949 <= a && a <= 50975 || 50977 <= a && a <= 51003 || 51005 <= a && a <= 51031 || 51033 <= a && a <= 51059 || 51061 <= a && a <= 51087 || 51089 <= a && a <= 51115 || 51117 <= a && a <= 51143 || 51145 <= a && a <= 51171 || 51173 <= a && a <= 51199 || 51201 <= a && a <= 51227 || 51229 <= a && a <= 51255 || 51257 <= a && a <= 51283 || 51285 <= a && a <= 51311 || 51313 <= a && a <= 51339 || 51341 <= a && a <= 51367 || 51369 <= a && a <= 51395 || 51397 <= a && a <= 51423 || 51425 <= a && a <= 51451 || 51453 <= a && a <= 51479 || 51481 <= a && a <= 51507 || 51509 <= a && a <= 51535 || 51537 <= a && a <= 51563 || 51565 <= a && a <= 51591 || 51593 <= a && a <= 51619 || 51621 <= a && a <= 51647 || 51649 <= a && a <= 51675 || 51677 <= a && a <= 51703 || 51705 <= a && a <= 51731 || 51733 <= a && a <= 51759 || 51761 <= a && a <= 51787 || 51789 <= a && a <= 51815 || 51817 <= a && a <= 51843 || 51845 <= a && a <= 51871 || 51873 <= a && a <= 51899 || 51901 <= a && a <= 51927 || 51929 <= a && a <= 51955 || 51957 <= a && a <= 51983 || 51985 <= a && a <= 52011 || 52013 <= a && a <= 52039 || 52041 <= a && a <= 52067 || 52069 <= a && a <= 52095 || 52097 <= a && a <= 52123 || 52125 <= a && a <= 52151 || 52153 <= a && a <= 52179 || 52181 <= a && a <= 52207 || 52209 <= a && a <= 52235 || 52237 <= a && a <= 52263 || 52265 <= a && a <= 52291 || 52293 <= a && a <= 52319 || 52321 <= a && a <= 52347 || 52349 <= a && a <= 52375 || 52377 <= a && a <= 52403 || 52405 <= a && a <= 52431 || 52433 <= a && a <= 52459 || 52461 <= a && a <= 52487 || 52489 <= a && a <= 52515 || 52517 <= a && a <= 52543 || 52545 <= a && a <= 52571 || 52573 <= a && a <= 52599 || 52601 <= a && a <= 52627 || 52629 <= a && a <= 52655 || 52657 <= a && a <= 52683 || 52685 <= a && a <= 52711 || 52713 <= a && a <= 52739 || 52741 <= a && a <= 52767 || 52769 <= a && a <= 52795 || 52797 <= a && a <= 52823 || 52825 <= a && a <= 52851 || 52853 <= a && a <= 52879 || 52881 <= a && a <= 52907 || 52909 <= a && a <= 52935 || 52937 <= a && a <= 52963 || 52965 <= a && a <= 52991 || 52993 <= a && a <= 53019 || 53021 <= a && a <= 53047 || 53049 <= a && a <= 53075 || 53077 <= a && a <= 53103 || 53105 <= a && a <= 53131 || 53133 <= a && a <= 53159 || 53161 <= a && a <= 53187 || 53189 <= a && a <= 53215 || 53217 <= a && a <= 53243 || 53245 <= a && a <= 53271 || 53273 <= a && a <= 53299 || 53301 <= a && a <= 53327 || 53329 <= a && a <= 53355 || 53357 <= a && a <= 53383 || 53385 <= a && a <= 53411 || 53413 <= a && a <= 53439 || 53441 <= a && a <= 53467 || 53469 <= a && a <= 53495 || 53497 <= a && a <= 53523 || 53525 <= a && a <= 53551 || 53553 <= a && a <= 53579 || 53581 <= a && a <= 53607 || 53609 <= a && a <= 53635 || 53637 <= a && a <= 53663 || 53665 <= a && a <= 53691 || 53693 <= a && a <= 53719 || 53721 <= a && a <= 53747 || 53749 <= a && a <= 53775 || 53777 <= a && a <= 53803 || 53805 <= a && a <= 53831 || 53833 <= a && a <= 53859 || 53861 <= a && a <= 53887 || 53889 <= a && a <= 53915 || 53917 <= a && a <= 53943 || 53945 <= a && a <= 53971 || 53973 <= a && a <= 53999 || 54001 <= a && a <= 54027 || 54029 <= a && a <= 54055 || 54057 <= a && a <= 54083 || 54085 <= a && a <= 54111 || 54113 <= a && a <= 54139 || 54141 <= a && a <= 54167 || 54169 <= a && a <= 54195 || 54197 <= a && a <= 54223 || 54225 <= a && a <= 54251 || 54253 <= a && a <= 54279 || 54281 <= a && a <= 54307 || 54309 <= a && a <= 54335 || 54337 <= a && a <= 54363 || 54365 <= a && a <= 54391 || 54393 <= a && a <= 54419 || 54421 <= a && a <= 54447 || 54449 <= a && a <= 54475 || 54477 <= a && a <= 54503 || 54505 <= a && a <= 54531 || 54533 <= a && a <= 54559 || 54561 <= a && a <= 54587 || 54589 <= a && a <= 54615 || 54617 <= a && a <= 54643 || 54645 <= a && a <= 54671 || 54673 <= a && a <= 54699 || 54701 <= a && a <= 54727 || 54729 <= a && a <= 54755 || 54757 <= a && a <= 54783 || 54785 <= a && a <= 54811 || 54813 <= a && a <= 54839 || 54841 <= a && a <= 54867 || 54869 <= a && a <= 54895 || 54897 <= a && a <= 54923 || 54925 <= a && a <= 54951 || 54953 <= a && a <= 54979 || 54981 <= a && a <= 55007 || 55009 <= a && a <= 55035 || 55037 <= a && a <= 55063 || 55065 <= a && a <= 55091 || 55093 <= a && a <= 55119 || 55121 <= a && a <= 55147 || 55149 <= a && a <= 55175 || 55177 <= a && a <= 55203 ? 10 : 9757 == a || 9977 == a || 9994 <= a && a <= 9997 || 127877 == a || 127938 <= a && a <= 127940 || 127943 == a || 127946 <= a && a <= 127948 || 128066 <= a && a <= 128067 || 128070 <= a && a <= 128080 || 128110 == a || 128112 <= a && a <= 128120 || 128124 == a || 128129 <= a && a <= 128131 || 128133 <= a && a <= 128135 || 128170 == a || 128372 <= a && a <= 128373 || 128378 == a || 128400 == a || 128405 <= a && a <= 128406 || 128581 <= a && a <= 128583 || 128587 <= a && a <= 128591 || 128675 == a || 128692 <= a && a <= 128694 || 128704 == a || 128716 == a || 129304 <= a && a <= 129308 || 129310 <= a && a <= 129311 || 129318 == a || 129328 <= a && a <= 129337 || 129341 <= a && a <= 129342 || 129489 <= a && a <= 129501 ? o : 127995 <= a && a <= 127999 ? 14 : 8205 == a ? 15 : 9792 == a || 9794 == a || 9877 <= a && a <= 9878 || 9992 == a || 10084 == a || 127752 == a || 127806 == a || 127859 == a || 127891 == a || 127908 == a || 127912 == a || 127979 == a || 127981 == a || 128139 == a || 128187 <= a && a <= 128188 || 128295 == a || 128300 == a || 128488 == a || 128640 == a || 128658 == a ? r : 128102 <= a && a <= 128105 ? s : 11
        }
        return this.nextBreak = function(e, t) {
            if (void 0 === t && (t = 0),
            t < 0)
                return 0;
            if (t >= e.length - 1)
                return e.length;
            for (var n, o, r = c(a(e, t)), s = [], l = t + 1; l < e.length; l++)
                if (o = l - 1,
                !(55296 <= (n = e).charCodeAt(o) && n.charCodeAt(o) <= 56319 && 56320 <= n.charCodeAt(o + 1) && n.charCodeAt(o + 1) <= 57343)) {
                    var u = c(a(e, l));
                    if (i(r, s, u))
                        return l;
                    s.push(u)
                }
            return e.length
        }
        ,
        this.splitGraphemes = function(e) {
            for (var t, n = [], o = 0; (t = this.nextBreak(e, o)) < e.length; )
                n.push(e.slice(o, t)),
                o = t;
            return o < e.length && n.push(e.slice(o)),
            n
        }
        ,
        this.iterateGraphemes = function(e) {
            var t = 0
              , n = {
                next: function() {
                    var n, o;
                    return (o = this.nextBreak(e, t)) < e.length ? (n = e.slice(t, o),
                    t = o,
                    {
                        value: n,
                        done: !1
                    }) : t < e.length ? (n = e.slice(t),
                    t = e.length,
                    {
                        value: n,
                        done: !1
                    }) : {
                        value: void 0,
                        done: !0
                    }
                }
                .bind(this)
            };
            return "undefined" != typeof Symbol && Symbol.iterator && (n[Symbol.iterator] = function() {
                return n
            }
            ),
            n
        }
        ,
        this.countGraphemes = function(e) {
            for (var t, n = 0, o = 0; (t = this.nextBreak(e, o)) < e.length; )
                o = t,
                n++;
            return o < e.length && n++,
            n
        }
        ,
        this
    }
    );
    var Au, Ru = (Au = Mu.exports) && Au.__esModule && Object.prototype.hasOwnProperty.call(Au, "default") ? Au.default : Au;
    const Nu = vo().os.isMacOS() ? "\u2318" : "Ctrl"
      , Bu = He({
        tc_menu_name: "TinyComments",
        tc_conversations_title: "Comments",
        tc_announce_sidebar_available: `Comment. Sidebar available. Press ${Nu} + Alt + M to switch to sidebar`,
        tc_items_addcomment: "Add comment",
        tc_items_showcomments: "Show comments",
        tc_items_deleteall: "Delete all conversations",
        tc_edit_buttons_save: "Save",
        tc_edit_buttons_cancel: "Cancel",
        tc_reply_buttons_comment: "Comment",
        tc_reply_buttons_clear: "Clear",
        tc_reply_placeholders: "Add comment...",
        tc_kebab_delete_conversation: "Delete conversation",
        tc_kebab_resolve_conversation: "Resolve conversation",
        tc_kebab_delete: "Delete",
        tc_kebab_edit: "Edit",
        tc_edit_problem_comment: "An error occurred editing this comment. See the console for details.",
        tc_edit_unauthorised_comment: "You are not allowed to edit this comment",
        tc_delete_buttons_cancel: "Cancel",
        tc_delete_buttons_proceed: "Delete",
        tc_resolve_buttons_proceed: "Resolve",
        tc_create_problem: "An error occurred while creating a comment. See the console for details",
        tc_reply_problem: "An error occurred while replying to a comment. See the console for details",
        tc_delete_prompts_conversation: "Delete this conversation?",
        tc_delete_prompts_conversation_detail_sing: "1 comment will be deleted. You can't undo this action.",
        tc_delete_prompts_conversation_detail_pl: "{0} comments will be deleted. You can't undo this action.",
        tc_delete_prompts_all: "Delete all conversations in the content? This cannot be undone.",
        tc_delete_prompts_comment: "Are you sure you want to delete this comment?",
        tc_resolve_prompts_conversation: "Resolve this conversation?",
        tc_resolve_prompts_conversation_detail_sing: "1 comment will be resolved. You can't undo this action.",
        tc_resolve_prompts_conversation_detail_pl: "{0} comments will be resolved. You can't undo this action.",
        tc_delete_problem_all: "An error occurred deleting all the conversations. See the console for details.",
        tc_delete_problem_conversation: "An error occurred deleting the conversation. See the console for details.",
        tc_delete_problem_comment: "An error occurred deleting the comment. See the console for details.",
        tc_delete_unauthorised_all: "You are not allowed to delete all the conversations",
        tc_delete_unauthorised_conversation: "You are not allowed to delete this conversation",
        tc_delete_unauthorised_comment: "You are not allowed to delete this comment",
        tc_resolve_unauthorised_conversation: "You are not allowed to resolve this conversation",
        tc_resolve_problem_conversation: "An error occurred resolving the conversation. See the console for details.",
        tc_date_less_than_a_minute_ago: "a moment ago",
        tc_date_1_minute_ago: "1 minute ago",
        tc_date_x_minutes_ago: "{0} minutes ago",
        tc_date_1_hour_ago: "1 hour ago",
        tc_date_x_hours_ago: "{0} hours ago",
        tc_date_1_day_ago: "1 day ago",
        tc_date_x_days_ago: "{0} days ago",
        tc_date_1_week_ago: "1 week ago",
        tc_date_x_weeks_ago: "{0} weeks ago",
        tc_date_1_month_ago: "1 month ago",
        tc_date_x_months_ago: "{0} months ago",
        tc_date_1_year_ago: "1 year ago",
        tc_date_x_years_ago: "{0} years ago",
        tc_date_comment_edited: " (edited)",
        tc_comment_buttons_showmore: "SHOW MORE",
        tc_comment_buttons_showless: "SHOW LESS"
    }, f)
      , Fu = "tox-button--kebab"
      , Du = "tox-comment"
      , Hu = "tox-comment__body"
      , Iu = "tox-textarea"
      , Pu = "tox-comment__reply"
      , Vu = "tox-comment__overlay"
      , Wu = "tox-comment__overlaytext"
      , Lu = "tox-comment__buttonspacing"
      , Uu = "tox-button"
      , ju = "tox-comment__edit"
      , zu = "tox-comment__scroll"
      , $u = "tox-collection__item"
      , qu = "tox-conversations"
      , Gu = "tox-comment__expander"
      , Ku = `${Gu} p:contains(${Bu.tc_comment_buttons_showmore})`
      , Yu = `${Gu} p:contains(${Bu.tc_comment_buttons_showless})`
      , Qu = e=>`.${e}`
      , Ju = e=>t=>[`${Qu(Du)}:contains(${t})`, Qu(e)].join(" ")
      , Xu = {
        kebab: Qu(Fu),
        cardBody: `${Qu(Du)} ${Qu(Hu)}`,
        card: Qu(Du),
        showMore: Qu(Ku),
        showLess: Qu(Yu),
        editItem: [".tox-menu", `[role="menuitem"]:contains(${Bu.tc_kebab_edit})`].join(" "),
        deleteItem: [".tox-menu", `[role="menuitem"]:contains(${Bu.tc_kebab_delete})`].join(" "),
        deleteConversationItem: [".tox-menu", `[role="menuitem"]:contains(${Bu.tc_kebab_delete_conversation})`].join(" "),
        resolveConversationItem: [".tox-menu", `[role="menuitem"]:contains(${Bu.tc_kebab_resolve_conversation})`].join(" "),
        outerScroll: Qu(zu),
        outerContainer: Qu(qu),
        cardFor: e=>`${Qu(Du)}:contains("${e}")`,
        cardN: e=>`${Qu(Du)}:nth-child(${e + 1})`,
        kebabFor: Ju(Fu),
        showMoreFor: Ju(Ku),
        showLessFor: Ju(Yu),
        editSaveButton: `.tox-button:contains(${Bu.tc_edit_buttons_save})`,
        replyCommentButton: `.tox-button:contains(${Bu.tc_reply_buttons_comment})`,
        cancelButton: `.tox-button:contains(${Bu.tc_edit_buttons_cancel})`,
        clearButton: `.tox-button:contains(${Bu.tc_reply_buttons_clear})`,
        deleteButton: `.tox-button:contains(${Bu.tc_delete_buttons_proceed})`,
        resolveButton: `.tox-button:contains(${Bu.tc_resolve_buttons_proceed})`,
        commentText: [Qu(qu), Qu(zu), Qu(Du), "textarea"].join(" "),
        editActions: Qu(ju),
        cardOverlay: Qu(Vu),
        cardOverlayText: Qu(Wu),
        cardOverlayButtons: Qu(Lu),
        replyTextarea: `.${Pu} textarea`,
        editTextarea: [Qu(Du), "textarea"].join(" "),
        kebabMenu: Qu("tox-menu"),
        textarea: Qu(Iu)
    }
      , Zu = {
        kebabOpen: `${Fu}--open`,
        bodyExpanded: "tox-comment__body--expanded",
        bodyNotAnimating: "tox-comment__body--pending",
        disappearing: "tox-comment--disappearing",
        commentThreadOverlay: "tox-comment-thread__overlay",
        bodyHasGradient: "tox-comment__gradient",
        editingTextarea: Iu
    }
      , ed = {
        conversationsTitle: ["tox-conversations__title"],
        conversationsHead: ["tox-conversations__header"],
        showMoreLessContainer: [Gu],
        outerContainer: [qu],
        date: ["tox-comment__date"],
        replySection: [Pu],
        replyTextarea: [Iu],
        textarea: [],
        editTextarea: [],
        kebab: ["tox-button--naked", Fu, Uu, "tox-button--icon"],
        kebabIcon: ["tox-icon"],
        card: [Du],
        cardHead: ["tox-comment__header"],
        cardHeadMeta: ["tox-comment__meta"],
        cardBody: [Hu],
        cardOverlay: [Vu],
        cardOverlayText: [Wu],
        cardOverlayButtons: [Lu],
        button: [Uu],
        secondaryButton: [Uu, "tox-button--secondary"],
        editActions: [ju],
        outerScroll: [zu],
        commentList: ["tox-comment-thread"],
        avatar: ["tox-user__avatar"],
        username: ["tox-user__name"],
        user: ["tox-user"],
        showMoreLess: [],
        kebabItem: [$u],
        kebabItemLabel: ["tox-collection__item-label"],
        kebabDisabledItem: ["tox-collection__item--state-disabled"],
        kebabMenu: ["tox-menu", "tox-collection", "tox-collection--list"],
        kebabMenuGroup: ["tox-collection__group"],
        roots: [qu]
    }
      , td = {
        kebab: {
            backgroundMenu: "tox-menu--background",
            selectedMenu: "tox-menu--active",
            menu: "tox-menu",
            item: $u,
            selectedItem: "tox-collection__item--active"
        }
    }
      , nd = ["#2DC26B", "#F1C40F", "#E03E2D", "#B96AD9", "#3598DB", "#169179", "#E67E23", "#BA372A", "#843FA1", "#236FA1", "#95A5A6", "#7E8C8D", "#34495E"]
      , od = (e,t)=>E.from(t.authorAvatar).orThunk((()=>e.lookup(t.author))).getOrThunk((()=>{
        const n = ((e,t,n=36)=>{
            const o = n / 2;
            return `<svg height="${n}" width="${n}" xmlns="http://www.w3.org/2000/svg"><circle cx="${o}" cy="${o}" r="${o}" fill="${t}"/><text x="50%" y="50%" text-anchor="middle" dominant-baseline="central" fill="#FFF" font-family="sans-serif" font-size="${o}">` + (e=>(new Ru).splitGraphemes(e)[0])(e) + "</text></svg>"
        }
        )(t.authorName, (()=>{
            const e = Math.floor(Os() * nd.length);
            return nd[e]
        }
        )())
          , o = "data:image/svg+xml," + encodeURIComponent(n);
        return e.store(t.author, o),
        o
    }
    ));
    var rd = Object.freeze({
        __proto__: null,
        getCurrent: (e,t,n)=>t.find(e)
    });
    const sd = [Xt("find")]
      , ad = wr({
        fields: sd,
        name: "composing",
        apis: rd
    })
      , id = (e,t)=>{
        t.ignore || (kr(e.element),
        t.onFocus(e))
    }
    ;
    var cd = Object.freeze({
        __proto__: null,
        blur: (e,t)=>{
            t.ignore || (e=>{
                e.dom.blur()
            }
            )(e.element)
        }
        ,
        focus: id,
        isFocused: e=>(e=>{
            const t = Se(e).dom;
            return e.dom === t.activeElement
        }
        )(e.element)
    })
      , ld = Object.freeze({
        __proto__: null,
        events: e=>er([nr(No(), ((t,n)=>{
            id(t, e),
            n.stop()
        }
        ))].concat(e.stopMousedown ? [nr(xo(), ((e,t)=>{
            t.event.prevent()
        }
        ))] : [])),
        exhibit: (e,t)=>{
            const n = t.ignore ? {} : {
                attributes: {
                    tabindex: "-1"
                }
            };
            return vr(n)
        }
    })
      , ud = [za("onFocus"), an("stopMousedown", !1), an("ignore", !1)];
    const dd = wr({
        fields: ud,
        name: "focusing",
        active: ld,
        apis: cd
    })
      , md = (e,t,n)=>{
        t.store.manager.onLoad(e, t, n)
    }
      , gd = (e,t,n)=>{
        t.store.manager.onUnload(e, t, n)
    }
    ;
    var pd = Object.freeze({
        __proto__: null,
        getState: (e,t,n)=>n,
        getValue: (e,t,n)=>t.store.manager.getValue(e, t, n),
        onLoad: md,
        onUnload: gd,
        setValue: (e,t,n,o)=>{
            t.store.manager.setValue(e, t, n, o)
        }
    })
      , hd = Object.freeze({
        __proto__: null,
        events: (e,t)=>{
            const n = e.resetOnDom ? [ir(((n,o)=>{
                md(n, e, t)
            }
            )), cr(((n,o)=>{
                gd(n, e, t)
            }
            ))] : [fr(e, t, md)];
            return er(n)
        }
    });
    const vd = ()=>{
        const e = hn(null);
        return Tn({
            set: e.set,
            get: e.get,
            isNotSet: ()=>null === e.get(),
            clear: ()=>{
                e.set(null)
            }
            ,
            readState: ()=>({
                mode: "memory",
                value: e.get()
            })
        })
    }
      , fd = ()=>{
        const e = hn({})
          , t = hn({});
        return Tn({
            readState: ()=>({
                mode: "dataset",
                dataByValue: e.get(),
                dataByText: t.get()
            }),
            lookup: n=>je(e.get(), n).orThunk((()=>je(t.get(), n))),
            update: n=>{
                const o = e.get()
                  , r = t.get()
                  , s = {}
                  , a = {};
                z(n, (e=>{
                    s[e.value] = e,
                    je(e, "meta").each((t=>{
                        je(t, "text").each((t=>{
                            a[t] = e
                        }
                        ))
                    }
                    ))
                }
                )),
                e.set({
                    ...o,
                    ...s
                }),
                t.set({
                    ...r,
                    ...a
                })
            }
            ,
            clear: ()=>{
                e.set({}),
                t.set({})
            }
        })
    }
    ;
    var bd = Object.freeze({
        __proto__: null,
        dataset: fd,
        init: e=>e.store.manager.state(e),
        manual: ()=>Tn({
            readState: p
        }),
        memory: vd
    });
    const yd = (e,t,n,o)=>{
        const r = t.store;
        n.update([o]),
        r.setValue(e, o),
        t.onSetValue(e, o)
    }
    ;
    var _d = [nn("initialValue"), Xt("getFallbackEntry"), Xt("getDataKey"), Xt("setValue"), Ka("manager", {
        setValue: yd,
        getValue: (e,t,n)=>{
            const o = t.store
              , r = o.getDataKey(e);
            return n.lookup(r).getOrThunk((()=>o.getFallbackEntry(r)))
        }
        ,
        onLoad: (e,t,n)=>{
            t.store.initialValue.each((o=>{
                yd(e, t, n, o)
            }
            ))
        }
        ,
        onUnload: (e,t,n)=>{
            n.clear()
        }
        ,
        state: fd
    })]
      , xd = [Xt("getValue"), an("setValue", p), nn("initialValue"), Ka("manager", {
        setValue: (e,t,n,o)=>{
            t.store.setValue(e, o),
            t.onSetValue(e, o)
        }
        ,
        getValue: (e,t,n)=>t.store.getValue(e),
        onLoad: (e,t,n)=>{
            t.store.initialValue.each((n=>{
                t.store.setValue(e, n)
            }
            ))
        }
        ,
        onUnload: p,
        state: kn.init
    })]
      , wd = [nn("initialValue"), Ka("manager", {
        setValue: (e,t,n,o)=>{
            n.set(o),
            t.onSetValue(e, o)
        }
        ,
        getValue: (e,t,n)=>n.get(),
        onLoad: (e,t,n)=>{
            t.store.initialValue.each((e=>{
                n.isNotSet() && n.set(e)
            }
            ))
        }
        ,
        onUnload: (e,t,n)=>{
            n.clear()
        }
        ,
        state: vd
    })]
      , Od = [cn("store", {
        mode: "memory"
    }, Yt("mode", {
        memory: wd,
        manual: xd,
        dataset: _d
    })), za("onSetValue"), an("resetOnDom", !1)];
    const Sd = wr({
        fields: Od,
        name: "representing",
        active: hd,
        apis: pd,
        extra: {
            setValueFrom: (e,t)=>{
                const n = Sd.getValue(t);
                Sd.setValue(e, n)
            }
        },
        state: bd
    });
    var Cd = Object.freeze({
        __proto__: null,
        exhibit: (e,t)=>vr({
            attributes: Rn([{
                key: t.tabAttr,
                value: "true"
            }])
        })
    })
      , Ed = [an("tabAttr", "data-alloy-tabstop")];
    const kd = wr({
        fields: Ed,
        name: "tabstopping",
        active: Cd
    })
      , Td = (e,t,n,o)=>je(t.routes, o.start).bind((e=>je(e, o.destination)))
      , Md = (e,t,n,o)=>Td(0, t, 0, o).bind((e=>e.transition.map((t=>({
        transition: t,
        route: e
    })))))
      , Ad = (e,t,n)=>{
        ((e,t,n)=>Rd(e, t).bind((e=>Md(0, t, 0, e))))(e, t).each((n=>{
            const o = n.transition;
            oa(e.element, o.transitionClass),
            Lr(e.element, t.destinationAttr)
        }
        ))
    }
      , Rd = (e,t,n)=>{
        const o = e.element;
        return Vr(o, t.destinationAttr).map((n=>({
            start: Pr(e.element, t.stateAttr),
            destination: n
        })))
    }
      , Nd = (e,t,n,o)=>{
        Ad(e, t),
        Wr(e.element, t.stateAttr) && Pr(e.element, t.stateAttr) !== o && t.onFinish(e, o),
        Hr(e.element, t.stateAttr, o)
    }
    ;
    var Bd = Object.freeze({
        __proto__: null,
        disableTransition: Ad,
        findRoute: Td,
        getCurrentRoute: Rd,
        getState: (e,t,n)=>Vr(e.element, t.stateAttr),
        jumpTo: Nd,
        progressTo: (e,t,n,o)=>{
            ((e,t,n,o)=>{
                Wr(e.element, t.destinationAttr) && (Vr(e.element, t.destinationAttr).each((n=>{
                    Hr(e.element, t.stateAttr, n)
                }
                )),
                Lr(e.element, t.destinationAttr))
            }
            )(e, t);
            const r = ((e,t,n,o)=>({
                start: Pr(e.element, t.stateAttr),
                destination: o
            }))(e, t, 0, o);
            Md(0, t, 0, r).fold((()=>{
                Nd(e, t, 0, o)
            }
            ), (n=>{
                Ad(e, t);
                const r = n.transition;
                na(e.element, r.transitionClass),
                Hr(e.element, t.destinationAttr, o)
            }
            ))
        }
    })
      , Fd = Object.freeze({
        __proto__: null,
        events: (e,t)=>er([nr(To(), ((t,n)=>{
            const o = n.event.raw;
            Rd(t, e).each((n=>{
                Td(0, e, 0, n).each((r=>{
                    r.transition.each((r=>{
                        o.propertyName === r.property && (Nd(t, e, 0, n.destination),
                        e.onTransition(t, n))
                    }
                    ))
                }
                ))
            }
            ))
        }
        )), ir(((t,n)=>{
            Nd(t, e, 0, e.initialState)
        }
        ))])
    })
      , Dd = [an("destinationAttr", "data-transitioning-destination"), an("stateAttr", "data-transitioning-state"), Xt("initialState"), za("onTransition"), za("onFinish"), Zt("routes", zt(nt.value, zt(nt.value, Bt([sn("transition", [Xt("property"), Xt("transitionClass")])]))))];
    const Hd = wr({
        fields: Dd,
        name: "transitioning",
        active: Fd,
        apis: Bd,
        extra: {
            createRoutes: e=>{
                const t = {};
                return De(e, ((e,n)=>{
                    const o = n.split("<->");
                    t[o[0]] = An(o[1], e),
                    t[o[1]] = An(o[0], e)
                }
                )),
                t
            }
            ,
            createBistate: (e,t,n)=>Rn([{
                key: e,
                value: An(t, n)
            }, {
                key: t,
                value: An(e, n)
            }]),
            createTristate: (e,t,n,o)=>Rn([{
                key: e,
                value: Rn([{
                    key: t,
                    value: o
                }, {
                    key: n,
                    value: o
                }])
            }, {
                key: t,
                value: Rn([{
                    key: e,
                    value: o
                }, {
                    key: n,
                    value: o
                }])
            }, {
                key: n,
                value: Rn([{
                    key: e,
                    value: o
                }, {
                    key: t,
                    value: o
                }])
            }])
        }
    })
      , Id = (e,t,n,o)=>{
        const r = n.get();
        n.set(o),
        ((e,t,n)=>{
            t.toggleClass.each((t=>{
                n.get() ? na(e.element, t) : oa(e.element, t)
            }
            ))
        }
        )(e, t, n),
        ((e,t,n)=>{
            const o = t.aria;
            o.update(e, o, n.get())
        }
        )(e, t, n),
        r !== o && t.onToggled(e, o)
    }
      , Pd = (e,t,n)=>{
        Id(e, t, n, !n.get())
    }
      , Vd = (e,t,n)=>{
        Id(e, t, n, t.selected)
    }
    ;
    var Wd = Object.freeze({
        __proto__: null,
        isOn: (e,t,n)=>n.get(),
        off: (e,t,n)=>{
            Id(e, t, n, !1)
        }
        ,
        on: (e,t,n)=>{
            Id(e, t, n, !0)
        }
        ,
        onLoad: Vd,
        set: Id,
        toggle: Pd
    })
      , Ld = Object.freeze({
        __proto__: null,
        events: (e,t)=>{
            const n = (o = e,
            r = t,
            s = Pd,
            ur((e=>{
                s(e, o, r)
            }
            )));
            var o, r, s;
            const a = fr(e, t, Vd);
            return er(Q([e.toggleOnExecute ? [n] : [], [a]]))
        }
        ,
        exhibit: ()=>vr({})
    });
    const Ud = (e,t,n)=>{
        Hr(e.element, "aria-expanded", n)
    }
    ;
    var jd = [an("selected", !1), nn("toggleClass"), an("toggleOnExecute", !0), za("onToggled"), cn("aria", {
        mode: "none"
    }, Yt("mode", {
        pressed: [an("syncWithExpanded", !1), Ka("update", ((e,t,n)=>{
            Hr(e.element, "aria-pressed", n),
            t.syncWithExpanded && Ud(e, 0, n)
        }
        ))],
        checked: [Ka("update", ((e,t,n)=>{
            Hr(e.element, "aria-checked", n)
        }
        ))],
        expanded: [Ka("update", Ud)],
        selected: [Ka("update", ((e,t,n)=>{
            Hr(e.element, "aria-selected", n)
        }
        ))],
        none: [Ka("update", p)]
    }))];
    const zd = wr({
        fields: jd,
        name: "toggling",
        active: Ld,
        apis: Wd,
        state: (!1,
        {
            init: ()=>{
                const e = hn(false);
                return {
                    get: ()=>e.get(),
                    set: t=>e.set(t),
                    clear: ()=>e.set(false),
                    readState: ()=>e.get()
                }
            }
        })
    });
    const $d = ()=>{
        const e = (e,t)=>{
            t.stop(),
            Jo(e)
        }
        ;
        return [nr(Eo(), e), nr(Po(), e), rr(bo()), rr(xo())]
    }
      , qd = e=>er(Q([e.map((e=>ur(((t,n)=>{
        e(t),
        n.stop()
    }
    )))).toArray(), $d()]))
      , Gd = (e,t,n)=>{
        const o = Z(e.slice(0, t))
          , r = Z(e.slice(t + 1));
        return K(o.concat(r), n)
    }
      , Kd = (e,t,n)=>{
        const o = Z(e.slice(0, t));
        return K(o, n)
    }
      , Yd = (e,t,n)=>{
        const o = e.slice(0, t)
          , r = e.slice(t + 1);
        return K(r.concat(o), n)
    }
      , Qd = (e,t,n)=>{
        const o = e.slice(t + 1);
        return K(o, n)
    }
      , Jd = e=>t=>{
        const n = t.raw;
        return L(e, n.which)
    }
      , Xd = e=>t=>X(e, (e=>e(t)))
      , Zd = e=>!0 === e.raw.shiftKey
      , em = e=>!0 === e.raw.ctrlKey
      , tm = (e=>t=>!e(t))(Zd)
      , nm = (e,t)=>({
        matches: e,
        classification: t
    })
      , om = (e,t,n,o)=>{
        const r = ct(e.element, "." + t.highlightClass);
        z(r, (n=>{
            U(o, (e=>ce(e.element, n))) || (oa(n, t.highlightClass),
            e.getSystem().getByDom(n).each((n=>{
                t.onDehighlight(e, n),
                Yo(n, Ko())
            }
            )))
        }
        ))
    }
      , rm = (e,t,n,o)=>{
        om(e, t, 0, [o]),
        sm(e, t, n, o) || (na(o.element, t.highlightClass),
        t.onHighlight(e, o),
        Yo(o, Go()))
    }
      , sm = (e,t,n,o)=>ra(o.element, t.highlightClass)
      , am = (e,t,n)=>os(e.element, "." + t.itemClass).bind((t=>e.getSystem().getByDom(t).toOptional()))
      , im = (e,t,n)=>{
        const o = ct(e.element, "." + t.itemClass);
        return (o.length > 0 ? E.some(o[o.length - 1]) : E.none()).bind((t=>e.getSystem().getByDom(t).toOptional()))
    }
      , cm = (e,t,n,o)=>{
        const r = ct(e.element, "." + t.itemClass);
        return Y(r, (e=>ra(e, t.highlightClass))).bind((t=>{
            const n = xs(t, o, 0, r.length - 1);
            return e.getSystem().getByDom(r[n]).toOptional()
        }
        ))
    }
      , lm = (e,t,n)=>{
        const o = ct(e.element, "." + t.itemClass);
        return mr(j(o, (t=>e.getSystem().getByDom(t).toOptional())))
    }
    ;
    var um = Object.freeze({
        __proto__: null,
        dehighlight: (e,t,n,o)=>{
            sm(e, t, n, o) && (oa(o.element, t.highlightClass),
            t.onDehighlight(e, o),
            Yo(o, Ko()))
        }
        ,
        dehighlightAll: (e,t,n)=>om(e, t, 0, []),
        getCandidates: lm,
        getFirst: am,
        getHighlighted: (e,t,n)=>os(e.element, "." + t.highlightClass).bind((t=>e.getSystem().getByDom(t).toOptional())),
        getLast: im,
        getNext: (e,t,n)=>cm(e, t, 0, 1),
        getPrevious: (e,t,n)=>cm(e, t, 0, -1),
        highlight: rm,
        highlightAt: (e,t,n,o)=>{
            ((e,t,n,o)=>{
                const r = ct(e.element, "." + t.itemClass);
                return E.from(r[o]).fold((()=>nt.error(new Error("No element found with index " + o))), e.getSystem().getByDom)
            }
            )(e, t, 0, o).fold((e=>{
                throw e
            }
            ), (o=>{
                rm(e, t, n, o)
            }
            ))
        }
        ,
        highlightBy: (e,t,n,o)=>{
            const r = lm(e, t);
            K(r, o).each((o=>{
                rm(e, t, n, o)
            }
            ))
        }
        ,
        highlightFirst: (e,t,n)=>{
            am(e, t).each((o=>{
                rm(e, t, n, o)
            }
            ))
        }
        ,
        highlightLast: (e,t,n)=>{
            im(e, t).each((o=>{
                rm(e, t, n, o)
            }
            ))
        }
        ,
        isHighlighted: sm
    })
      , dm = [Xt("highlightClass"), Xt("itemClass"), za("onHighlight"), za("onDehighlight")];
    const mm = wr({
        fields: dm,
        name: "highlighting",
        apis: um
    })
      , gm = (e,t,n)=>{
        t.exists((e=>n.exists((t=>ce(t, e))))) || Qo(e, qo(), {
            prevFocus: t,
            newFocus: n
        })
    }
      , pm = ()=>{
        const e = e=>Mr(e.element);
        return {
            get: e,
            set: (t,n)=>{
                const o = e(t);
                t.getSystem().triggerFocus(n, t.element);
                const r = e(t);
                gm(t, o, r)
            }
        }
    }
      , hm = ()=>{
        const e = e=>mm.getHighlighted(e).map((e=>e.element));
        return {
            get: e,
            set: (t,n)=>{
                const o = e(t);
                t.getSystem().getByDom(n).fold(p, (e=>{
                    mm.highlight(t, e)
                }
                ));
                const r = e(t);
                gm(t, o, r)
            }
        }
    }
    ;
    var vm;
    !function(e) {
        e.OnFocusMode = "onFocus",
        e.OnEnterOrSpaceMode = "onEnterOrSpace",
        e.OnApiMode = "onApi"
    }(vm || (vm = {}));
    const fm = (e,t,n,o,r)=>{
        const s = (e,t,n,o,r)=>((e,t)=>{
            const n = K(e, (e=>e.matches(t)));
            return n.map((e=>e.classification))
        }
        )(n(e, t, o, r), t.event).bind((n=>n(e, t, o, r)))
          , a = {
            schema: ()=>e.concat([an("focusManager", pm()), cn("focusInside", "onFocus", jt((e=>L(["onFocus", "onEnterOrSpace", "onApi"], e) ? nt.value(e) : nt.error("Invalid value for focusInside")))), Ka("handler", a), Ka("state", t), Ka("sendFocusIn", r)]),
            processKey: s,
            toEvents: (e,t)=>{
                const a = e.focusInside !== vm.OnFocusMode ? E.none() : r(e).map((n=>nr(No(), ((o,r)=>{
                    n(o, e, t),
                    r.stop()
                }
                ))))
                  , i = [nr(Oo(), ((o,a)=>{
                    s(o, a, n, e, t).fold((()=>{
                        ((n,o)=>{
                            const s = Jd(ls.concat(is))(o.event);
                            e.focusInside === vm.OnEnterOrSpaceMode && s && Bn(n, o) && r(e).each((r=>{
                                r(n, e, t),
                                o.stop()
                            }
                            ))
                        }
                        )(o, a)
                    }
                    ), (e=>{
                        a.stop()
                    }
                    ))
                }
                )), nr(So(), ((n,r)=>{
                    s(n, r, o, e, t).each((e=>{
                        r.stop()
                    }
                    ))
                }
                ))];
                return er(a.toArray().concat(i))
            }
        };
        return a
    }
      , bm = e=>{
        const t = [nn("onEscape"), nn("onEnter"), an("selector", '[data-alloy-tabstop="true"]:not(:disabled)'), an("firstTabstop", 0), an("useTabstopAt", O), nn("visibilitySelector")].concat([e])
          , n = (e,t)=>{
            const n = e.visibilitySelector.bind((e=>rs(t, e))).getOr(t);
            return nc(n) > 0
        }
          , o = (e,t)=>t.focusManager.get(e).bind((e=>rs(e, t.selector)))
          , r = (e,t,o)=>{
            ((e,t)=>{
                const o = ct(e.element, t.selector)
                  , r = $(o, (e=>n(t, e)));
                return E.from(r[t.firstTabstop])
            }
            )(e, t).each((n=>{
                t.focusManager.set(e, n)
            }
            ))
        }
          , s = (e,t,r,s)=>{
            const a = ct(e.element, r.selector);
            return o(e, r).bind((t=>Y(a, y(ce, t)).bind((t=>((e,t,o,r,s)=>s(t, o, (e=>((e,t)=>n(e, t) && e.useTabstopAt(t))(r, e))).fold((()=>r.cyclic ? E.some(!0) : E.none()), (t=>(r.focusManager.set(e, t),
            E.some(!0)))))(e, a, t, r, s)))))
        }
          , a = (e,t,n)=>{
            const o = n.cyclic ? Gd : Kd;
            return s(e, 0, n, o)
        }
          , i = (e,t,n)=>{
            const o = n.cyclic ? Yd : Qd;
            return s(e, 0, n, o)
        }
          , c = v([nm(Xd([Zd, Jd(as)]), a), nm(Jd(as), i), nm(Xd([tm, Jd(is)]), ((e,t,n)=>n.onEnter.bind((n=>n(e, t)))))])
          , l = v([nm(Jd(cs), ((e,t,n)=>n.onEscape.bind((n=>n(e, t))))), nm(Jd(as), ((e,t,n)=>o(e, n).filter((e=>!n.useTabstopAt(e))).bind((o=>((e=>(e=>be(e))(e).bind(we).exists((t=>ce(t, e))))(o) ? a : i)(e, t, n)))))]);
        return fm(t, kn.init, c, l, (()=>E.some(r)))
    }
    ;
    var ym = bm(Jt("cyclic", w))
      , _m = bm(Jt("cyclic", O));
    const xm = e=>he("input")(e) && "radio" !== Pr(e, "type") || he("textarea")(e)
      , wm = (e,t,n)=>xm(n) && Jd(ls)(t.event) ? E.none() : ((e,t,n)=>(Xo(e, n, Ho()),
    E.some(!0)))(e, 0, n)
      , Om = (e,t)=>E.some(!0)
      , Sm = [an("execute", wm), an("useSpace", !1), an("useEnter", !0), an("useControlEnter", !1), an("useDown", !1)]
      , Cm = (e,t,n)=>n.execute(e, t, e.element);
    var Em = fm(Sm, kn.init, ((e,t,n,o)=>{
        const r = n.useSpace && !xm(e.element) ? ls : []
          , s = n.useEnter ? is : []
          , a = n.useDown ? gs : []
          , i = r.concat(s).concat(a);
        return [nm(Jd(i), Cm)].concat(n.useControlEnter ? [nm(Xd([em, Jd(is)]), Cm)] : [])
    }
    ), ((e,t,n,o)=>n.useSpace && !xm(e.element) ? [nm(Jd(ls), Om)] : []), (()=>E.none()));
    const km = ()=>{
        const e = Xr();
        return Tn({
            readState: ()=>e.get().map((e=>({
                numRows: String(e.numRows),
                numColumns: String(e.numColumns)
            }))).getOr({
                numRows: "?",
                numColumns: "?"
            }),
            setGridSize: (t,n)=>{
                e.set({
                    numRows: t,
                    numColumns: n
                })
            }
            ,
            getNumRows: ()=>e.get().map((e=>e.numRows)),
            getNumColumns: ()=>e.get().map((e=>e.numColumns))
        })
    }
    ;
    var Tm = Object.freeze({
        __proto__: null,
        flatgrid: km,
        init: e=>e.state(e)
    });
    const Mm = e=>(t,n,o,r)=>{
        const s = e(t.element);
        return Bm(s, t, n, o, r)
    }
      , Am = (e,t)=>{
        const n = gl(e, t);
        return Mm(n)
    }
      , Rm = (e,t)=>{
        const n = gl(t, e);
        return Mm(n)
    }
      , Nm = e=>(t,n,o,r)=>Bm(e, t, n, o, r)
      , Bm = (e,t,n,o,r)=>o.focusManager.get(t).bind((n=>e(t.element, n, o, r))).map((e=>(o.focusManager.set(t, e),
    !0)))
      , Fm = Nm
      , Dm = Nm
      , Hm = Nm
      , Im = (e,t,n)=>{
        const o = ct(e, n);
        return ((e,n)=>Y(e, (e=>ce(e, t))).map((t=>({
            index: t,
            candidates: e
        }))))($(o, ku))
    }
      , Pm = (e,t)=>Y(e, (e=>ce(t, e)))
      , Vm = (e,t,n,o)=>o(Math.floor(t / n), t % n).bind((t=>{
        const o = t.row * n + t.column;
        return o >= 0 && o < e.length ? E.some(e[o]) : E.none()
    }
    ))
      , Wm = (e,t,n,o,r)=>Vm(e, t, o, ((t,s)=>{
        const a = t === n - 1 ? e.length - t * o : o
          , i = xs(s, r, 0, a - 1);
        return E.some({
            row: t,
            column: i
        })
    }
    ))
      , Lm = (e,t,n,o,r)=>Vm(e, t, o, ((t,s)=>{
        const a = xs(t, r, 0, n - 1)
          , i = a === n - 1 ? e.length - a * o : o
          , c = ws(s, 0, i - 1);
        return E.some({
            row: a,
            column: c
        })
    }
    ))
      , Um = [Xt("selector"), an("execute", wm), $a("onEscape"), an("captureTab", !1), Qa()]
      , jm = (e,t,n)=>{
        os(e.element, t.selector).each((n=>{
            t.focusManager.set(e, n)
        }
        ))
    }
      , zm = e=>(t,n,o,r)=>Im(t, n, o.selector).bind((t=>e(t.candidates, t.index, r.getNumRows().getOr(o.initSize.numRows), r.getNumColumns().getOr(o.initSize.numColumns))))
      , $m = (e,t,n)=>n.captureTab ? E.some(!0) : E.none()
      , qm = zm(((e,t,n,o)=>Wm(e, t, n, o, -1)))
      , Gm = zm(((e,t,n,o)=>Wm(e, t, n, o, 1)))
      , Km = zm(((e,t,n,o)=>Lm(e, t, n, o, -1)))
      , Ym = zm(((e,t,n,o)=>Lm(e, t, n, o, 1)))
      , Qm = v([nm(Jd(us), Am(qm, Gm)), nm(Jd(ms), Rm(qm, Gm)), nm(Jd(ds), Fm(Km)), nm(Jd(gs), Dm(Ym)), nm(Xd([Zd, Jd(as)]), $m), nm(Xd([tm, Jd(as)]), $m), nm(Jd(ls.concat(is)), ((e,t,n,o)=>((e,t)=>t.focusManager.get(e).bind((e=>rs(e, t.selector))))(e, n).bind((o=>n.execute(e, t, o)))))])
      , Jm = v([nm(Jd(cs), ((e,t,n)=>n.onEscape(e, t))), nm(Jd(ls), Om)]);
    var Xm = fm(Um, km, Qm, Jm, (()=>E.some(jm)));
    const Zm = (e,t,n,o,r)=>{
        const s = (e,t,n)=>r(e, t, o, 0, n.length - 1, n[t], (t=>{
            return o = n[t],
            "button" === le(o) && "disabled" === Pr(o, "disabled") ? s(e, t, n) : E.from(n[t]);
            var o
        }
        ));
        return Im(e, n, t).bind((e=>{
            const t = e.index
              , n = e.candidates;
            return s(t, t, n)
        }
        ))
    }
      , eg = (e,t,n,o)=>Zm(e, t, n, o, ((e,t,n,o,r,s,a)=>{
        const i = ws(t + n, o, r);
        return i === e ? E.from(s) : a(i)
    }
    ))
      , tg = (e,t,n,o)=>Zm(e, t, n, o, ((e,t,n,o,r,s,a)=>{
        const i = xs(t, n, o, r);
        return i === e ? E.none() : a(i)
    }
    ))
      , ng = [Xt("selector"), an("getInitial", E.none), an("execute", wm), $a("onEscape"), an("executeOnMove", !1), an("allowVertical", !0), an("allowHorizontal", !0), an("cycles", !0)]
      , og = (e,t,n)=>((e,t)=>t.focusManager.get(e).bind((e=>rs(e, t.selector))))(e, n).bind((o=>n.execute(e, t, o)))
      , rg = (e,t,n)=>{
        t.getInitial(e).orThunk((()=>os(e.element, t.selector))).each((n=>{
            t.focusManager.set(e, n)
        }
        ))
    }
      , sg = (e,t,n)=>(n.cycles ? tg : eg)(e, n.selector, t, -1)
      , ag = (e,t,n)=>(n.cycles ? tg : eg)(e, n.selector, t, 1)
      , ig = e=>(t,n,o,r)=>e(t, n, o, r).bind((()=>o.executeOnMove ? og(t, n, o) : E.some(!0)))
      , cg = v([nm(Jd(ls), Om), nm(Jd(cs), ((e,t,n)=>n.onEscape(e, t)))]);
    var lg = fm(ng, kn.init, ((e,t,n,o)=>{
        const r = [...n.allowHorizontal ? us : []].concat(n.allowVertical ? ds : [])
          , s = [...n.allowHorizontal ? ms : []].concat(n.allowVertical ? gs : []);
        return [nm(Jd(r), ig(Am(sg, ag))), nm(Jd(s), ig(Rm(sg, ag))), nm(Jd(is), og), nm(Jd(ls), og)]
    }
    ), cg, (()=>E.some(rg)));
    const ug = (e,t,n)=>E.from(e[t]).bind((e=>E.from(e[n]).map((e=>({
        rowIndex: t,
        columnIndex: n,
        cell: e
    })))))
      , dg = (e,t,n,o)=>{
        const r = e[t].length
          , s = xs(n, o, 0, r - 1);
        return ug(e, t, s)
    }
      , mg = (e,t,n,o)=>{
        const r = xs(n, o, 0, e.length - 1)
          , s = e[r].length
          , a = ws(t, 0, s - 1);
        return ug(e, r, a)
    }
      , gg = (e,t,n,o)=>{
        const r = e[t].length
          , s = ws(n + o, 0, r - 1);
        return ug(e, t, s)
    }
      , pg = (e,t,n,o)=>{
        const r = ws(n + o, 0, e.length - 1)
          , s = e[r].length
          , a = ws(t, 0, s - 1);
        return ug(e, r, a)
    }
      , hg = [tn("selectors", [Xt("row"), Xt("cell")]), an("cycles", !0), an("previousSelector", E.none), an("execute", wm)]
      , vg = (e,t,n)=>{
        const o = t.previousSelector(e).orThunk((()=>{
            const n = t.selectors;
            return os(e.element, n.cell)
        }
        ));
        o.each((n=>{
            t.focusManager.set(e, n)
        }
        ))
    }
      , fg = (e,t)=>(n,o,r)=>{
        const s = r.cycles ? e : t;
        return rs(o, r.selectors.row).bind((e=>{
            const t = ct(e, r.selectors.cell);
            return Pm(t, o).bind((t=>{
                const o = ct(n, r.selectors.row);
                return Pm(o, e).bind((e=>{
                    const n = ((e,t)=>j(e, (e=>ct(e, t.selectors.cell))))(o, r);
                    return s(n, e, t).map((e=>e.cell))
                }
                ))
            }
            ))
        }
        ))
    }
      , bg = fg(((e,t,n)=>dg(e, t, n, -1)), ((e,t,n)=>gg(e, t, n, -1)))
      , yg = fg(((e,t,n)=>dg(e, t, n, 1)), ((e,t,n)=>gg(e, t, n, 1)))
      , _g = fg(((e,t,n)=>mg(e, n, t, -1)), ((e,t,n)=>pg(e, n, t, -1)))
      , xg = fg(((e,t,n)=>mg(e, n, t, 1)), ((e,t,n)=>pg(e, n, t, 1)))
      , wg = v([nm(Jd(us), Am(bg, yg)), nm(Jd(ms), Rm(bg, yg)), nm(Jd(ds), Fm(_g)), nm(Jd(gs), Dm(xg)), nm(Jd(ls.concat(is)), ((e,t,n)=>Mr(e.element).bind((o=>n.execute(e, t, o)))))])
      , Og = v([nm(Jd(ls), Om)]);
    var Sg = fm(hg, kn.init, wg, Og, (()=>E.some(vg)));
    const Cg = [Xt("selector"), an("execute", wm), an("moveOnTab", !1)]
      , Eg = (e,t,n)=>n.focusManager.get(e).bind((o=>n.execute(e, t, o)))
      , kg = (e,t,n)=>{
        os(e.element, t.selector).each((n=>{
            t.focusManager.set(e, n)
        }
        ))
    }
      , Tg = (e,t,n)=>tg(e, n.selector, t, -1)
      , Mg = (e,t,n)=>tg(e, n.selector, t, 1)
      , Ag = v([nm(Jd(ds), Hm(Tg)), nm(Jd(gs), Hm(Mg)), nm(Xd([Zd, Jd(as)]), ((e,t,n,o)=>n.moveOnTab ? Hm(Tg)(e, t, n, o) : E.none())), nm(Xd([tm, Jd(as)]), ((e,t,n,o)=>n.moveOnTab ? Hm(Mg)(e, t, n, o) : E.none())), nm(Jd(is), Eg), nm(Jd(ls), Eg)])
      , Rg = v([nm(Jd(ls), Om)]);
    var Ng = fm(Cg, kn.init, Ag, Rg, (()=>E.some(kg)));
    const Bg = [$a("onSpace"), $a("onEnter"), $a("onShiftEnter"), $a("onLeft"), $a("onRight"), $a("onTab"), $a("onShiftTab"), $a("onUp"), $a("onDown"), $a("onEscape"), an("stopSpaceKeyup", !1), nn("focusIn")];
    var Fg = fm(Bg, kn.init, ((e,t,n)=>[nm(Jd(ls), n.onSpace), nm(Xd([tm, Jd(is)]), n.onEnter), nm(Xd([Zd, Jd(is)]), n.onShiftEnter), nm(Xd([Zd, Jd(as)]), n.onShiftTab), nm(Xd([tm, Jd(as)]), n.onTab), nm(Jd(ds), n.onUp), nm(Jd(gs), n.onDown), nm(Jd(us), n.onLeft), nm(Jd(ms), n.onRight), nm(Jd(ls), n.onSpace)]), ((e,t,n)=>[...n.stopSpaceKeyup ? [nm(Jd(ls), Om)] : [], nm(Jd(cs), n.onEscape)]), (e=>e.focusIn));
    const Dg = ym.schema()
      , Hg = _m.schema()
      , Ig = lg.schema()
      , Pg = Xm.schema()
      , Vg = Sg.schema()
      , Wg = Em.schema()
      , Lg = Ng.schema()
      , Ug = Fg.schema()
      , jg = (e=>{
        const t = Gt("Creating behaviour: " + e.name, Or, e);
        return ((e,t,n,o,r,s)=>{
            const a = e
              , i = rn(t, [on("config", e)]);
            return yr(a, i, t, n, o, r, s)
        }
        )(Yt(t.branchKey, t.branches), t.name, t.active, t.apis, t.extra, t.state)
    }
    )({
        branchKey: "mode",
        branches: Object.freeze({
            __proto__: null,
            acyclic: Dg,
            cyclic: Hg,
            execution: Wg,
            flatgrid: Pg,
            flow: Ig,
            matrix: Vg,
            menu: Lg,
            special: Ug
        }),
        name: "keying",
        active: {
            events: (e,t)=>e.handler.toEvents(e, t)
        },
        apis: {
            focusIn: (e,t,n)=>{
                t.sendFocusIn(t).fold((()=>{
                    e.getSystem().triggerFocus(e.element, e.element)
                }
                ), (o=>{
                    o(e, t, n)
                }
                ))
            }
            ,
            setGridSize: (e,t,n,o,r)=>{
                (e=>$e(e, "setGridSize"))(n) ? n.setGridSize(o, r) : console.error("Layout does not support setGridSize")
            }
        },
        state: Tm
    })
      , zg = Ni({
        name: "Button",
        factory: e=>{
            const t = qd(e.action)
              , n = e.dom.tag
              , o = t=>je(e.dom, "attributes").bind((e=>je(e, t)));
            return {
                uid: e.uid,
                dom: e.dom,
                components: e.components,
                events: t,
                behaviours: Ha(e.buttonBehaviours, [dd.config({}), jg.config({
                    mode: "execution",
                    useSpace: !0,
                    useEnter: !0
                })]),
                domModification: {
                    attributes: "button" === n ? {
                        type: o("type").getOr("button"),
                        ...o("role").map((e=>({
                            role: e
                        }))).getOr({})
                    } : {
                        role: e.role.getOr(o("role").getOr("button"))
                    }
                },
                eventOrder: e.eventOrder
            }
        }
        ,
        configFields: [an("uid", void 0), Xt("dom"), an("components", []), Da("buttonBehaviours", [dd, jg]), nn("action"), nn("role"), an("eventOrder", {})]
    })
      , $g = ["input", "button", "textarea", "select"]
      , qg = (e,t,n)=>{
        (t.disabled() ? Xg : Zg)(e, t)
    }
      , Gg = (e,t)=>!0 === t.useNative && L($g, le(e.element))
      , Kg = e=>{
        Hr(e.element, "disabled", "disabled")
    }
      , Yg = e=>{
        Lr(e.element, "disabled")
    }
      , Qg = e=>{
        Hr(e.element, "aria-disabled", "true")
    }
      , Jg = e=>{
        Hr(e.element, "aria-disabled", "false")
    }
      , Xg = (e,t,n)=>{
        t.disableClass.each((t=>{
            na(e.element, t)
        }
        )),
        (Gg(e, t) ? Kg : Qg)(e),
        t.onDisabled(e)
    }
      , Zg = (e,t,n)=>{
        t.disableClass.each((t=>{
            oa(e.element, t)
        }
        )),
        (Gg(e, t) ? Yg : Jg)(e),
        t.onEnabled(e)
    }
      , ep = (e,t)=>Gg(e, t) ? (e=>Wr(e.element, "disabled"))(e) : (e=>"true" === Pr(e.element, "aria-disabled"))(e);
    var tp = Object.freeze({
        __proto__: null,
        disable: Xg,
        enable: Zg,
        isDisabled: ep,
        onLoad: qg,
        set: (e,t,n,o)=>{
            (o ? Xg : Zg)(e, t)
        }
    })
      , np = Object.freeze({
        __proto__: null,
        events: (e,t)=>er([tr(Ho(), ((t,n)=>ep(t, e))), fr(e, t, qg)]),
        exhibit: (e,t)=>vr({
            classes: t.disabled() ? t.disableClass.toArray() : []
        })
    })
      , op = [((e,t)=>cn("disabled", t, Lt))(0, w), an("useNative", !0), nn("disableClass"), za("onDisabled"), za("onEnabled")];
    const rp = wr({
        fields: op,
        name: "disabling",
        active: np,
        apis: tp
    });
    var sp = Object.freeze({
        __proto__: null,
        events: e=>er([nr(Do(), ((t,n)=>{
            const o = e.channels
              , r = Be(o)
              , s = n
              , a = ((e,t)=>t.universal ? e : $(e, (e=>L(t.channels, e))))(r, s);
            z(a, (e=>{
                const n = o[e]
                  , r = n.schema
                  , a = Gt("channel[" + e + "] data\nReceiver: " + jr(t.element), r, s.data);
                n.onReceive(t, a)
            }
            ))
        }
        ))])
    })
      , ap = [Zt("channels", zt(nt.value, Bt([qa("onReceive"), an("schema", It())])))];
    const ip = wr({
        fields: ap,
        name: "receiving",
        active: sp
    })
      , cp = e=>{
        var t;
        return rp.config(null !== (t = e.disablingConfig) && void 0 !== t ? t : {})
    }
      , lp = e=>({
        [Cn]: {
            schema: ln,
            onReceive: (t,n)=>{
                rp.set(t, e(n))
            }
        }
    })
      , up = e=>{
        var t;
        const n = null !== (t = e.disableWhileSaving) && void 0 !== t && t;
        return [cp(e), (o = n ? dn : un,
        ip.config({
            channels: lp(o)
        }))];
        var o
    }
      , dp = e=>t=>{
        var n;
        const o = null !== (n = t.disableWhileSaving) && void 0 !== n && n
          , r = t.eventName.map((e=>({
            action: t=>{
                Yo(t, e)
            }
        }))).getOr({});
        return zg.sketch({
            dom: {
                tag: "button",
                classes: e,
                styles: void 0 !== t.styles ? t.styles : {}
            },
            components: [ka(t.text)],
            ...r,
            buttonBehaviours: _r([kd.config({}), ...up({
                disableWhileSaving: o
            })])
        })
    }
      , mp = dp(ed.button)
      , gp = dp(ed.secondaryButton)
      , pp = "tc-save-edit"
      , hp = "tc-cancel-edit"
      , vp = Cs("tc-patch-comment-state-event")
      , fp = Cs("tc-purge-comment-state-event")
      , bp = Cs("tc-force-patch-state-event");
    var yp, _p;
    !function(e) {
        e.None = "Prop_None",
        e.Collapsed = "Prop_Collapsed",
        e.Expanded = "Prop_Expanded",
        e.CollapsedOrNone = "Prop_CollapsedOrNone",
        e.ExpandOrNone = "Prop_ExpandOrNone",
        e.Edit = "Prop_Edit"
    }(yp || (yp = {})),
    function(e) {
        e[e.Before = 0] = "Before",
        e[e.QueryingDelete = 1] = "QueryingDelete",
        e[e.QueryingResolve = 2] = "QueryingResolve",
        e[e.PostDelete = 3] = "PostDelete",
        e[e.PostResolve = 4] = "PostResolve"
    }(_p || (_p = {}));
    const xp = e=>j(e.conversation, (e=>e.props))
      , wp = (e,t)=>({
        ...e,
        targetUid: t
    })
      , Op = (e,t)=>({
        ...e,
        queue: e.queue.concat(t)
    })
      , Sp = ()=>({
        targetUid: E.none(),
        conversation: [],
        queue: []
    })
      , Cp = (e,t)=>n=>{
        const o = t(n);
        Qo(n, vp, {
            uid: e,
            patch: o
        })
    }
      , Ep = (e,t)=>n=>{
        const o = t(n);
        Qo(n, vp, {
            uid: e,
            patch: o
        }),
        Yo(n, bp)
    }
      , kp = e=>{
        Yo(e, bp)
    }
      , Tp = (e,t)=>{
        ua(e.element, "visibility", "hidden"),
        zd.set(e, !1);
        const n = e.element.dom.clientHeight;
        return zd.set(e, !0),
        va(e.element, "visibility"),
        e.element.dom.scrollHeight > n + 1 ? t : yp.None
    }
      , Mp = e=>{
        zd.off(e),
        na(e.element, Zu.bodyHasGradient)
    }
      , Ap = e=>{
        zd.on(e),
        oa(e.element, Zu.bodyHasGradient)
    }
      , Rp = e=>we(e.element)
      , Np = e=>{
        oa(e.element, Zu.bodyHasGradient),
        zd.set(e, !1),
        Lr(e.element, "aria-expanded")
    }
      , Bp = e=>{
        Rp(e).each((e=>{
            Lr(e, "readonly"),
            na(e, Zu.editingTextarea),
            kr(e);
            const t = e.dom
              , n = ba(e).length;
            t.setSelectionRange(n, n)
        }
        )),
        e.element.dom.scrollTop = 0
    }
      , Fp = e=>{
        const t = e=>t=>{
            z(e, (e=>e(t)))
        }
          , n = t=>{
            Rp(t).each((n=>{
                const o = ha(n, "width");
                ua(n, "width", ac(n) + "px"),
                va(n, "height"),
                Sd.setValue(t, e.props.content),
                t.getSystem().triggerEvent(Co(), n, {}),
                ma(n, {
                    width: o
                })
            }
            ))
        }
          , o = t=>{
            return n = t,
            o = e.memCommands,
            (e=>{
                Rp(e).each((e=>{
                    Hr(e, "readonly", "true"),
                    oa(e, Zu.editingTextarea)
                }
                ))
            }
            )(n),
            void o.getOpt(n).each((e=>{
                Eu.remove(n, e)
            }
            ));
            var n, o
        }
          , r = {
            [yp.None]: t([o, n, Np]),
            [yp.Expanded]: t([o, n, Ap]),
            [yp.Collapsed]: t([o, n, Mp]),
            [yp.ExpandOrNone]: t([o, n, t=>{
                na(t.element, Zu.bodyNotAnimating);
                const n = Tp(t, yp.Expanded);
                Cp(e.props.uid, (()=>({
                    mode: n
                })))(t)
            }
            ]),
            [yp.CollapsedOrNone]: t([o, n, t=>{
                na(t.element, Zu.bodyNotAnimating);
                const n = Tp(t, yp.Collapsed);
                n === yp.Collapsed && (na(t.element, Zu.bodyHasGradient),
                zd.off(t)),
                fa(t.element),
                Cp(e.props.uid, (()=>({
                    mode: n
                })))(t)
            }
            ]),
            [yp.Edit]: t([t=>{
                return n = t,
                o = e.memCommands,
                zd.on(n),
                oa(n.element, Zu.bodyHasGradient),
                void ((e,t)=>{
                    Bp(e),
                    t.getOpt(e).fold((()=>{
                        Eu.append(e, t.asSpec())
                    }
                    ), p)
                }
                )(n, o);
                var n, o
            }
            , n])
        };
        return je(r, e.props.mode)
    }
      , Dp = Cs("tc-focus-outer-comment")
      , Hp = Cs("tc-start-delete-comment")
      , Ip = Cs("tc-start-delete-conversation")
      , Pp = Cs("tc-start-resolve-conversation")
      , Vp = Cs("tc-commit-delete")
      , Wp = Cs("tc-commit-resolve")
      , Lp = Cs("tc-start-edit-comment")
      , Up = Cs("tc-commit-edit-comment");
    Cs("tc-cancel-edit-comment"),
    Cs("tc-long-content"),
    Cs("tc-short-content");
    const jp = Cs("tc-toggle-comment")
      , zp = v([nn("data"), an("inputAttributes", {}), an("inputStyles", {}), an("tag", "input"), an("inputClasses", []), za("onSetValue"), an("styles", {}), an("eventOrder", {}), Ba("inputBehaviours", [Sd, dd]), an("selectOnFocus", !0)])
      , $p = e=>_r([dd.config({
        onFocus: e.selectOnFocus ? e=>{
            const t = e.element
              , n = ba(t);
            t.dom.setSelectionRange(0, n.length)
        }
        : p
    })])
      , qp = e=>({
        ...$p(e),
        ...Fa(e.inputBehaviours, [Sd.config({
            store: {
                mode: "manual",
                ...e.data.map((e=>({
                    initialValue: e
                }))).getOr({}),
                getValue: e=>ba(e.element),
                setValue: (e,t)=>{
                    ba(e.element) !== t && ya(e.element, t)
                }
            },
            onSetValue: e.onSetValue
        })])
    })
      , Gp = e=>({
        tag: e.tag,
        attributes: {
            type: "text",
            ...e.inputAttributes
        },
        styles: e.inputStyles,
        classes: e.inputClasses
    })
      , Kp = Ni({
        name: "Input",
        configFields: zp(),
        factory: (e,t)=>({
            uid: e.uid,
            dom: Gp(e),
            components: [],
            behaviours: qp(e),
            eventOrder: e.eventOrder
        })
    })
      , Yp = e=>e.dom.clientHeight
      , Qp = "data-alloy-widget-tabstop"
      , Jp = e=>jg.config({
        mode: "cyclic",
        onEscape: e.onEscape,
        useTabstopAt: e=>"textarea" !== le(e) || "true" !== Pr(e, "readonly")
    })
      , Xp = e=>jg.config({
        mode: "special",
        onEnter: t=>(Yo(t, e.enterEvent),
        E.some(!0)),
        onShiftEnter: (e,t)=>(t.cut(),
        E.none()),
        onSpace: (e,t)=>(t.cut(),
        E.none())
    })
      , Zp = e=>jg.config({
        mode: "cyclic",
        selector: `[${Qp}="true"]`,
        focusInside: vm.OnEnterOrSpaceMode,
        onEscape: (t,n)=>Bn(t, n) ? E.none() : (Yo(t, e.escapeEvent),
        E.some(!0))
    })
      , eh = e=>jg.config({
        mode: "flow",
        allowVertical: !0,
        selector: e.selector
    })
      , th = {
        "data-gramm_editor": "false",
        rows: "2"
    }
      , nh = {
        "white-space": "pre-wrap"
    }
      , oh = (e,t)=>{
        const n = e.element.dom;
        va(e.element, "height"),
        fa(e.element);
        const o = n.clientHeight
          , r = n.scrollHeight;
        if (r > o) {
            const n = nc(e.element)
              , s = n - o;
            ua(e.element, "height", t(r, n, s) + "px")
        }
    }
      , rh = e=>{
        oh(e, ((t,n,o)=>{
            const r = (s = e.element,
            ye(s).bind((e=>ye(e).bind((t=>xe(t, 1).map((n=>{
                const o = nc(e) - Yp(s);
                return .5 * (Yp(t) - Yp(n) - o)
            }
            ))))))).getOr(3 * n);
            var s;
            if (r < n)
                return n;
            {
                const e = t + o;
                return e > r ? r : e
            }
        }
        ))
    }
      , sh = e=>oh(e, ((e,t,n)=>e + n))
      , ah = e=>{
        const t = Xr();
        return Kp.sketch({
            tag: "textarea",
            inputAttributes: {
                ...th,
                readonly: "true"
            },
            inputClasses: ed.editTextarea,
            inputStyles: {
                ...nh,
                "overflow-y": "hidden",
                border: "none !important"
            },
            data: e,
            inputBehaviours: _r([Cr("textarea-events", [ir((e=>{
                t.set(ac(e.element)),
                sh(e)
            }
            )), nr(Co(), sh)]), ip.config({
                channels: {
                    ...lp(dn),
                    [En]: {
                        onReceive: e=>{
                            const n = ac(e.element);
                            t.on((t=>{
                                t !== n && va(e.element, "height")
                            }
                            )),
                            t.set(n),
                            sh(e)
                        }
                    }
                }
            }), Xp({
                enterEvent: Up
            }), kd.config({}), cp({})])
        })
    }
      , ih = wn
      , ch = {
        [ih.LessThanMinute]: [Bu.tc_date_less_than_a_minute_ago, Bu.tc_date_less_than_a_minute_ago],
        [ih.Minute]: [Bu.tc_date_1_minute_ago, Bu.tc_date_x_minutes_ago],
        [ih.Hour]: [Bu.tc_date_1_hour_ago, Bu.tc_date_x_hours_ago],
        [ih.Day]: [Bu.tc_date_1_day_ago, Bu.tc_date_x_days_ago],
        [ih.Week]: [Bu.tc_date_1_week_ago, Bu.tc_date_x_weeks_ago],
        [ih.Month]: [Bu.tc_date_1_month_ago, Bu.tc_date_x_months_ago],
        [ih.Year]: [Bu.tc_date_1_year_ago, Bu.tc_date_x_years_ago]
    }
      , lh = (e,t)=>{
        const n = ch[e.interval]
          , o = 1 === e.intervalUnits ? n[0] : n[1];
        return t.translate([o, e.intervalUnits])
    }
      , uh = {
        editCommentEvent: Cs("tc-conversation-edit-comment"),
        deleteCommentEvent: Cs("tc-conversation-delete-comment"),
        deleteConversationEvent: Cs("tc-conversation-delete-all"),
        resolveConversationEvent: Cs("tc-conversation-resolve"),
        createCommentEvent: Cs("tc-conversation-create")
    }
      , dh = "aria-controls"
      , mh = (e,t)=>hl(t, (t=>ce(t, e.element)), w) || ((e,t)=>(e=>ts(e, (e=>{
        if (!de(e))
            return !1;
        const t = Pr(e, "id");
        return void 0 !== t && t.indexOf(dh) > -1
    }
    )).bind((e=>{
        const t = Pr(e, "id")
          , n = Se(e);
        return os(n, `[${dh}="${t}"]`)
    }
    )))(t).exists((t=>mh(e, t))))(e, t);
    var gh = Object.freeze({
        __proto__: null,
        getCoupled: (e,t,n,o)=>n.getOrCreate(e, t, o),
        getExistingCoupled: (e,t,n,o)=>n.getExisting(e, t, o)
    })
      , ph = [Zt("others", zt(nt.value, It()))]
      , hh = Object.freeze({
        __proto__: null,
        init: ()=>{
            const e = {}
              , t = (t,n)=>{
                if (0 === Be(t.others).length)
                    throw new Error("Cannot find any known coupled components");
                return je(e, n)
            }
              , n = v({});
            return Tn({
                readState: n,
                getExisting: (e,n,o)=>t(n, o).orThunk((()=>(je(n.others, o).getOrDie("No information found for coupled component: " + o),
                E.none()))),
                getOrCreate: (n,o,r)=>t(o, r).getOrThunk((()=>{
                    const t = je(o.others, r).getOrDie("No information found for coupled component: " + r)(n)
                      , s = n.getSystem().build(t);
                    return e[r] = s,
                    s
                }
                ))
            })
        }
    });
    const vh = wr({
        fields: ph,
        name: "coupling",
        apis: gh,
        state: hh
    })
      , fh = (e,t,n,o)=>{
        n.get().each((t=>{
            zi(e)
        }
        ));
        const r = t.getAttachPoint(e);
        Wi(r, e);
        const s = e.getSystem().build(o);
        return Wi(e, s),
        n.set(s),
        s
    }
      , bh = (e,t,n,o)=>{
        const r = fh(e, t, n, o);
        return t.onOpen(e, r),
        r
    }
      , yh = (e,t,n)=>{
        n.get().each((o=>{
            zi(e),
            ji(e),
            t.onClose(e, o),
            n.clear()
        }
        ))
    }
      , _h = (e,t,n)=>n.isOpen()
      , xh = (e,t,n)=>{
        const o = t.getAttachPoint(e);
        ua(e.element, "position", fu.getMode(o)),
        ((e,t,n,o)=>{
            ha(e.element, t).fold((()=>{
                Lr(e.element, n)
            }
            ), (t=>{
                Hr(e.element, n, t)
            }
            )),
            ua(e.element, t, "hidden")
        }
        )(e, "visibility", t.cloakVisibilityAttr)
    }
      , wh = (e,t,n)=>{
        (e=>U(["top", "left", "right", "bottom"], (t=>ha(e, t).isSome())))(e.element) || va(e.element, "position"),
        ((e,t,n)=>{
            Vr(e.element, n).fold((()=>va(e.element, t)), (n=>ua(e.element, t, n)))
        }
        )(e, "visibility", t.cloakVisibilityAttr)
    }
    ;
    var Oh = Object.freeze({
        __proto__: null,
        cloak: xh,
        close: yh,
        decloak: wh,
        getState: (e,t,n)=>n.get(),
        isOpen: _h,
        isPartOf: (e,t,n,o)=>_h(0, 0, n) && n.get().exists((n=>t.isPartOf(e, n, o))),
        open: bh,
        openWhileCloaked: (e,t,n,o,r)=>{
            xh(e, t),
            bh(e, t, n, o),
            r(),
            wh(e, t)
        }
        ,
        setContent: (e,t,n,o)=>n.get().map((()=>fh(e, t, n, o)))
    })
      , Sh = Object.freeze({
        __proto__: null,
        events: (e,t)=>er([nr(Wo(), ((n,o)=>{
            yh(n, e, t)
        }
        ))])
    })
      , Ch = [za("onOpen"), za("onClose"), Xt("isPartOf"), Xt("getAttachPoint"), an("cloakVisibilityAttr", "data-precloak-visibility")]
      , Eh = Object.freeze({
        __proto__: null,
        init: ()=>{
            const e = Xr()
              , t = v("not-implemented");
            return Tn({
                readState: t,
                isOpen: e.isSet,
                clear: e.clear,
                set: e.set,
                get: e.get
            })
        }
    });
    const kh = wr({
        fields: Ch,
        name: "sandboxing",
        active: Sh,
        apis: Oh,
        state: Eh
    })
      , Th = "alloy.item-hover"
      , Mh = "alloy.item-focus"
      , Ah = "alloy.item-toggled"
      , Rh = e=>{
        (Mr(e.element).isNone() || dd.isFocused(e)) && (dd.isFocused(e) || dd.focus(e),
        Qo(e, Th, {
            item: e
        }))
    }
      , Nh = e=>{
        Qo(e, Mh, {
            item: e
        })
    }
      , Bh = v(Th)
      , Fh = v(Mh)
      , Dh = v(Ah)
      , Hh = e=>e.role.fold((()=>e.toggling.map((e=>e.exclusive ? "menuitemradio" : "menuitemcheckbox")).getOr("menuitem")), f)
      , Ih = [Xt("data"), Xt("components"), Xt("dom"), an("hasSubmenu", !1), nn("toggling"), nn("role"), Da("itemBehaviours", [zd, dd, jg, Sd]), an("ignoreFocus", !1), an("domModification", {}), Ka("builder", (e=>({
        dom: e.dom,
        domModification: {
            ...e.domModification,
            attributes: {
                role: Hh(e),
                ...e.domModification.attributes,
                "aria-haspopup": e.hasSubmenu,
                ...e.hasSubmenu ? {
                    "aria-expanded": !1
                } : {}
            }
        },
        behaviours: Ha(e.itemBehaviours, [e.toggling.fold(zd.revoke, (t=>zd.config(((e,t)=>({
            aria: {
                mode: t ? "selected" : "checked"
            },
            ...We(e, ((e,t)=>"exclusive" !== t)),
            onToggled: (t,n)=>{
                m(e.onToggled) && e.onToggled(t, n),
                ((e,t)=>{
                    Qo(e, Ah, {
                        item: e,
                        state: t
                    })
                }
                )(t, n)
            }
        }))(t, e.role.exists((e=>"option" === e)))))), dd.config({
            ignore: e.ignoreFocus,
            stopMousedown: e.ignoreFocus,
            onFocus: e=>{
                Nh(e)
            }
        }), jg.config({
            mode: "execution"
        }), Sd.config({
            store: {
                mode: "memory",
                initialValue: e.data
            }
        }), Cr("item-type-events", [...$d(), nr(wo(), Rh), nr(Io(), dd.focus)])]),
        components: e.components,
        eventOrder: e.eventOrder
    }))), an("eventOrder", {})]
      , Ph = [Xt("dom"), Xt("components"), Ka("builder", (e=>({
        dom: e.dom,
        components: e.components,
        events: er([sr(Io())])
    })))]
      , Vh = v("item-widget")
      , Wh = v([bi({
        name: "widget",
        overrides: e=>({
            behaviours: _r([Sd.config({
                store: {
                    mode: "manual",
                    getValue: t=>e.data,
                    setValue: p
                }
            })])
        })
    })])
      , Lh = [Xt("uid"), Xt("data"), Xt("components"), Xt("dom"), an("autofocus", !1), an("ignoreFocus", !1), Da("widgetBehaviours", [Sd, dd, jg]), an("domModification", {}), ki(Wh()), Ka("builder", (e=>{
        const t = Ci(Vh(), e, Wh())
          , n = Ei(Vh(), e, t.internals())
          , o = t=>((e,t,n)=>{
            const o = t.partUids.widget;
            return e.getSystem().getByUid(o).toOptional()
        }
        )(t, e).map((e=>(jg.focusIn(e),
        e)))
          , r = (t,n)=>xm(n.event.target) ? E.none() : e.autofocus ? (n.setSource(t.element),
        E.none()) : E.none();
        return {
            dom: e.dom,
            components: n,
            domModification: e.domModification,
            events: er([ur(((e,t)=>{
                o(e).each((e=>{
                    t.stop()
                }
                ))
            }
            )), nr(wo(), Rh), nr(Io(), ((t,n)=>{
                e.autofocus ? o(t) : dd.focus(t)
            }
            ))]),
            behaviours: Ha(e.widgetBehaviours, [Sd.config({
                store: {
                    mode: "memory",
                    initialValue: e.data
                }
            }), dd.config({
                ignore: e.ignoreFocus,
                onFocus: e=>{
                    Nh(e)
                }
            }), jg.config({
                mode: "special",
                focusIn: e.autofocus ? e=>{
                    o(e)
                }
                : Sr(),
                onLeft: r,
                onRight: r,
                onEscape: (t,n)=>dd.isFocused(t) || e.autofocus ? e.autofocus ? (n.setSource(t.element),
                E.none()) : E.none() : (dd.focus(t),
                E.some(!0))
            })])
        }
    }
    ))]
      , Uh = Yt("type", {
        widget: Lh,
        item: Ih,
        separator: Ph
    })
      , jh = v([xi({
        factory: {
            sketch: e=>{
                const t = Gt("menu.spec item", Uh, e);
                return t.builder(t)
            }
        },
        name: "items",
        unit: "item",
        defaults: (e,t)=>ze(t, "uid") ? t : {
            ...t,
            uid: Ns("item")
        },
        overrides: (e,t)=>({
            type: t.type,
            ignoreFocus: e.fakeFocus,
            domModification: {
                classes: [e.markers.item]
            }
        })
    })])
      , zh = v([("role",
    on("role", Vt)), Xt("value"), Xt("items"), Xt("dom"), Xt("components"), an("eventOrder", {}), Ba("menuBehaviours", [mm, Sd, ad, jg]), cn("movement", {
        mode: "menu",
        moveOnTab: !0
    }, Yt("mode", {
        grid: [Qa(), Ka("config", ((e,t)=>({
            mode: "flatgrid",
            selector: "." + e.markers.item,
            initSize: {
                numColumns: t.initSize.numColumns,
                numRows: t.initSize.numRows
            },
            focusManager: e.focusManager
        })))],
        matrix: [Ka("config", ((e,t)=>({
            mode: "matrix",
            selectors: {
                row: t.rowSelector,
                cell: "." + e.markers.item
            },
            previousSelector: t.previousSelector,
            focusManager: e.focusManager
        }))), Xt("rowSelector"), an("previousSelector", E.none)],
        menu: [an("moveOnTab", !0), Ka("config", ((e,t)=>({
            mode: "menu",
            selector: "." + e.markers.item,
            moveOnTab: t.moveOnTab,
            focusManager: e.focusManager
        })))]
    })), Zt("markers", Wa()), an("fakeFocus", !1), an("focusManager", pm()), za("onHighlight"), za("onDehighlight"), an("showMenuRole", !0)]);
    const $h = v("alloy.menu-focus")
      , qh = Bi({
        name: "Menu",
        configFields: zh(),
        partFields: jh(),
        factory: (e,t,n,o)=>({
            uid: e.uid,
            dom: e.dom,
            markers: e.markers,
            behaviours: Fa(e.menuBehaviours, [mm.config({
                highlightClass: e.markers.selectedItem,
                itemClass: e.markers.item,
                onHighlight: e.onHighlight,
                onDehighlight: e.onDehighlight
            }), Sd.config({
                store: {
                    mode: "memory",
                    initialValue: e.value
                }
            }), ad.config({
                find: E.some
            }), jg.config(e.movement.config(e, e.movement))]),
            events: er([nr(Fh(), ((e,t)=>{
                const n = t.event;
                e.getSystem().getByDom(n.target).each((n=>{
                    mm.highlight(e, n),
                    t.stop(),
                    Qo(e, $h(), {
                        menu: e,
                        item: n
                    })
                }
                ))
            }
            )), nr(Bh(), ((e,t)=>{
                const n = t.event.item;
                mm.highlight(e, n)
            }
            )), nr(Dh(), ((e,t)=>{
                const {item: n, state: o} = t.event;
                o && "menuitemradio" === Pr(n.element, "role") && ((e,t)=>{
                    const n = ct(e.element, '[role="menuitemradio"][aria-checked="true"]');
                    z(n, (n=>{
                        ce(n, t.element) || e.getSystem().getByDom(n).each((e=>{
                            zd.off(e)
                        }
                        ))
                    }
                    ))
                }
                )(e, n)
            }
            ))]),
            components: t,
            eventOrder: e.eventOrder,
            ...e.showMenuRole ? {
                domModification: {
                    attributes: {
                        role: e.role.getOr("menu")
                    }
                }
            } : {}
        })
    })
      , Gh = (e,t,n,o)=>je(n, o).bind((o=>je(e, o).bind((o=>{
        const r = Gh(e, t, n, o);
        return E.some([o].concat(r))
    }
    )))).getOr([])
      , Kh = e=>"prepared" === e.type ? E.some(e.menu) : E.none()
      , Yh = ()=>{
        const e = hn({})
          , t = hn({})
          , n = hn({})
          , o = Xr()
          , r = hn({})
          , s = e=>a(e).bind(Kh)
          , a = e=>je(t.get(), e)
          , i = t=>je(e.get(), t);
        return {
            setMenuBuilt: (e,n)=>{
                t.set({
                    ...t.get(),
                    [e]: {
                        type: "prepared",
                        menu: n
                    }
                })
            }
            ,
            setContents: (s,a,i,c)=>{
                o.set(s),
                e.set(i),
                t.set(a),
                r.set(c);
                const l = ((e,t)=>{
                    const n = {};
                    De(e, ((e,t)=>{
                        z(e, (e=>{
                            n[e] = t
                        }
                        ))
                    }
                    ));
                    const o = t
                      , r = Ie(t, ((e,t)=>({
                        k: e,
                        v: t
                    })))
                      , s = He(r, ((e,t)=>[t].concat(Gh(n, o, r, t))));
                    return He(n, (e=>je(s, e).getOr([e])))
                }
                )(c, i);
                n.set(l)
            }
            ,
            expand: t=>je(e.get(), t).map((e=>{
                const o = je(n.get(), t).getOr([]);
                return [e].concat(o)
            }
            )),
            refresh: e=>je(n.get(), e),
            collapse: e=>je(n.get(), e).bind((e=>e.length > 1 ? E.some(e.slice(1)) : E.none())),
            lookupMenu: a,
            lookupItem: i,
            otherMenus: e=>{
                const t = r.get();
                return ee(Be(t), e)
            }
            ,
            getPrimary: ()=>o.get().bind(s),
            getMenus: ()=>t.get(),
            clear: ()=>{
                e.set({}),
                t.set({}),
                n.set({}),
                o.clear()
            }
            ,
            isClear: ()=>o.get().isNone(),
            getTriggeringPath: (t,r)=>{
                const a = $(i(t).toArray(), (e=>s(e).isSome()));
                return je(n.get(), t).bind((t=>{
                    const n = Z(a.concat(t));
                    return (e=>{
                        const t = [];
                        for (let n = 0; n < e.length; n++) {
                            const o = e[n];
                            if (!o.isSome())
                                return E.none();
                            t.push(o.getOrDie())
                        }
                        return E.some(t)
                    }
                    )(J(n, ((t,a)=>((t,n,o)=>s(t).bind((r=>(t=>Ue(e.get(), ((e,n)=>e === t)))(t).bind((e=>n(e).map((e=>({
                        triggeredMenu: r,
                        triggeringItem: e,
                        triggeringPath: o
                    }))))))))(t, r, n.slice(0, a + 1)).fold((()=>dr(o.get(), t) ? [] : [E.none()]), (e=>[E.some(e)])))))
                }
                ))
            }
        }
    }
      , Qh = Kh
      , Jh = Cs("tiered-menu-item-highlight")
      , Xh = Cs("tiered-menu-item-dehighlight");
    var Zh;
    !function(e) {
        e[e.HighlightMenuAndItem = 0] = "HighlightMenuAndItem",
        e[e.HighlightJustMenu = 1] = "HighlightJustMenu",
        e[e.HighlightNone = 2] = "HighlightNone"
    }(Zh || (Zh = {}));
    const ev = v("collapse-item")
      , tv = Ni({
        name: "TieredMenu",
        configFields: [Ga("onExecute"), Ga("onEscape"), qa("onOpenMenu"), qa("onOpenSubmenu"), za("onRepositionMenu"), za("onCollapseMenu"), an("highlightOnOpen", Zh.HighlightMenuAndItem), tn("data", [Xt("primary"), Xt("menus"), Xt("expansions")]), an("fakeFocus", !1), za("onHighlightItem"), za("onDehighlightItem"), za("onHover"), Ua(), Xt("dom"), an("navigateOnHover", !0), an("stayInDom", !1), Ba("tmenuBehaviours", [jg, mm, ad, Eu]), an("eventOrder", {})],
        apis: {
            collapseMenu: (e,t)=>{
                e.collapseMenu(t)
            }
            ,
            highlightPrimary: (e,t)=>{
                e.highlightPrimary(t)
            }
            ,
            repositionMenus: (e,t)=>{
                e.repositionMenus(t)
            }
        },
        factory: (e,t)=>{
            const n = Xr()
              , o = Yh()
              , r = e=>Sd.getValue(e).value
              , s = t=>He(e.data.menus, ((e,t)=>J(e.items, (e=>"separator" === e.type ? [] : [e.data.value]))))
              , a = mm.highlight
              , i = (t,n)=>{
                a(t, n),
                mm.getHighlighted(n).orThunk((()=>mm.getFirst(n))).each((o=>{
                    e.fakeFocus ? mm.highlight(n, o) : Xo(t, o.element, Io())
                }
                ))
            }
              , c = (e,t)=>mr(j(t, (t=>e.lookupMenu(t).bind((e=>"prepared" === e.type ? E.some(e.menu) : E.none())))))
              , l = (t,n,o)=>{
                const r = c(n, n.otherMenus(o));
                z(r, (n=>{
                    aa(n.element, [e.markers.backgroundMenu]),
                    e.stayInDom || Eu.remove(t, n)
                }
                ))
            }
              , u = (t,o)=>{
                const s = (t=>n.get().getOrThunk((()=>{
                    const o = {}
                      , s = ct(t.element, `.${e.markers.item}`)
                      , a = $(s, (e=>"true" === Pr(e, "aria-haspopup")));
                    return z(a, (e=>{
                        t.getSystem().getByDom(e).each((e=>{
                            const t = r(e);
                            o[t] = e
                        }
                        ))
                    }
                    )),
                    n.set(o),
                    o
                }
                )))(t);
                De(s, ((e,t)=>{
                    const n = L(o, t);
                    Hr(e.element, "aria-expanded", n)
                }
                ))
            }
              , d = (t,n,o)=>E.from(o[0]).bind((r=>n.lookupMenu(r).bind((r=>{
                if ("notbuilt" === r.type)
                    return E.none();
                {
                    const s = r.menu
                      , a = c(n, o.slice(1));
                    return z(a, (t=>{
                        na(t.element, e.markers.backgroundMenu)
                    }
                    )),
                    it(s.element) || Eu.append(t, Na(s)),
                    aa(s.element, [e.markers.backgroundMenu]),
                    i(t, s),
                    l(t, n, o),
                    E.some(s)
                }
            }
            ))));
            let m;
            !function(e) {
                e[e.HighlightSubmenu = 0] = "HighlightSubmenu",
                e[e.HighlightParent = 1] = "HighlightParent"
            }(m || (m = {}));
            const g = (t,n,s=m.HighlightSubmenu)=>{
                if (n.hasConfigured(rp) && rp.isDisabled(n))
                    return E.some(n);
                {
                    const a = r(n);
                    return o.expand(a).bind((r=>(u(t, r),
                    E.from(r[0]).bind((a=>o.lookupMenu(a).bind((i=>{
                        const c = ((e,t,n)=>{
                            if ("notbuilt" === n.type) {
                                const r = e.getSystem().build(n.nbMenu());
                                return o.setMenuBuilt(t, r),
                                r
                            }
                            return n.menu
                        }
                        )(t, a, i);
                        return it(c.element) || Eu.append(t, Na(c)),
                        e.onOpenSubmenu(t, n, c, Z(r)),
                        s === m.HighlightSubmenu ? (mm.highlightFirst(c),
                        d(t, o, r)) : (mm.dehighlightAll(c),
                        E.some(n))
                    }
                    )))))))
                }
            }
              , h = (t,n)=>{
                const s = r(n);
                return o.collapse(s).bind((r=>(u(t, r),
                d(t, o, r).map((o=>(e.onCollapseMenu(t, n, o),
                o))))))
            }
              , v = t=>(n,o)=>rs(o.getSource(), `.${e.markers.item}`).bind((e=>n.getSystem().getByDom(e).toOptional().bind((e=>t(n, e).map(O)))))
              , b = er([nr($h(), ((e,t)=>{
                const n = t.event.item;
                o.lookupItem(r(n)).each((()=>{
                    const n = t.event.menu;
                    mm.highlight(e, n);
                    const s = r(t.event.item);
                    o.refresh(s).each((t=>l(e, o, t)))
                }
                ))
            }
            )), ur(((t,n)=>{
                const o = n.event.target;
                t.getSystem().getByDom(o).each((n=>{
                    0 === r(n).indexOf("collapse-item") && h(t, n),
                    g(t, n, m.HighlightSubmenu).fold((()=>{
                        e.onExecute(t, n)
                    }
                    ), p)
                }
                ))
            }
            )), ir(((t,n)=>{
                (t=>{
                    const n = ((t,n,o)=>He(o, ((o,r)=>{
                        const s = ()=>qh.sketch({
                            ...o,
                            value: r,
                            markers: e.markers,
                            fakeFocus: e.fakeFocus,
                            onHighlight: (e,t)=>{
                                Qo(e, Jh, {
                                    menuComp: e,
                                    itemComp: t
                                })
                            }
                            ,
                            onDehighlight: (e,t)=>{
                                Qo(e, Xh, {
                                    menuComp: e,
                                    itemComp: t
                                })
                            }
                            ,
                            focusManager: e.fakeFocus ? hm() : pm()
                        });
                        return r === n ? {
                            type: "prepared",
                            menu: t.getSystem().build(s())
                        } : {
                            type: "notbuilt",
                            nbMenu: s
                        }
                    }
                    )))(t, e.data.primary, e.data.menus)
                      , r = s();
                    return o.setContents(e.data.primary, n, e.data.expansions, r),
                    o.getPrimary()
                }
                )(t).each((n=>{
                    Eu.append(t, Na(n)),
                    e.onOpenMenu(t, n),
                    e.highlightOnOpen === Zh.HighlightMenuAndItem ? i(t, n) : e.highlightOnOpen === Zh.HighlightJustMenu && a(t, n)
                }
                ))
            }
            )), nr(Jh, ((t,n)=>{
                e.onHighlightItem(t, n.event.menuComp, n.event.itemComp)
            }
            )), nr(Xh, ((t,n)=>{
                e.onDehighlightItem(t, n.event.menuComp, n.event.itemComp)
            }
            )), ...e.navigateOnHover ? [nr(Bh(), ((t,n)=>{
                const s = n.event.item;
                ((e,t)=>{
                    const n = r(t);
                    o.refresh(n).bind((t=>(u(e, t),
                    d(e, o, t))))
                }
                )(t, s),
                g(t, s, m.HighlightParent),
                e.onHover(t, s)
            }
            ))] : []])
              , y = e=>mm.getHighlighted(e).bind(mm.getHighlighted)
              , _ = {
                collapseMenu: e=>{
                    y(e).each((t=>{
                        h(e, t)
                    }
                    ))
                }
                ,
                highlightPrimary: e=>{
                    o.getPrimary().each((t=>{
                        i(e, t)
                    }
                    ))
                }
                ,
                repositionMenus: t=>{
                    const n = o.getPrimary().bind((e=>y(t).bind((e=>{
                        const t = r(e)
                          , n = (s = o.getMenus(),
                        Le(s, f));
                        var s;
                        const a = mr(j(n, Qh));
                        return o.getTriggeringPath(t, (e=>((e,t,n)=>se(t, (e=>{
                            if (!e.getSystem().isConnected())
                                return E.none();
                            const t = mm.getCandidates(e);
                            return K(t, (e=>r(e) === n))
                        }
                        )))(0, a, e)))
                    }
                    )).map((t=>({
                        primary: e,
                        triggeringPath: t
                    })))));
                    n.fold((()=>{
                        (e=>E.from(e.components()[0]).filter((e=>"menu" === Pr(e.element, "role"))))(t).each((n=>{
                            e.onRepositionMenu(t, n, [])
                        }
                        ))
                    }
                    ), (({primary: n, triggeringPath: o})=>{
                        e.onRepositionMenu(t, n, o)
                    }
                    ))
                }
            };
            return {
                uid: e.uid,
                dom: e.dom,
                markers: e.markers,
                behaviours: Fa(e.tmenuBehaviours, [jg.config({
                    mode: "special",
                    onRight: v(((e,t)=>xm(t.element) ? E.none() : g(e, t, m.HighlightSubmenu))),
                    onLeft: v(((e,t)=>xm(t.element) ? E.none() : h(e, t))),
                    onEscape: v(((t,n)=>h(t, n).orThunk((()=>e.onEscape(t, n).map((()=>t)))))),
                    focusIn: (e,t)=>{
                        o.getPrimary().each((t=>{
                            Xo(e, t.element, Io())
                        }
                        ))
                    }
                }), mm.config({
                    highlightClass: e.markers.selectedMenu,
                    itemClass: e.markers.menu
                }), ad.config({
                    find: e=>mm.getHighlighted(e)
                }), Eu.config({})]),
                eventOrder: e.eventOrder,
                apis: _,
                events: b
            }
        }
        ,
        extraApis: {
            tieredData: (e,t,n)=>({
                primary: e,
                menus: t,
                expansions: n
            }),
            singleData: (e,t)=>({
                primary: e,
                menus: An(e, t),
                expansions: {}
            }),
            collapseItem: e=>({
                value: Cs(ev()),
                meta: {
                    text: e
                }
            })
        }
    })
      , nv = v("sink")
      , ov = v(_i({
        name: nv(),
        overrides: v({
            dom: {
                tag: "div"
            },
            behaviours: _r([fu.config({
                useFixed: O
            })]),
            events: er([rr(Oo()), rr(xo()), rr(Eo())])
        })
    }))
      , rv = Bt([an("isExtraPart", w), rn("fireEventInstead", [an("event", zo())])])
      , sv = e=>{
        const t = Gt("Dismissal", rv, e);
        return {
            [S()]: {
                schema: Bt([Xt("target")]),
                onReceive: (e,n)=>{
                    kh.isOpen(e) && (kh.isPartOf(e, n.target) || t.isExtraPart(e, n.target) || t.fireEventInstead.fold((()=>kh.close(e)), (t=>Yo(e, t.event))))
                }
            }
        }
    }
      , av = Bt([rn("fireEventInstead", [an("event", $o())]), Zt("doReposition", Lt)])
      , iv = e=>{
        const t = Gt("Reposition", av, e);
        return {
            [C()]: {
                onReceive: e=>{
                    kh.isOpen(e) && t.fireEventInstead.fold((()=>t.doReposition(e)), (t=>Yo(e, t.event)))
                }
            }
        }
    }
      , cv = (e,t)=>{
        const n = e.getHotspot(t).getOr(t)
          , o = "hotspot"
          , r = e.getAnchorOverrides();
        return e.layouts.fold((()=>({
            type: o,
            hotspot: n,
            overrides: r
        })), (e=>({
            type: o,
            hotspot: n,
            overrides: r,
            layouts: e
        })))
    }
      , lv = (e,t,n,o,r,s,a)=>{
        const i = ((e,t,n,o,r,s,a)=>{
            const i = ((e,t,n)=>(0,
            e.fetch)(n).map(t))(e, t, o)
              , c = dv(o, e);
            return i.map((t=>t.bind((t=>{
                const i = t.menus[t.primary];
                return E.from(i).each((t=>{
                    e.listRole.each((e=>{
                        t.role = e
                    }
                    ))
                }
                )),
                E.from(tv.sketch({
                    ...s.menu(),
                    uid: Ns(""),
                    data: t,
                    highlightOnOpen: a,
                    onOpenMenu: (e,t)=>{
                        const o = c().getOrDie();
                        fu.position(o, t, {
                            anchor: n
                        }),
                        kh.decloak(r)
                    }
                    ,
                    onOpenSubmenu: (e,t,n)=>{
                        const o = c().getOrDie();
                        fu.position(o, n, {
                            anchor: {
                                type: "submenu",
                                item: t
                            }
                        }),
                        kh.decloak(r)
                    }
                    ,
                    onRepositionMenu: (e,t,o)=>{
                        const r = c().getOrDie();
                        fu.position(r, t, {
                            anchor: n
                        }),
                        z(o, (e=>{
                            fu.position(r, e.triggeredMenu, {
                                anchor: {
                                    type: "submenu",
                                    item: e.triggeringItem
                                }
                            })
                        }
                        ))
                    }
                    ,
                    onEscape: ()=>(dd.focus(o),
                    kh.close(r),
                    E.some(!0))
                }))
            }
            ))))
        }
        )(e, t, cv(e, n), n, o, r, a);
        return i.map((e=>(e.fold((()=>{
            kh.isOpen(o) && kh.close(o)
        }
        ), (e=>{
            kh.cloak(o),
            kh.open(o, e),
            s(o)
        }
        )),
        o)))
    }
      , uv = (e,t,n,o,r,s,a)=>(kh.close(o),
    Ze(o))
      , dv = (e,t)=>e.getSystem().getByUid(t.uid + "-" + nv()).map((e=>()=>nt.value(e))).getOrThunk((()=>t.lazySink.fold((()=>()=>nt.error(new Error("No internal sink is specified, nor could an external sink be found"))), (t=>()=>t(e)))))
      , mv = e=>{
        kh.getState(e).each((e=>{
            tv.repositionMenus(e)
        }
        ))
    }
      , gv = (e,t,n)=>{
        const o = (()=>{
            const e = Cs(dh);
            return {
                id: e,
                link: t=>{
                    Hr(t, dh, e)
                }
                ,
                unlink: e=>{
                    Lr(e, dh)
                }
            }
        }
        )()
          , r = dv(t, e);
        return {
            dom: {
                tag: "div",
                classes: e.sandboxClasses,
                attributes: {
                    id: o.id
                }
            },
            behaviours: Ha(e.sandboxBehaviours, [Sd.config({
                store: {
                    mode: "memory",
                    initialValue: t
                }
            }), kh.config({
                onOpen: (r,s)=>{
                    const a = cv(e, t);
                    o.link(t.element),
                    e.matchWidth && ((e,t,n)=>{
                        const o = ad.getCurrent(t).getOr(t)
                          , r = ac(e.element);
                        n ? ua(o.element, "min-width", r + "px") : ((e,t)=>{
                            sc.set(e, t)
                        }
                        )(o.element, r)
                    }
                    )(a.hotspot, s, e.useMinWidth),
                    e.onOpen(a, r, s),
                    void 0 !== n && void 0 !== n.onOpen && n.onOpen(r, s)
                }
                ,
                onClose: (e,s)=>{
                    o.unlink(t.element),
                    r().getOr(s).element.dom.dispatchEvent(new window.FocusEvent("focusout")),
                    void 0 !== n && void 0 !== n.onClose && n.onClose(e, s)
                }
                ,
                isPartOf: (e,n,o)=>mh(n, o) || mh(t, o),
                getAttachPoint: ()=>r().getOrDie()
            }), ad.config({
                find: e=>kh.getState(e).bind((e=>ad.getCurrent(e)))
            }), ip.config({
                channels: {
                    ...sv({
                        isExtraPart: w
                    }),
                    ...iv({
                        doReposition: mv
                    })
                }
            })])
        }
    }
      , pv = v([Xt("dom"), Xt("fetch"), za("onOpen"), $a("onExecute"), an("getHotspot", E.some), an("getAnchorOverrides", v({})), bl(), Ba("dropdownBehaviours", [zd, vh, jg, dd]), Xt("toggleClass"), an("eventOrder", {}), nn("lazySink"), an("matchWidth", !1), an("useMinWidth", !1), nn("role"), nn("listRole")].concat([an("sandboxClasses", []), Da("sandboxBehaviours", [ad, ip, kh, Sd])]))
      , hv = v([yi({
        schema: [Ua(), an("fakeFocus", !1)],
        name: "menu",
        defaults: e=>({
            onExecute: e.onExecute
        })
    }), ov()])
      , vv = Bi({
        name: "Dropdown",
        configFields: pv(),
        partFields: hv(),
        factory: (e,t,n,o)=>{
            const r = e=>{
                kh.getState(e).each((e=>{
                    tv.highlightPrimary(e)
                }
                ))
            }
              , s = (t,n,r)=>((e,t,n,o,r,s)=>{
                const a = vh.getCoupled(n, "sandbox");
                return (kh.isOpen(a) ? uv : lv)(e, t, n, a, o, r, s)
            }
            )(e, f, t, o, n, r)
              , a = {
                expand: e=>{
                    zd.isOn(e) || s(e, p, Zh.HighlightNone).get(p)
                }
                ,
                open: e=>{
                    zd.isOn(e) || s(e, p, Zh.HighlightMenuAndItem).get(p)
                }
                ,
                refetch: t=>vh.getExistingCoupled(t, "sandbox").fold((()=>s(t, p, Zh.HighlightMenuAndItem).map(p)), (n=>lv(e, f, t, n, o, p, Zh.HighlightMenuAndItem).map(p))),
                isOpen: zd.isOn,
                close: e=>{
                    zd.isOn(e) && s(e, p, Zh.HighlightMenuAndItem).get(p)
                }
                ,
                repositionMenus: e=>{
                    zd.isOn(e) && (e=>{
                        const t = vh.getCoupled(e, "sandbox");
                        mv(t)
                    }
                    )(e)
                }
            }
              , i = (e,t)=>(Jo(e),
            E.some(!0));
            return {
                uid: e.uid,
                dom: e.dom,
                components: t,
                behaviours: Fa(e.dropdownBehaviours, [zd.config({
                    toggleClass: e.toggleClass,
                    aria: {
                        mode: "expanded"
                    }
                }), vh.config({
                    others: {
                        sandbox: t=>gv(e, t, {
                            onOpen: ()=>zd.on(t),
                            onClose: ()=>zd.off(t)
                        })
                    }
                }), jg.config({
                    mode: "special",
                    onSpace: i,
                    onEnter: i,
                    onDown: (e,t)=>{
                        if (vv.isOpen(e)) {
                            const t = vh.getCoupled(e, "sandbox");
                            r(t)
                        } else
                            vv.open(e);
                        return E.some(!0)
                    }
                    ,
                    onEscape: (e,t)=>vv.isOpen(e) ? (vv.close(e),
                    E.some(!0)) : E.none()
                }), dd.config({})]),
                events: qd(E.some((e=>{
                    s(e, r, Zh.HighlightMenuAndItem).get(p)
                }
                ))),
                eventOrder: {
                    ...e.eventOrder,
                    [Ho()]: ["disabling", "toggling", "alloy.base.behaviour"]
                },
                apis: a,
                domModification: {
                    attributes: {
                        "aria-haspopup": e.listRole.getOr("true"),
                        ...e.role.fold((()=>({})), (e=>({
                            role: e
                        }))),
                        ..."button" === e.dom.tag ? {
                            type: ("type",
                            je(e.dom, "attributes").bind((e=>je(e, "type")))).getOr("button")
                        } : {}
                    }
                }
            }
        }
        ,
        apis: {
            open: (e,t)=>e.open(t),
            refetch: (e,t)=>e.refetch(t),
            expand: (e,t)=>e.expand(t),
            close: (e,t)=>e.close(t),
            isOpen: (e,t)=>e.isOpen(t),
            repositionMenus: (e,t)=>e.repositionMenus(t)
        }
    })
      , fv = "alloy.base.behaviour"
      , bv = Cs("tc-kebab-action")
      , yv = (e,t)=>{
        const n = j(e, (e=>({
            type: "item",
            data: {
                value: e.eventName
            },
            dom: {
                tag: "div",
                classes: ed.kebabItem
            },
            components: [{
                dom: {
                    tag: "span",
                    classes: ed.kebabItemLabel
                },
                components: [ka(t.universe.translate(e.textKey))]
            }],
            itemBehaviours: _r([Cr("item-events", [ur((t=>{
                Qo(t, bv, {
                    eventName: e.eventName
                }),
                Yo(t, Wo())
            }
            ))]), ...up({
                disablingConfig: {
                    disableClass: ed.kebabDisabledItem.join(" ")
                }
            })]),
            eventOrder: {
                [Ho()]: [rp.name(), fv, zd.name(), "typeaheadevents", "item-events"]
            }
        })));
        return vv.sketch({
            dom: {
                tag: "button",
                attributes: {
                    type: "button"
                },
                classes: ed.kebab
            },
            components: [{
                dom: {
                    tag: "div",
                    classes: ed.kebabIcon,
                    innerHtml: '<svg width="24" height="24" data-name="icon-image-options"><g id="icon-image-options" stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2z" id="Shape" fill-rule="nonzero"></path></g></svg>'
                }
            }],
            lazySink: e=>t.getSink(e).fold((()=>nt.error("Could not find sink for kebab")), nt.value),
            dropdownBehaviours: _r([...up({}), kd.config({
                tabAttr: Qp
            })]),
            sandboxBehaviours: _r([Cr("kebab-sandbox-events", [nr(bv, ((e,t)=>{
                const n = Sd.getValue(e);
                Yo(n, t.event.eventName)
            }
            ))])]),
            parts: {
                menu: {
                    dom: {
                        tag: "div"
                    },
                    markers: td.kebab
                }
            },
            toggleClass: Zu.kebabOpen,
            layouts: {
                onLtr: ()=>[Zc],
                onRtl: ()=>[Xc]
            },
            fetch: ()=>{
                const e = Cs("kebab-id");
                return Ze(E.some(tv.singleData(e, {
                    value: Cs(e),
                    dom: {
                        tag: "div",
                        classes: ed.kebabMenu
                    },
                    components: [{
                        dom: {
                            tag: "div",
                            classes: ed.kebabMenuGroup
                        },
                        components: [qh.parts.items({})]
                    }],
                    items: n
                })))
            }
        })
    }
      , _v = e=>{
        const t = T(e)
          , n = _e(t)
          , o = (e=>{
            const t = void 0 !== e.dom.attributes ? e.dom.attributes : [];
            return G(t, ((e,t)=>"class" === t.name ? e : {
                ...e,
                [t.name]: t.value
            }), {})
        }
        )(t)
          , r = (e=>Array.prototype.slice.call(e.dom.classList, 0))(t)
          , s = 0 === n.length ? {} : {
            innerHtml: Br(t)
        };
        return {
            tag: le(t),
            classes: r,
            attributes: o,
            ...s
        }
    }
      , xv = "overlay-button-events"
      , wv = [kd.config({}), Cr(xv, [nr(xo(), ((e,t)=>{
        t.event.prevent()
    }
    ))])]
      , Ov = (e,t,n)=>{
        const o = t=>{
            Yo(t, Dp),
            Ep(e(), (()=>({
                stage: _p.Before
            })))(t)
        }
          , r = (e,t,n)=>zg.sketch({
            dom: {
                tag: "button",
                classes: e ? ed.button : ed.secondaryButton
            },
            components: [ka(t)],
            eventOrder: {
                [xo()]: [fv, dd.name(), xv]
            },
            action: n,
            buttonBehaviours: _r(wv)
        })
          , s = {
            setText: (e,s,a)=>{
                const i = ((e,o)=>{
                    const r = j(((e,t)=>{
                        switch (t) {
                        case _p.QueryingDelete:
                            return n ? [Bu.tc_delete_prompts_conversation, 1 === e ? Bu.tc_delete_prompts_conversation_detail_sing : {
                                pattern: Bu.tc_delete_prompts_conversation_detail_pl,
                                targets: [e]
                            }] : [Bu.tc_delete_prompts_comment];
                        case _p.QueryingResolve:
                            return [Bu.tc_resolve_prompts_conversation, 1 === e ? Bu.tc_resolve_prompts_conversation_detail_sing : {
                                pattern: Bu.tc_resolve_prompts_conversation_detail_pl,
                                targets: [e]
                            }];
                        default:
                            return []
                        }
                    }
                    )(e, o), (e=>"string" == typeof e ? t.translate(e) : t.translate([e.pattern].concat(e.targets))))
                      , s = o === _p.QueryingDelete;
                    return {
                        lines: r,
                        cancelText: t.translate(Bu.tc_delete_buttons_cancel),
                        proceedText: t.translate(s ? Bu.tc_delete_buttons_proceed : Bu.tc_resolve_buttons_proceed),
                        proceedEvent: s ? Vp : Wp
                    }
                }
                )(s, a);
                Eu.set(e, j(i.lines, (e=>({
                    dom: {
                        tag: "div"
                    },
                    components: [{
                        dom: _v(`<p>${e}</p>`)
                    }]
                }))).concat([{
                    dom: {
                        tag: "div",
                        classes: ed.cardOverlayButtons
                    },
                    components: [r(!0, i.cancelText, o), r(!1, i.proceedText, (e=>{
                        Yo(e, i.proceedEvent)
                    }
                    ))]
                }]))
            }
        };
        return {
            dom: {
                tag: "div",
                styles: {
                    display: "none"
                },
                classes: ed.cardOverlayText
            },
            components: [],
            apis: s,
            behaviours: _r([Eu.config({}), Cr("card-delete-events", [nr(Bo(), (t=>{
                Mr(t.element).fold((()=>{
                    Ep(e(), (()=>({
                        stage: _p.Before
                    })))(t)
                }
                ), p)
            }
            ))]), jg.config({
                mode: "cyclic",
                onEscape: e=>(o(e),
                E.some(!0))
            })])
        }
    }
      , Sv = (e,t,n)=>{
        n ? (va(t.element, "display"),
        t.hasConfigured(jg) && jg.focusIn(t)) : ua(t.element, "display", "none")
    }
      , Cv = "basecamp"
      , Ev = "deleting"
      , kv = {
        textKey: Bu.tc_kebab_edit,
        eventName: Lp
    }
      , Tv = {
        textKey: Bu.tc_kebab_delete,
        eventName: Hp
    }
      , Mv = {
        textKey: Bu.tc_kebab_delete_conversation,
        eventName: Ip
    }
      , Av = {
        textKey: Bu.tc_kebab_resolve_conversation,
        eventName: Pp
    }
      , Rv = (e,t,n,o)=>{
        let r = e;
        const s = Q([n.deleteConversation ? [Mv] : [], n.resolveConversation ? [Av] : [], n.editComment ? [kv] : [], n.deleteComment ? [Tv] : []])
          , a = qi(((e,t)=>{
            const n = e=>[ka(`${lh(On(e.createdAt), t)}`), {
                dom: {
                    tag: "span",
                    classes: []
                },
                components: e.modifiedAt === e.createdAt ? [] : [ka(t.translate(Bu.tc_date_comment_edited))]
            }]
              , o = {
                updateWith: (e,t,o)=>{
                    Eu.set(e, n(t))
                }
            };
            return {
                dom: {
                    tag: "div",
                    classes: ed.date
                },
                components: n(e),
                behaviours: _r([Eu.config({})]),
                apis: o
            }
        }
        )(e, o.universe))
          , i = {
            updateWith: (e,t,n)=>{
                r = t,
                l.getOpt(e).each((e=>{
                    e.getApis().updateWith(e, t, {})
                }
                )),
                u.getOpt(e).each((e=>{
                    e.getApis().updateWith(e, t, {})
                }
                )),
                ((e,t,n)=>{
                    const o = n.stage === _p.QueryingDelete || n.stage === _p.QueryingResolve;
                    d.getOpt(e).each((e=>Sv(0, e, o))),
                    m.getOpt(e).each((e=>{
                        e.getApis().setText(e, t, n.stage),
                        Sv(0, e, o)
                    }
                    ))
                }
                )(e, n.numComments, t),
                t.stage !== _p.PostDelete && t.stage !== _p.PostResolve || Hd.getCurrentRoute(e).filter((e=>e.destination === Ev)).fold((()=>{
                    Hd.progressTo(e, Ev)
                }
                ), p),
                a.getOpt(e).each((e=>{
                    e.getApis().updateWith(e, t, {})
                }
                ))
            }
        }
          , c = {
            dom: {
                tag: "div",
                classes: ed.cardHead
            },
            components: Q([[{
                dom: {
                    tag: "div",
                    classes: ed.cardHeadMeta
                },
                components: [(e=>{
                    const t = ((e,t)=>({
                        dom: {
                            tag: "div",
                            classes: ed.avatar
                        },
                        components: [{
                            dom: {
                                tag: "img",
                                attributes: {
                                    alt: "",
                                    role: "presentation",
                                    src: od(e, t)
                                }
                            }
                        }]
                    }))(o.avatarCache, e)
                      , n = {
                        dom: {
                            tag: "div",
                            classes: ed.username
                        },
                        components: [ka(e.authorName)]
                    };
                    return {
                        dom: {
                            tag: "div",
                            classes: ed.user
                        },
                        components: [t, {
                            dom: {
                                tag: "div"
                            },
                            components: [n, a.asSpec()]
                        }]
                    }
                }
                )(r)]
            }], s.length > 0 ? [yv(s, o)] : []])
        }
          , l = qi((e=>{
            const t = hn(e)
              , n = {
                updateWith: (e,n,o)=>{
                    switch (t.set(n),
                    n.mode) {
                    case yp.None:
                        ua(e.element, "display", "none");
                        break;
                    case yp.Collapsed:
                        va(e.element, "display"),
                        we(e.element).each((e=>Fr(e, Bu.tc_comment_buttons_showmore)));
                        break;
                    case yp.Expanded:
                        va(e.element, "display"),
                        we(e.element).each((e=>Fr(e, Bu.tc_comment_buttons_showless)));
                        break;
                    case yp.ExpandOrNone:
                    case yp.CollapsedOrNone:
                        break;
                    case yp.Edit:
                        ua(e.element, "display", "none")
                    }
                }
            };
            return {
                dom: {
                    tag: "div",
                    classes: ed.showMoreLessContainer,
                    styles: {
                        display: "none"
                    }
                },
                components: [zg.sketch({
                    dom: {
                        tag: "p",
                        classes: ed.showMoreLess
                    },
                    components: [ka(Bu.tc_comment_buttons_showmore)],
                    action: e=>{
                        Ep(t.get().uid, (()=>({
                            mode: t.get().mode === yp.Collapsed ? yp.Expanded : yp.Collapsed
                        })))(e)
                    }
                    ,
                    buttonBehaviours: _r([kd.config({
                        tabAttr: Qp
                    })])
                })],
                apis: n
            }
        }
        )({
            uid: e.uid,
            mode: e.mode
        }))
          , u = qi(((e,t)=>{
            const n = hn(e)
              , o = e=>{
                Yo(e, Dp),
                Ep(n.get().uid, (e=>({
                    mode: yp.ExpandOrNone
                })))(e)
            }
              , r = {
                updateWith: (e,t,o)=>{
                    n.set(t),
                    Fp({
                        props: t,
                        memCommands: s
                    }).each((t=>{
                        oa(e.element, Zu.bodyNotAnimating),
                        t(e)
                    }
                    ))
                }
            }
              , s = qi(((e,t)=>({
                dom: {
                    tag: "div",
                    classes: ed.editActions
                },
                components: [gp({
                    text: t.translate(Bu.tc_edit_buttons_cancel),
                    eventName: E.some(hp),
                    disableWhileSaving: !0
                }), mp({
                    text: t.translate(Bu.tc_edit_buttons_save),
                    eventName: E.some(pp),
                    disableWhileSaving: !0
                })]
            }))(n.get(), t))
              , a = he("textarea");
            return {
                dom: {
                    tag: "div",
                    classes: ed.cardBody
                },
                components: [ah(n.get().content)],
                behaviours: _r([Cr("overflow-events", [ir((e=>{
                    r.updateWith(e, n.get(), {})
                }
                )), nr(pp, (e=>{
                    Yo(e, Up)
                }
                )), nr(hp, o), ar(To(), ((e,t)=>{
                    "max-height" === t.event.raw.propertyName && we(e.element).each((t=>{
                        e.getSystem().triggerEvent(Co(), t, {})
                    }
                    ))
                }
                ))]), Jp({
                    onEscape: e=>(o(e),
                    E.some(!0))
                }), zd.config({
                    toggleClass: Zu.bodyExpanded,
                    selected: !1,
                    toggleOnExecute: !1,
                    aria: {
                        mode: "expanded"
                    }
                }), Sd.config({
                    store: {
                        mode: "manual",
                        getValue: e=>we(e.element).filter(a).map(ba).getOr(""),
                        setValue: (e,t)=>{
                            we(e.element).filter(a).each((e=>{
                                ya(e, t)
                            }
                            ))
                        }
                    }
                }), Eu.config({})]),
                apis: r
            }
        }
        )(r, o.universe))
          , d = qi({
            dom: {
                tag: "div",
                classes: ed.cardOverlay,
                styles: {
                    display: "none"
                }
            }
        })
          , m = qi(Ov((()=>r.uid), o.universe, t));
        return {
            dom: {
                tag: "div",
                classes: ed.card,
                styles: {
                    position: "relative"
                }
            },
            components: [c, u.asSpec(), d.asSpec(), m.asSpec(), l.asSpec()],
            behaviours: _r([dd.config({}), kd.config({}), Zp({
                escapeEvent: Dp
            }), Hd.config({
                initialState: Cv,
                onTransition: e=>{
                    var t;
                    (t = r.uid,
                    e=>{
                        Qo(e, fp, {
                            uid: t
                        })
                    }
                    )(e)
                }
                ,
                routes: {
                    [Cv]: {
                        [Ev]: {
                            transition: {
                                property: "opacity",
                                transitionClass: Zu.disappearing
                            }
                        }
                    }
                }
            }), Sd.config({
                store: {
                    mode: "memory",
                    initialValue: r.uid
                }
            }), Cr("comment-events", [nr(jp, (e=>Ep(r.uid, (()=>({
                mode: r.mode === yp.Collapsed ? yp.Expanded : yp.Collapsed
            })))(e))), nr(Dp, dd.focus), nr(Hp, (e=>{
                Ep(r.uid, (()=>({
                    stage: _p.QueryingDelete
                })))(e)
            }
            )), nr(Ip, (e=>{
                Ep(r.uid, (()=>({
                    stage: _p.QueryingDelete
                })))(e)
            }
            )), nr(Pp, (e=>{
                Ep(r.uid, (()=>({
                    stage: _p.QueryingResolve
                })))(e)
            }
            )), nr(Wp, (e=>{
                Qo(e, uh.resolveConversationEvent, {
                    uid: r.uid
                })
            }
            )), nr(Lp, (e=>Ep(r.uid, (e=>({
                mode: yp.Edit
            })))(e))), nr(Up, (e=>{
                u.getOpt(e).each((t=>{
                    const n = Sd.getValue(t);
                    Qo(e, uh.editCommentEvent, {
                        uid: r.uid,
                        content: n
                    })
                }
                ))
            }
            )), nr(Vp, (e=>{
                Qo(e, t ? uh.deleteConversationEvent : uh.deleteCommentEvent, {
                    uid: r.uid
                })
            }
            ))])]),
            apis: i
        }
    }
      , Nv = (e,t,n)=>j(e, ((e,o)=>{
        const r = 0 === o;
        return Rv(e, r, {
            editComment: !0,
            deleteComment: o > 0,
            deleteConversation: r,
            resolveConversation: r && n
        }, t)
    }
    ))
      , Bv = (e,t,n=!1)=>{
        const o = {
            setComments: (e,o)=>{
                ad.getCurrent(e).each((e=>{
                    Eu.set(e, Nv(o, t, n))
                }
                )),
                kp(e)
            }
            ,
            updateWith: (e,o,r)=>{
                ad.getCurrent(e).each((r=>{
                    const s = Eu.contents(r);
                    (e=>re(e).exists((e=>e.stage === _p.QueryingDelete)))(o) || (e=>re(e).exists((e=>e.stage === _p.QueryingResolve)))(o) ? na(r.element, Zu.commentThreadOverlay) : oa(r.element, Zu.commentThreadOverlay),
                    s.length !== o.length ? Eu.set(r, Nv(o, t, n)) : z(s, ((e,t)=>{
                        s[t].getApis().updateWith(s[t], o[t], {
                            numComments: o.length
                        })
                    }
                    )),
                    kp(e)
                }
                ))
            }
            ,
            scrollToEnd: e=>{
                ad.getCurrent(e).each((t=>{
                    var n;
                    (n = Eu.contents(t),
                    oe(n, n.length - 1)).each((t=>{
                        const n = e.element.dom
                          , o = n.getBoundingClientRect()
                          , r = t.element.dom.getBoundingClientRect();
                        r.top < o.top ? n.scrollTop += r.top - o.top : r.bottom > o.bottom && (n.scrollTop += r.bottom - o.bottom)
                    }
                    ))
                }
                ))
            }
        };
        return {
            dom: {
                tag: "div",
                classes: ed.outerScroll
            },
            components: [{
                dom: {
                    tag: "div",
                    classes: ed.commentList
                },
                components: Nv(e, t, n),
                behaviours: _r([eh({
                    selector: Xu.card
                }), Eu.config({})])
            }],
            behaviours: _r([ad.config({
                find: e=>we(e.element).bind((t=>e.getSystem().getByDom(t).toOptional()))
            })]),
            apis: o
        }
    }
      , Fv = e=>{
        return {
            dom: {
                tag: "div",
                classes: ed.conversationsHead
            },
            components: [(t = e.translate(Bu.tc_conversations_title),
            {
                dom: {
                    tag: "div",
                    classes: ed.conversationsTitle
                },
                components: [ka(t)]
            })]
        };
        var t
    }
    ;
    var Dv;
    !function(e) {
        e[e.Start = 0] = "Start",
        e[e.Reply = 1] = "Reply"
    }(Dv || (Dv = {}));
    const Hv = Cs("tc-clear-input")
      , Iv = Cs("tc-submit-input")
      , Pv = (e,t)=>{
        const n = qi((e=>((e,t)=>Kp.sketch({
            tag: "textarea",
            inputClasses: ed.replyTextarea,
            inputAttributes: {
                ...th,
                placeholder: t.translate(Bu.tc_reply_placeholders)
            },
            inputStyles: nh,
            inputBehaviours: _r([Xp({
                enterEvent: e
            }), kd.config({}), Cr("reply-events", [nr(Co(), rh)]), ip.config({
                channels: {
                    ...lp(dn),
                    [En]: {
                        onReceive: rh
                    }
                }
            }), cp({
                disableWhileSaving: !0
            })])
        }))(Iv, e))(t))
          , o = {
            focusEditor: e=>{
                n.getOpt(e).each(dd.focus)
            }
            ,
            updateWith: (e,t,n)=>{
                U(t, (e=>e.mode === yp.Edit)) ? ua(e.element, "display", "none") : va(e.element, "display")
            }
        };
        return {
            dom: {
                tag: "div",
                classes: ed.replySection
            },
            behaviours: _r([Cr("reply-events", [nr(Hv, (e=>{
                n.getOpt(e).each((e=>{
                    Sd.setValue(e, "")
                }
                ))
            }
            )), nr(Iv, (t=>{
                n.getOpt(t).map(Sd.getValue).each((n=>{
                    n.length > 0 && Qo(t, uh.createCommentEvent, {
                        content: n,
                        mode: e
                    })
                }
                ))
            }
            ))])]),
            components: [n.asSpec(), gp({
                text: t.translate(Bu.tc_reply_buttons_clear),
                eventName: E.some(Hv),
                disableWhileSaving: !0
            }), mp({
                text: t.translate(Bu.tc_reply_buttons_comment),
                eventName: E.some(Iv),
                disableWhileSaving: !0
            })],
            apis: o
        }
    }
      , Vv = ()=>{
        let e = Sp();
        const t = t=>{
            e = t(e)
        }
        ;
        return {
            clearAll: ()=>{
                e = Sp()
            }
            ,
            recalibrate: e=>{
                t((t=>{
                    return n = t,
                    o = e.comments,
                    {
                        targetUid: n.targetUid,
                        conversation: j(o, (e=>({
                            uid: e.uid,
                            props: {
                                ...e,
                                stage: _p.Before,
                                mode: dr(n.targetUid, e.uid) ? yp.ExpandOrNone : yp.CollapsedOrNone
                            }
                        }))),
                        queue: []
                    };
                    var n, o
                }
                ))
            }
            ,
            enqueuePatch: (e,n)=>{
                t((t=>((e,t)=>Op(e, [t]))(t, {
                    uid: e,
                    patch: n
                })))
            }
            ,
            enqueuePatches: e=>{
                t((t=>Op(t, e)))
            }
            ,
            setTargetUid: e=>{
                t((t=>wp(t, E.some(e))))
            }
            ,
            clearTargetUid: ()=>{
                t((e=>wp(e, E.none())))
            }
            ,
            processQueue: ()=>(e=>{
                if (e.queue.length > 0) {
                    const t = (e=>{
                        const t = j(e.conversation, (t=>K(e.queue, (e=>e.uid === t.uid)).fold((()=>t), (e=>{
                            const n = void 0 !== e.patch.content ? {
                                mode: yp.ExpandOrNone
                            } : {};
                            return {
                                uid: t.uid,
                                props: {
                                    ...t.props,
                                    ...e.patch,
                                    ...n
                                }
                            }
                        }
                        ))));
                        return {
                            targetUid: e.targetUid,
                            conversation: t,
                            queue: []
                        }
                    }
                    )(e);
                    return E.some({
                        world: t,
                        props: xp(t)
                    })
                }
                return E.none()
            }
            )(e).map((({world: t, props: n})=>(e = t,
            n))),
            purge: e=>{
                t((t=>{
                    const n = $(t.conversation, (t=>t.uid !== e));
                    return {
                        ...t,
                        conversation: n
                    }
                }
                ))
            }
            ,
            getProps: ()=>xp(e),
            adjust: e=>{
                t((t=>Op(t, j(e, (e=>({
                    uid: e.uid,
                    patch: "to-delete" === e.type ? {
                        stage: _p.PostDelete
                    } : {}
                }))))))
            }
        }
    }
      , Wv = e=>({
        type: "redraw-sidebar",
        view: e
    })
      , Lv = Cs("tc-escapeInSidebar")
      , Uv = (e,t,n,o,r,s,a)=>{
        const i = e=>{
            v.get().each((t=>{
                "comments" === t.type && re(t.conversation.comments).each((({author: n, authorName: o, content: r, createdAt: s})=>{
                    e(t.conversation.uid, {
                        author: n,
                        authorName: o
                    }, r, a(t.conversation.uid), s)
                }
                ))
            }
            ))
        }
          , c = (e,t)=>{
            v.get().each((n=>{
                "comments" === n.type && K(n.conversation.comments, (t=>t.uid === e)).each((({author: e, authorName: n, content: o})=>{
                    t({
                        author: e,
                        authorName: n
                    }, o)
                }
                ))
            }
            ))
        }
          , l = Vv()
          , u = (()=>{
            const e = {};
            return {
                lookup: t=>je(e, t),
                store: (t,n)=>e[t] = n
            }
        }
        )()
          , d = ()=>{
            l.processQueue().each((e=>{
                w(e),
                b.getOpt(p).each((t=>{
                    t.getApis().updateWith(t, e, {})
                }
                ))
            }
            ))
        }
          , m = (e,t)=>{
            i(((n,o,r,s,a)=>e(n).get((e=>{
                e.fold((e=>e()), (e=>{
                    e(),
                    t(n, o, r, s, a)
                }
                ))
            }
            ))))
        }
          , g = (e,t)=>{
            e.get((e=>{
                e.fold((e=>e()), (e=>{
                    l.setTargetUid(e.targetUid),
                    e.fn(),
                    t(e.targetUid)
                }
                ))
            }
            ))
        }
          , p = Ra({
            dom: {
                tag: "div",
                classes: e,
                styles: {
                    position: "relative"
                }
            },
            behaviours: _r([Eu.config({}), Jp({
                onEscape: e=>(Yo(e, Lv),
                E.some(!0))
            }), Cr("sidebar-events", [nr(vp, ((e,t)=>{
                l.enqueuePatch(t.event.uid, t.event.patch)
            }
            )), nr(fp, ((e,t)=>{
                l.purge(t.event.uid),
                b.getOpt(p).each((e=>{
                    const t = l.getProps();
                    w(t),
                    e.getApis().updateWith(e, t, {})
                }
                ))
            }
            )), nr(bp, (()=>{
                d()
            }
            )), nr(Lv, (()=>{
                t.onEscape()
            }
            )), nr(uh.deleteConversationEvent, (()=>{
                m((e=>n.deleteConversation(e)), ((e,t,n,o,s)=>{
                    r({
                        type: "delete",
                        timestamp: vn(),
                        conversationUid: e,
                        conversationContext: o,
                        conversationContent: n,
                        conversationAuthor: t,
                        conversationCreatedAt: s
                    })
                }
                ))
            }
            )), nr(uh.deleteCommentEvent, ((e,t)=>{
                const o = t.event.uid;
                m((e=>n.deleteComment(e, o)), ((e,t,n,s,a)=>{
                    c(o, ((i,c)=>{
                        r({
                            type: "delete-comment",
                            timestamp: vn(),
                            conversationUid: e,
                            commentUid: o,
                            conversationContext: s,
                            conversationContent: n,
                            conversationCreatedAt: a,
                            commentContent: c,
                            commentAuthor: i,
                            conversationAuthor: t
                        })
                    }
                    ))
                }
                ))
            }
            )), nr(uh.resolveConversationEvent, (()=>{
                n.optResolveConversation.each((e=>{
                    m((t=>e(t)), ((e,t,n,o,s)=>{
                        r({
                            type: "resolve",
                            timestamp: vn(),
                            conversationUid: e,
                            conversationContext: o,
                            conversationContent: n,
                            conversationCreatedAt: s,
                            conversationAuthor: t
                        })
                    }
                    ))
                }
                ))
            }
            )), nr(uh.editCommentEvent, ((e,t)=>{
                const {uid: o, content: s} = t.event;
                i(((e,t,a,i,l)=>{
                    g(n.editComment(e, o, s), (()=>{
                        c(o, (n=>{
                            r({
                                type: "edit-comment",
                                timestamp: vn(),
                                conversationUid: e,
                                commentUid: o,
                                conversationContext: i,
                                conversationContent: a,
                                conversationCreatedAt: l,
                                commentContent: s,
                                commentAuthor: n,
                                conversationAuthor: t
                            })
                        }
                        ))
                    }
                    ))
                }
                ))
            }
            )), nr(uh.createCommentEvent, ((e,t)=>{
                const o = t.event.content;
                t.event.mode === Dv.Reply ? i(((e,t,s,a,i)=>{
                    g(n.reply(e, o), (n=>{
                        r({
                            type: "reply",
                            timestamp: vn(),
                            conversationUid: e,
                            commentUid: n,
                            conversationContext: a,
                            conversationContent: s,
                            conversationCreatedAt: i,
                            commentContent: o,
                            conversationAuthor: t
                        })
                    }
                    ))
                }
                )) : g(n.createConversation(o), (e=>{
                    r({
                        type: "create",
                        timestamp: vn(),
                        conversationUid: e,
                        conversationContext: a(e),
                        conversationContent: o
                    })
                }
                ))
            }
            ))])])
        })
          , h = $i(p)
          , v = hn(E.none())
          , f = e=>{
            Eu.set(p, [y.asSpec(), Fv(o)].concat(e))
        }
          , b = qi(Bv([], {
            getSink: e=>y.getOpt(e),
            universe: o,
            avatarCache: u
        }, s.useResolveConversation))
          , y = qi({
            dom: {
                tag: "div",
                styles: {
                    "z-index": "100"
                }
            },
            behaviours: _r([fu.config({})])
        })
          , _ = qi(Pv(Dv.Start, o))
          , x = qi(Pv(Dv.Reply, o))
          , w = e=>{
            x.getOpt(p).each((t=>{
                t.getApis().updateWith(t, e, {})
            }
            ))
        }
          , O = e=>{
            "splash" === e.view.type ? (l.clearAll(),
            f([_.asSpec()])) : "comments" === e.view.type && (l.recalibrate(e.view.conversation),
            f([b.asSpec(), x.asSpec()]),
            b.getOpt(p).each((e=>{
                const t = l.getProps();
                w(t),
                e.getApis().setComments(e, t),
                e.getApis().scrollToEnd(e)
            }
            )))
        }
        ;
        return {
            system: h,
            root: p,
            element: h.element,
            update: e=>{
                b.getOpt(p).bind((e=>v.get().map((t=>({
                    convUi: e,
                    pview: t
                }))))).fold((()=>O(e)), (({pview: t})=>{
                    const n = ((e,t)=>e.type !== t.type ? Wv(t) : "splash" === t.type ? {
                        type: "no-change"
                    } : ((e,t)=>{
                        if (e.conversation.uid === t.conversation.uid) {
                            const n = j(e.conversation.comments, (e=>e.uid))
                              , o = j(t.conversation.comments, (e=>e.uid));
                            return ((e,t,n=I)=>H(n).eq(e, t))(n, o) ? {
                                type: "refresh-comments",
                                comments: j(t.conversation.comments, (e=>({
                                    uid: e.uid,
                                    patch: {
                                        ...e
                                    }
                                })))
                            } : 0 === ee(o, n).length ? {
                                type: "remove-comments",
                                adjustments: j(n, (e=>({
                                    type: L(o, e) ? "to-remain" : "to-delete",
                                    uid: e
                                })))
                            } : Wv(t)
                        }
                        return Wv(t)
                    }
                    )(e, t))(t, e.view);
                    switch (n.type) {
                    case "add-comment":
                    case "redraw-sidebar":
                        O(e);
                        break;
                    case "no-change":
                        break;
                    case "remove-comments":
                        l.adjust(n.adjustments),
                        d();
                        break;
                    case "refresh-comments":
                        l.enqueuePatches(n.comments),
                        d()
                    }
                }
                )),
                v.set(E.some(e.view)),
                ku(p.element) && e.grabFocus() && x.getOpt(p).orThunk((()=>_.getOpt(p))).each((e=>{
                    e.getApis().focusEditor(e)
                }
                ))
            }
            ,
            hasFocus: ()=>Mr(p.element).isSome(),
            sendGlobalUiState: e=>{
                e.readonly && h.broadcastOn([S()], {
                    target: h.element
                }),
                h.broadcastOn([Cn], e)
            }
            ,
            getSink: y.getOpt
        }
    }
      , jv = (e,t)=>{
        e.execCommand("tc-delete-conversation-at-cursor", !1, {
            conversationUid: t
        })
    }
      , zv = (e,t,n,o)=>e.fold((e=>nt.error({
        message: t,
        error: e,
        refresh: o
    })), (e=>n(e).fold((e=>nt.error({
        message: e.permError,
        error: e.reason,
        refresh: o
    })), nt.value)))
      , $v = e=>je(e, "reason").getOr("");
    tinymce.Resource.add("tinymce.plugins.tinycomments.sidebar", ((e,t,n,o,s,a)=>{
        const i = ((e,t,n)=>{
            const o = e=>()=>{
                n().showError(e.message, e.error),
                e.refresh && e.refresh()
            }
            ;
            return {
                createConversation: r=>(n().setSaving(!0),
                at.wrap(e.create({
                    content: r,
                    createdAt: vn()
                }).map((e=>{
                    const r = nt.value
                      , s = p;
                    return n().setSaving(!1),
                    zv(e, Bu.tc_create_problem, r, s).fold((e=>nt.error(o(e))), (e=>nt.value({
                        targetUid: e.conversationUid,
                        fn: ()=>{
                            n().refreshReadonly() ? je(e, "onError").each((e=>e(new Error("Unable to create a new conversation")))) : (t.annotator.annotate(qe(), {
                                uid: e.conversationUid
                            }),
                            n().refreshSidebar(E.some(e.conversationUid), 3),
                            je(e, "onSuccess").each((t=>t(e.conversationUid))))
                        }
                    })))
                }
                )))),
                reply: (r,s)=>(n().setSaving(!0),
                at.wrap(e.reply({
                    conversationUid: r,
                    content: s,
                    createdAt: vn()
                }).map((e=>{
                    const s = nt.value
                      , a = p;
                    return n().setSaving(!1),
                    zv(e, Bu.tc_reply_problem, s, a).fold((e=>nt.error(o(e))), (e=>nt.value({
                        targetUid: e.commentUid,
                        fn: ()=>{
                            t.undoManager.dispatchChange(),
                            n().refreshSidebar(E.some(r), 3)
                        }
                    })))
                }
                )))),
                editComment: (t,r,s)=>(n().setSaving(!0),
                at.wrap(e.editComment({
                    conversationUid: t,
                    commentUid: r,
                    content: s,
                    modifiedAt: vn()
                }).map((e=>{
                    const s = p;
                    return n().setSaving(!1),
                    zv(e, Bu.tc_edit_problem_comment, (e=>e.canEdit ? nt.value(e) : nt.error({
                        permError: Bu.tc_edit_unauthorised_comment,
                        reason: $v(e)
                    })), s).fold((e=>nt.error(o(e))), (()=>nt.value({
                        targetUid: r,
                        fn: ()=>{
                            n().refreshSidebar(E.some(t), 4)
                        }
                    })))
                }
                )))),
                deleteComment: (t,r)=>at.wrap(e.deleteComment({
                    conversationUid: t,
                    commentUid: r
                }).map((e=>zv(e, Bu.tc_delete_problem_comment, (e=>e.canDelete ? nt.value(e) : nt.error({
                    permError: Bu.tc_delete_unauthorised_comment,
                    reason: $v(e)
                })), (()=>{
                    n().refreshSidebar(E.some(t), 4)
                }
                )).fold((e=>nt.error(o(e))), (()=>nt.value((()=>{
                    n().refreshSidebar(E.some(t), 4)
                }
                ))))))),
                deleteConversation: r=>at.wrap(e.deleteConversation({
                    conversationUid: r
                }).map((e=>zv(e, Bu.tc_delete_problem_conversation, (e=>e.canDelete ? nt.value(e) : nt.error({
                    permError: Bu.tc_delete_unauthorised_conversation,
                    reason: $v(e)
                })), (()=>{
                    n().refreshSidebar(E.some(r), 4)
                }
                )).fold((e=>nt.error(o(e))), (()=>nt.value((()=>{
                    jv(t, r),
                    n().refreshSidebar(E.none(), 2)
                }
                ))))))),
                optResolveConversation: e.resolveConversation.map((e=>r=>at.wrap(e({
                    conversationUid: r
                }).map((e=>zv(e, Bu.tc_resolve_problem_conversation, (e=>e.canResolve ? nt.value(e) : nt.error({
                    permError: Bu.tc_resolve_unauthorised_conversation,
                    reason: $v(e)
                })), (()=>{
                    n().refreshSidebar(E.some(r), 4)
                }
                )).fold((e=>nt.error(o(e))), (()=>nt.value((()=>{
                    jv(t, r),
                    n().refreshSidebar(E.none(), 2)
                }
                )))))))))
            }
        }
        )(t, e, (()=>u))
          , c = {
            useResolveConversation: t.resolveConversation.isSome()
        }
          , l = Uv(ed.roots, {
            onEscape: ()=>e.focus()
        }, i, a, ((e,t)=>n=>{
            const o = (e=>(t={})=>r(t.after) ? Sn(e, t.after) : Sn(e))(t);
            t.set(t.get().concat([n])),
            ((e,t)=>{
                const n = {
                    getEventLog: t
                };
                e.dispatch("CommentChange", n)
            }
            )(e, o)
        }
        )(e, o), c, (t=>((e,t)=>je(e.annotator.getAll(qe()), t).map((t=>j(t, (t=>((e,t)=>{
            const n = "SPAN" === t.nodeName;
            return e.serialize(t, {
                getInner: n,
                selection: !0
            })
        }
        )(e.serializer, t))).join(" "))).getOr(""))(e, t)))
          , u = pn(t, n, e, l)
          , d = e=>{
            l.system.broadcastOn([S()], {
                target: R(e.target)
            })
        }
        ;
        e.on("ResizeEditor", (()=>{
            l.system.broadcastOn([En], {})
        }
        ));
        const m = Me(R(document), "mousedown", (e=>{
            l.system.broadcastOn([S()], {
                target: e.target
            })
        }
        ));
        e.on("mousedown", d),
        e.on("remove", (()=>{
            e.off("mousedown", d),
            m.unbind()
        }
        )),
        s({
            controller: u,
            attachTo: e=>{
                Ne(e, l.element)
            }
        })
    }
    ))
}();
